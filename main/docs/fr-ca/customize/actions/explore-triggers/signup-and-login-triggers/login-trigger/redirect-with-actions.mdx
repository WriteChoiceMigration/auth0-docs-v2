---
og:description: Learn how to use post-login Actions to redirect users before an authentication
  transaction is complete.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Rediriger avec des actions
og:url: https://auth0.com/docs/
permalink: redirect-with-actions
title: Rediriger avec des actions
twitter:description: Learn how to use post-login Actions to redirect users before
  an authentication transaction is complete.
twitter:title: Rediriger avec des actions
---

Vous pouvez utiliser les actions post-connexion pour rediriger les utilisateurs avant la fin de la transaction d’authentification. Cela vous permet de mettre en œuvre des flux d’authentification personnalisés qui nécessitent une interaction supplémentaire avec l’utilisateur au-delà du formulaire de connexion standard.

Redirects are commonly used to do custom [Multi-factor Authentication (MFA)](/docs/secure/multi-factor-authentication) in Auth0, but they can also be used to:

* Permettre de personnaliser l’acceptation de la politique de confidentialité, les conditions de service et les formulaires de divulgation des données.
* Effectuer une collecte unique des données de profil supplémentaires requises en toute sécurité.
* Autoriser les utilisateurs d’Active Directory distants à modifier leur mot de passe.
* Demander aux utilisateurs de fournir une vérification supplémentaire lorsqu’ils se connectent à partir d’emplacements inconnus.
* Recueillir plus d’informations sur vos utilisateurs que celles fournies lors de l’inscription initiale.

## Présentation

À un niveau élevé, une action de redirection fonctionne de la manière suivante :

1. An Action issues a redirect to a URL.
2. The Actions pipeline is suspended after that Action completes its execution.
3. The user is redirected to the URL along with a `state` parameter.
4. When the external flow has concluded, the external site redirects the user to a `/continue` endpoint along with the `state` parameter.
5. The Actions pipeline is resumed on the same Action that invoked the redirect.

## Lancer une redirection

Appelez la fonction `api.redirect.sendUserTo()` comme suit :

```javascript lines
/**
* @param {Event} event - Details about the user and the context in which they are logging in.
* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
*/
exports.onExecutePostLogin = async (event, api) => {
  api.redirect.sendUserTo("https://my-app.exampleco.com");
};
```






Actions will finish the execution of this Action, and then suspend the actions pipeline to send the user to the `https://my-app.exampleco.com`. In other words, any Actions that are bound to the post-login triggers that run after the Action invoking the redirect will not execute until the authentication flow has been resumed. If you are familiar with Redirect Rules, then note that this is a key difference between Redirect Actions and Redirect Rules.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Unlike Redirect Rules, Redirect Actions will suspend the Actions pipeline when a redirect is issued and will resume in the same Action that issued the redirect when the authentication flow is continued.

</Callout>

Une fois l’action exécutée, Auth0 redirige l’utilisateur vers l’URL spécifiée dans la fonction `api.redirect.sendUserTo()`. Auth0 transmet également un paramètre `state` dans cette URL. Par exemple :

`https://my-app.exampleco.com/?state=abc123`

Your redirect URL will need to extract the `state` parameter and send it back to Auth0 to resume the authentication transaction. State is an opaque value used to prevent [Cross-Site Request Forgery (CSRF) attacks](/docs/secure/security-guidance/prevent-threats).

## Reprendre le flux d’authentification

Après la redirection, reprenez l’authentification en redirigeant l’utilisateur vers le point de terminaison `/continue` et incluez le paramètre `state` que vous avez reçu dans l’URL. Si vous ne renvoyez pas l’état initial au point de terminaison`/continue`, Auth0 perdra le contexte de la transaction de connexion et l’utilisateur ne pourra pas se connecter en raison d’une erreur `invalid_request`.

Par exemple :

`https://{yourAuth0Domain}/continue?state=THE_ORIGINAL_STATE`

In this example, `THE_ORIGINAL_STATE` is the value that Auth0 generated and sent to the redirect URL. For example, if your Action redirects to `https://my-app.exampleco.com/`, Auth0 would use a redirect URL similar to `https://my-app.exampleco.com/?state=abc123`, making `abc123` the `THE_ORIGINAL_STATE`. To resume the authentication transaction, you would redirect to:

`https://{yourAuth0Domain}/continue?state=abc123`

Lorsqu’un utilisateur a été redirigé vers le point de terminaison `/continue`, le pipeline d’actions recommence à la même action qui a invoqué la redirection en appelant la fonction `onContinuePostLogin`. Pour que les redirections fonctionnent correctement, vous devez créer une fonction avec la signature suivante dans l’action qui a invoqué la redirection :

```javascript lines
/**
* @param {Event} event - Details about the user and the context in which they are logging in.
* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
*/
exports.onExecutePostLogin = async (event, api) => {
  api.redirect.sendUserTo("https://my-app.exampleco.com");
};

/**
* @param {Event} event - Details about the user and the context in which they are logging in.
* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
*/

exports.onContinuePostLogin = async (event, api) => {
}
```






## Transmettre des données au site externe

To pass data to the external site, we recommend encoding that data in a signed [JWT](/docs/secure/tokens/json-web-tokens) so that your application can be certain it was not tampered with during transit. With Actions, this can be done with the `api.redirect.encodeToken` and `api.redirect.sendUserTo` functions:

```javascript lines expandable
/**
* @param {Event} event - Details about the user and the context in which they are logging in.
* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
*/
exports.onExecutePostLogin = async (event, api) => {
  const YOUR_AUTH0_DOMAIN = event.secrets.YOUR_AUTH0_DOMAIN || event.request.hostname

  // Craft a signed session token
  const token = api.redirect.encodeToken({
    secret: event.secrets.MY_REDIRECT_SECRET,
    expiresInSeconds: 60, 
    payload: {
      // Custom claims to be added to the token
      email: event.user.email,
      externalUserId: 1234,
      continue_uri: `https://${YOUR_AUTH0_DOMAIN}/continue`
    },
  });

  // Send the user to https://my-app.exampleco.com along
  // with a `session_token` query string param including
  // the email.
  api.redirect.sendUserTo("https://my-app.exampleco.com", {
    query: { session_token: token }
  });
}
```






Le code ci-dessus ajoute un paramètre de chaîne de requête `session_token` à l’URL utilisée pour la redirection (en plus du paramètre `state` ajouté automatiquement par Auth0). Ce jeton contiendra les éléments suivants :

<table class="table"><thead>
<tr>
<th>Token Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sub</code></td>
<td>Auth0 <code>user_id</code> of the user.</td>
</tr>
<tr>
<td><code>iss</code></td>
<td>Hostname of your Auth0 tenant domain (e.g., <code>example.auth0.com</code>).</td>
</tr>
<tr>
<td><code>exp</code></td>
<td>Expiration time (in seconds) specified with the <code>expiresInSeconds</code> parameter. Should be as short as possible to avoid re-use of the token. Defaults to 900 seconds (15 minutes).</td>
</tr>
<tr>
<td><code>ip</code></td>
<td>IP Address of the originating authentication request.</td>
</tr>
<tr>
<td><code>email</code></td>
<td>Custom claim with a value specified in the <code>payload.email</code> parameter.</td>
</tr>
<tr>
<td><code>externalUserId</code></td>
<td>Custom claim with a value specified in the <code>payload.externalUserId</code> parameter.</td>
</tr>
<tr>
<td><code>signature</code></td>
<td>Using the secret specified above, the token will be signed with HS256 algorithm.</td>
</tr>
</tbody>
</table>

### S’assurer que le jeton n’a pas été altéré

Le système externe doit vérifier que le jeton n’a pas été altéré pendant le transit. Pour ce faire, le système distant doit s’assurer que la signature du jeton est valide et, le cas échéant, que la session dans le système externe appartient au même utilisateur Auth0 que celui indiqué dans la demande `sub` du jeton.

## Renvoyer les données à Auth0

After the user completes the custom flow in the external site, they should be redirected to the `/continue` endpoint. In some situations, you may want to pass data back to Auth0 to impact the authentication or <Tooltip tip="Authorization Flow: Authorization grant (or workflow) specified in the OAuth 2.0 framework." cta="View Glossary" href="/docs/glossary?term=authorization+flow">authorization flow</Tooltip> for that user (for example, if you are implementing CAPTCHA checks or custom <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=MFA">MFA</Tooltip>).

### Utiliser les métadonnées de l’application dans la mesure du possible

If possible, the remote system should use the [Auth0 Management API](https://auth0.com/docs/api/management/v2/) to store custom information as application metadata on the Auth0 user profile. When the Auth0 Action flow is resumed, this information will be available on the `event.user.app_metadata` object. This approach avoids passing sensitive information to Auth0 on the front channel.

### Soyez sélectif lorsque vous stockez des données sur le profil utilisateur Auth0

Évitez de stocker trop de données dans le profil Auth0. Ces données sont destinées à des fins d’authentification et d’autorisation. Les métadonnées et les fonctionnalités de recherche d’Auth0 ne sont pas destinées à des scénarios nécessitant une fréquence de recherche ou de mise à jour élevée, comme les études de marché. Votre système risque de rencontrer des problèmes d’évolutivité et de performance si vous utilisez Auth0 à ces fins.

Si votre application nécessite l’accès à des données substantielles sur l’utilisateur, l’approche recommandée est de stocker ces données dans un système externe et de stocker une clé étrangère (ID de l’utilisateur) dans Auth0 afin que les systèmes principaux puissent récupérer les données en cas de besoin.

## Envoyer des données sur le canal frontal

Passing information back and forth in the front channel opens up surface area for <Tooltip tip="Bad Actors: Entity (a person or group) that poses a threat to the business or environment with the intention to cause harm." cta="View Glossary" href="/docs/glossary?term=bad+actors">bad actors</Tooltip> to attack. If information must be sent on the front channel, then consider the following guidance:

### Renvoyer des informations à l’action

Un jeton de session signé est nécessaire pour renvoyer des informations sensibles à Auth0. Vous pouvez facilement valider ce jeton dans une Action à l’aide du code suivant :

```javascript lines
/**
 * @param {Event} event - Details about the user and the context in which they are logging in.
 * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
 */
exports.onContinuePostLogin = async (event, api) => {
  const payload = api.redirect.validateToken({
    secret: event.secrets.PRECONFIGURED_SECRET,
    tokenParameterName: 'my_token',
  });

  // use the data encoded in the token, such as: 
  api.idToken.setCustomClaim('color', payload.favorite_color);
}
```






Le jeton sera validé pour s’assurer que :

* la signature est valide,
* le jeton n’a pas expiré.
* La demande `state` dans le jeton correspond au paramètre `state` utilisé dans le processus de redirection.

<table class="table"><thead>
<tr>
<th>Token Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sub</code></td>
<td>Auth0 <code>user_id</code> of the user.</td>
</tr>
<tr>
<td><code>iss</code></td>
<td>Application that is targeted for the redirect.</td>
</tr>
<tr>
<td><code>exp</code></td>
<td>Should be as short as possible to avoid reuse of the token.</td>
</tr>
<tr>
<td><code>state</code></td>
<td>state parameter sent to the remote site as part of the redirect. This must be included in the token to avoid replay attacks.</td>
</tr>
<tr>
<td><code>other</code></td>
<td>Any other custom claims will be exposed as the <code>payload</code> in the code above.</td>
</tr>
<tr>
<td><code>signature</code></td>
<td>Token should be signed with the HS256 algorithm.</td>
</tr>
</tbody>
</table>

Pour éviter les attaques par réinsertion, le jeton doit être renvoyé à Auth0 en effectuant une requête POST vers le point de terminaison `/continue`. L’option `tokenParameterName` dans le code vous permet de spécifier le nom du champ contenant votre jeton.

## Méthodes d’authentification personnalisées

Une fois la redirection réussie dans le pipeline de connexion, les actions peuvent enregistrer des événements relatifs aux méthodes d’authentification personnalisées dans la session de l’utilisateur. Le tableau `event.authentication.methods` contiendra une entrée pour la méthode personnalisée pendant toute la durée de la session dans le navigateur de l’utilisateur. Chaque entrée de ce tableau comporte un horodatage indiquant le moment où la méthode d’authentification a été enregistrée.

Une action personnalisée peut déclencher une redirection si la méthode personnalisée requise ne figure pas dans le tableau `event.authentication.methods` ou est trop ancienne.

Vous pouvez utiliser `api.redirect.sendUserTo()` pour diriger l’utilisateur vers une page qui implémente une méthode d’authentification personnalisée. Vous pouvez utiliser `api.authentication.recordMethod()` dans le gestionnaire `exports.onContinuePostLogin` pour stocker un enregistrement de la méthode complétée dans la session de l’utilisateur.

L’enregistrement stocké dans le tableau `event.authentication.methods` aura une propriété `name` qui correspond à l’URL choisie dans `api.authentication.recordMethod()`. L’URL capturée ici vous permet de rechercher dans les méthodes d’authentification terminées de la transaction en cours pour déterminer si votre méthode personnalisée a déjà été utilisée.

Votre flux de travail peut exiger que la méthode personnalisée soit ré-exécutée périodiquement pendant la durée de la session d’un utilisateur. Par exemple, les scénarios MFA personnalisés peuvent exiger une nouvelle vérification de la part de l’utilisateur après un délai donné.

L’exemple ci-dessous compare l’horodatage d’un enregistrement existant pour déterminer quand exécuter à nouveau la méthode personnalisée :

```javascript lines expandable
const CUSTOM_METHOD_URL = "https://path.to.prompt";
const PROMPT_TTL = 1000 * 60 * 60 * 24; // 24h

/**
 * Handler that will be called during the execution of a PostLogin flow.
 *
 * @param {Event} event - Details about the user and the context in which
 * they are logging in.
 * @param {PostLoginAPI} api - Interface whose methods can be used to
 * change the behavior of the login.
 */
exports.onExecutePostLogin = async (event, api) => {
  // Search authentication method records for an entry representing our
  // custom method.
  const methodRecord = event.authentication?.methods.find((record) =>
    validateCustomRecord(record, CUSTOM_METHOD_URL, PROMPT_TTL)
  );

  if (!methodRecord) {
    const sessionToken = api.redirect.encodeToken({
      payload: {
        user_id: event.user.user_id,
      },
      secret: event.secrets.SESSION_TOKEN_SECRET,
    });

    // We didn't find a valid record, so we send the user to the
    // URL that implements the custom method with the signed
    // data we encoded in `sessionToken`.
    api.redirect.sendUserTo(CUSTOM_METHOD_URL, {
      query: { session_token: sessionToken },
    });
  }
};

/**
 * Handler that will be invoked when this action is resuming after an
 * external redirect. If your onExecutePostLogin function does not perform
 * a redirect, this function can be safely ignored.
 *
 * @param {Event} event - Details about the user and the context in which
 * they are logging in.
 * @param {PostLoginAPI} api - Interface whose methods can be used to
 * change the behavior of the login.
 */
exports.onContinuePostLogin = async (event, api) => {
  const payload = api.redirect.validateToken({
    secret: event.secrets.SESSION_TOKEN_SECRET,
    tokenParameterName: "session_token",
  });

  if (!validateSessionToken(payload)) {
    return api.access.deny("Unauthorized");
  }

  // Record the completion of our custom authentication method.
  // THIS NEW API IS ONLY AVAILABLE IN `onContinuePostLogin`.
  api.authentication.recordMethod(CUSTOM_METHOD_URL);
};

function validateCustomRecord(record, url, ttl) {
  if (!record) {
    // No record means it isn't valid.
    return false;
  }

  if (record.url !== url) {
    // This isn't a record of our custom method.
    return false;
  }

  // Timestamps are rendered as ISO8601 strings.
  const timestamp = new Date(record.timestamp);

  // The record is valid if it was recorded recently enough.
  return timestamp.valueOf() >= Date.now() - ttl;
}

function validateSessionToken(payload) {
  // Custom validation logic for the data returned by the
  // custom method goes here.
  return true;
}
```






L’API `api.authentication.recordMethod()` n’est disponible que dans le gestionnaire `exports.onContinuePostLogin`. Cette méthode permet d’éviter les tentatives d’attaque par connexion en enregistrant la méthode personnalisée après avoir effectué la redirection.

## Restrictions et limites

Les actions de redirection ne fonctionnent pas avec :

* [Resource Owner endpoint](https://auth0.com/docs/api/authentication/reference#resource-owner)
* [Password exchange](/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)
* [Refresh Token exchange](/docs/secure/tokens/refresh-tokens)

### Le point de terminaison du propriétaire de la ressource.

It is impossible to use redirect Actions when you are calling the Authentication API [Get Token](https://auth0.com/docs/api/authentication#resource-owner-password) endpoint for the <Tooltip tip="Resource Owner: Entity (such as a user or application) capable of granting access to a protected resource." cta="View Glossary" href="/docs/glossary?term=Resource+Owner">Resource Owner</Tooltip> Password flow. Since the user is not in a redirect flow to begin with, you can not redirect the user in an Action.

### Flows where prompt=none

L’objectif de `prompt=none` étant d’éviter tout scénario dans lequel l’utilisateur doit saisir des données, toute redirection se traduit par `erreur=interaction_required`.

Comme les actions sont exécutées après la création d’une session d’authentification, vous ne pouvez pas utiliser `prompt=none` si vous avez une règle de redirection qui tente de bloquer l’accès aux jetons sous certaines conditions (authentification multifacteur personnalisée, CAPTCHA à la connexion, etc.).

Vous ne pouvez pas créer un flux de redirection qui bloque l’accès aux jetons et contourne l’action de redirection si `prompt=none`. Après une tentative infructueuse, un utilisateur peut appeler à nouveau avec `prompt=none` et obtenir des jetons parce que sa session d’authentification a été créée, même si les actions ont échoué la première fois.

### Jetons d’actualisation

Due to the fact that using a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=refresh+token">refresh token</Tooltip> requires a back-channel call to the Authentication API [Get Token](https://auth0.com/docs/api/authentication#refresh-token) endpoint, this will also fail if attempting to redirect.

Il est difficile de vérifier de manière sûre que les restrictions de connexion ont été appliquées. Aucun identifiant de session cohérent dans le contexte ne peut être utilisé pour collecter des informations associées à la session, comme les défis MFA résolus par cet utilisateur. Par conséquent, vous ne pouvez absolument pas utiliser `prompt=none`.

Chaque fois que `api.redirect.sendUserTo()` est appelé dans une action, si `prompt=none` a été transmis, l’autorisation échoue avec `error=interaction_required`. Cependant, comme la session de l’utilisateur est créée même si les actions échouent, vous ne pouvez pas être sûr qu’un utilisateur a relevé tous les défis en matière de redirection. Vous ne pouvez donc pas utiliser `prompt=none` pour obtenir des jetons.

Dans ce cas précis, nous vous recommandons d’utiliser exclusivement les jetons d’actualisation, qui permettent de s’assurer que l’utilisateur a répondu correctement aux défis si ceux-ci sont requis pour générer un jeton d’actualisation.

## Learn more

* [Manage User Metadata with the post-login Action Trigger](/docs/manage-users/user-accounts/metadata/manage-user-metadata)