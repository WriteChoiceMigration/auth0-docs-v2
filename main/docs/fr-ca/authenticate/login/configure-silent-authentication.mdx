---
og:description: Learn how to keep users logged in to your application using silent
  authentication.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Configurer l’authentification silencieuse
og:url: https://auth0.com/docs/
permalink: configure-silent-authentication
title: Configurer l’authentification silencieuse
twitter:description: Learn how to keep users logged in to your application using silent
  authentication.
twitter:title: Configurer l’authentification silencieuse
---

Le [protocole OpenID Connect](/protocols/openid-connect-protocol) prend en charge un paramètre `prompt=none` sur la demande d’authentification qui permet aux applications d’indiquer que le serveur d’autorisation ne doit afficher aucune interaction utilisateur (telle que l’authentification, le consentement ou la MFA). Auth0 renverra soit la réponse demandée à l’application, soit une erreur si l’utilisateur n’est pas déjà authentifié ou si un type de consentement ou d’invite est requis avant de continuer.

L’utilisation du [flux implicite](/login/flows/implicit-flow-with-form-post) dans les applications Web monopages soulève des problèmes de sécurité qui doivent être résolus par des mesures correctives explicites. Vous pouvez utiliser le [Flux de code d’autorisation avec PKCE](/login/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce) en conjonction avec l’authentification silencieuse pour renouveler les sessions dans les applications Web monopages.



## Lancer des demandes d’authentification silencieuse

Pour lancer une demande d’authentification silencieuse, ajoutez le paramètre `prompt=none` lorsque vous redirigez un utilisateur vers le point de terminaison [`/authorize` d’Authentication API Auth0](/api/authentication#authorize-application). (Les paramètres individuels de la demande d’authentification varient en fonction des besoins particuliers de votre application.)

Par exemple :



Le paramètre `prompt=none` oblige Auth0 à envoyer immédiatement un résultat à la `redirection_uri` (URL de rappel) indiquée, en utilisant le `response_mode` indiqué, avec l’une des deux réponses possibles : réussite ou erreur.



### Réponses d’authentification réussie

Si l’utilisateur était déjà connecté à Auth0 et qu’aucune autre invite interactive n’est requise, Auth0 répondra exactement comme si l’utilisateur s’était authentifié manuellement à partir de la page de connexion.

Par exemple, lors de l’utilisation du flux implicite (`response_type=id_token jeton`, utilisé pour les applications à page unique), Auth0 répondra avec les jetons demandés :



Cette réponse est indiscernable d’une connexion effectuée directement sans le paramètre `prompt=none`.

### Réponses d’erreur

Si l’utilisateur n’est pas connecté via l’authentification unique (SSO) ou si sa session SSO a expiré, Auth0 le redirigera vers la `redirection_uri` (URL de rappel) en affichant une erreur :



Les valeurs possibles pour `ERROR_CODE` sont définies par les [Spécifications OpenID Connect](https://openid.net/specs/openid-connect-core-1_0.html#AuthError) :



Si l’une de ces erreurs est renvoyée, l’utilisateur doit être redirigé vers la page de connexion Auth0 sans le paramètre `prompt=none` à authentifier.

## Renouveler les jetons expirés

Vous pouvez effectuer une demande d’authentification silencieuse pour obtenir de nouveaux jetons tant que l’utilisateur dispose toujours d’une session valide sur Auth0. La méthode [`checkSession`](/libraries/auth0js)[de auth0.js](/libraries/auth0js) utilise une requête de jeton silencieuse en combinaison avec `response_mode=web_message` pour les application Web monopages afin que la requête se produise dans un iframe caché. Avec les application Web monopages, Auth0.js gère le traitement des résultats (soit le jeton, soit le code d’erreur) et transmet les informations à l’aide d’une fonction de rappel fournie par l’application. Cela n’entraîne aucune perturbation de l’expérience utilisateur (pas d’actualisation de page ni de perte d’état).



### Expiration du jeton d’accès

Les jetons d’accès sont opaques pour les applications. Cela signifie que les applications ne peuvent pas inspecter le contenu des jetons d’accès pour déterminer leur date d’expiration.

Il existe deux façons de déterminer la date d’expiration d’un jeton d’accès :

* Lisez le paramètre de réponse `expires_in` renvoyé par Auth0.
* Ignorez complètement les dates d’expiration. Renouveler plutôt le jeton d’accès si votre API rejette une demande de l’application (par exemple avec un code d’erreur 401).

Dans le cas d’un [Flux implicite](/login/flows/implicit-flow-with-form-post), le paramètre `expires_in` est renvoyé par Auth0 sous forme de paramètre de hachage suite à une authentification réussie. Dans le [Flux de code d’autorisation avec PKCE](/login/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce), il est renvoyé au serveur dorsal lors de l’exécution de l’échange de code d’autorisation.

Le paramètre `expires_in` indique combien de secondes le jeton d’accès sera valide et peut être utilisé pour anticiper l’expiration du jeton d’accès.

### Réponses d’erreur

Vous pourriez recevoir une réponse d’erreur de type `timeout`, indiquant  que le délai d’exécution de la communication `web_message` s’est écoulé. Cette erreur est généralement associée à un retour à l’authentification cross-origin. Pour résoudre ce problème, assurez-vous d’ajouter toutes les URL à partir desquelles vous souhaitez effectuer une authentification silencieuse dans le champ **Origines Web autorisées** pour votre application à l’aide d’Auth0 Dashboard.

## Interroger avec `checkSession()`



## Authentification silencieuse avec l’authentification multifacteur (MFA)

Dans certaines situations, vous pourriez ne pas vouloir demander à l’utilisateur d’avoir recours à l’[Authentification multifacteur (MFA)](/mfa) chaque fois qu’il se connecte à partir du même navigateur. Pour ce faire, configurez une action afin que la MFA ne se produise qu’une seule fois par session. Ceci est utile lors de l’exécution d’une authentification silencieuse (`prompt=none`) pour renouveler les jetons d’accès de courte durée dans une application Web monopage pendant la durée de la session d’un utilisateur sans avoir à définir le paramètre `allowRememberBrowser` sur `true (vrai)`.



Pour en savoir plus, veuillez consulter [Modifier la fréquence des demandes d’authentification](/mfa/customize-mfa-user-pages).