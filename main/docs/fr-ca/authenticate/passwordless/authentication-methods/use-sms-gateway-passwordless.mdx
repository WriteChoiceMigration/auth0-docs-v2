---
og:description: Learn how to set up a custom SMS gateway for Passwordless connections.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Configurer une passerelle SMS personnalisée pour les connexions sans mot
  de passe
og:url: https://auth0.com/docs/
permalink: use-sms-gateway-passwordless
title: Configurer une passerelle SMS personnalisée pour les connexions sans mot de
  passe
twitter:description: Learn how to set up a custom SMS gateway for Passwordless connections.
twitter:title: Configurer une passerelle SMS personnalisée pour les connexions sans
  mot de passe
---

Ce guide vous montrera comment utiliser une passerelle SMS personnalisée pour envoyer vos codes à usage unique.

By default, [Passwordless SMS connections](/docs/authenticate/passwordless/authentication-methods/sms-otp) use [Twilio](https://www.twilio.com) to send out one-time use codes. However, if you have a custom SMS gateway, you can modify your connection to use that instead.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0 does not support basic SMS authentication.

</Callout>

1. Set up a SMS passwordless connection. To learn how, read the Implement Passwordless section in [Passwordless Connections](/docs/authenticate/passwordless).
2. [Get an Access Token for the Management API](/docs/secure/tokens/access-tokens/management-api-access-tokens). You will need this to make calls to the Management API to update your Passwordless connection.
3. Use the [GET Connections](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) endpoint to retrieve information about the connections associated with your tenant. More specifically, you need to get the ID for your Passwordless SMS connection so that you can use it in a later API call that updates the connection itself.
   Veillez à remplacer `ACCESS_TOKEN` par le jeton obtenu à l’étape 1 avant d’effectuer l’appel suivant au Management API :

<CodeGroup>
```bash cURL lines
curl --request GET \
  --url https://your-auth0-tenant.com/api/v2/connections \
  --header 'authorization: Bearer {yourAccessToken}'
```
```csharp C# lines
var client = new RestClient("https://your-auth0-tenant.com/api/v2/connections");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourAccessToken}");
IRestResponse response = client.Execute(request);
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://your-auth0-tenant.com/api/v2/connections"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.get("https://your-auth0-tenant.com/api/v2/connections")
  .header("authorization", "Bearer {yourAccessToken}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://your-auth0-tenant.com/api/v2/connections',
  headers: {authorization: 'Bearer {yourAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://your-auth0-tenant.com/api/v2/connections"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://your-auth0-tenant.com/api/v2/connections",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("your-auth0-tenant.com")

headers = { 'authorization': "Bearer {yourAccessToken}" }

conn.request("GET", "/api/v2/connections", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://your-auth0-tenant.com/api/v2/connections")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = ["authorization": "Bearer {yourAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://your-auth0-tenant.com/api/v2/connections")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

   La réponse du point de terminaison sera un tableau d’objets. Chaque objet représente une connexion affiliée à votre locataire.
4. Identify your connection ID. You can find the ID associated with your Passwordless connection by reviewing the array of objects you returned from the [GET Connections endpoint](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) in step 2.
   Pour trouver l’objet propre à votre connexion sans mot de passe, vous pouvez rechercher la propriété `"name": "sms"`. Notez que la connexion affiche actuellement les informations Twilio que vous avez fournies au cours du processus d’installation.

   ```json lines expandable
   [
       {
           "id": "con_UX85K7K0N86INi9U",
           "options": {
               "disable_signup": false,
               "name": "sms",
               "twilio_sid": "TWILIO_SID",
               "twilio_token": "TWILIO_AUTH_TOKEN",
               "from": "+15555555555",
               "syntax": "md_with_macros",
               "template": "Your SMS verification code is: @@password@@",
               "totp": {
                   "time_step": 300,
                   "length": 6
               },
               "messaging_service_sid": null,
               "brute_force_protection": true
           },
           "strategy": "sms",
           "name": "sms",
           "is_domain_connection": false,
           "realms": [
               "sms"
           ],
           "enabled_clients": []
       }
   ]
   ```


   

   
5. Update the connection. You can do this by making a PATCH call to the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). More specifically, you'll be updating the connections `options` object to provide information about the SMS Gateway.

   <Warning>

   You must send the entire `options` object with each call; otherwise, you will overwrite the existing data that is not included in subsequent calls.

   </Warning>

   Apportez les modifications suivantes :
   * Supprimez les paramètres `twilio_sid` et `twilio_token`.
   * Ajoutez le paramètre `provider` et attribuez-lui la valeur `sms_gateway`)
   * Ajoutez le paramètre `gateway_url`, et définissez-le à l’URL de votre passerelle SMS. Auth0 doit être capable d’atteindre cette URL pour pouvoir utiliser votre passerelle et envoyer des messages en votre nom.

   Votre charge utile ressemblera à ceci :

   ```json lines
   {
       "options": {
         "strategy": "sms",
         "provider": "sms_gateway",
         "gateway_url": "{urlOfYourGateway}",
         "from": "+1 234 567",
         "template": "Your verification code is: @@password@@",
         "brute_force_protection": true,
         "forward_req_info": "true",
         "disable_signup": false,
         "name": "sms",
         "syntax": "md_with_macros",
         "totp": {
           "time_step": 300,
           "length": 6
         }
       },
       "is_domain_connection": false,
       "enabled_clients": []
   }
   ```


   

   

## Demandes authentifiées

Si votre passerelle SMS accepte les demandes authentifiées basées sur des jetons, vous pouvez ajouter ce qui suit à votre objet `options` :

```json lines
"gateway_authentication": {
    "method": "bearer",
    "subject": "urn:Auth0",
    "audience": "urn:MySmsGateway",
    "secret": "MySecretToSignTheToken",
    "secret_base64_encoded": false
}
```






When you include `gateway_authentication` in your `options` object, Auth0 adds a [JSON Web Token](/docs/secure/tokens/json-web-tokens) to the `Authorization` header whenever it sends requests to your SMS gateway. The token contains the `gateway_authentication.subject` and `gateway_authentication.audience` values, and is signed with `gateway_authentication.secret`.

Si votre secret est encodé en base64-url, définissez `secret_base64_encoded` sur `true`.

Once you have updated your connection, Auth0 will send the following to your SMS Gateway every time a user signs up or logs in with your <Tooltip tip="Passwordless: Form of authentication that does not rely on a password as the first factor." cta="View Glossary" href="/docs/glossary?term=Passwordless">Passwordless</Tooltip> connection.

```json lines
{
  "recipient": "+1 399 999",
  "body": "Your verification code is: 12345",
  "sender": "+1 234 567"
}
```






Si vous définissez la propriété `forward_req_info` de l’objet `options` sur `true`, la passerelle recevra également des informations de la requête HTTP qui a initié le processus sans mot de passe. Ces informations comprennent l’adresse IP du client appelant `/passwordless/start` et son agent utilisateur.

```json lines
{
  "recipient": "+1 399 999",
  "body": "Your verification code is: 12345",
  "sender": "+1 234 567",
  "req" : { 
      "ip" : "167.56.227.117",
      "user-agent" : "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36"
       }
}
```






## Gestion des erreurs

Auth0 ne prend en compte que le code HTTP renvoyé par la passerelle SMS; le reste de la réponse est ignoré (p. ex., le corps et le type de la réponse).

Si la passerelle SMS renvoie un code HTTP autre que 200, le point de terminaison `/passwordless/start` renvoie un code HTTP 400 et une réponse qui ressemble à ce qui suit :

```json lines
{
 "error":"sms_provider_error",
 "error_description":"Unexpected response while calling the SMS gateway: <HTTP Code Returned by the SMS Gateway>"}
}
```






Si la passerelle SMS renvoie le code HTTP 401, la `error_description` sera **Échec de l’authentification lors de l’appel à la passerelle SMS : 401**. (Veuillez noter que le texte de la description de l’erreur est susceptible d’être modifié à tout moment).

Auth0 enforces a timeout of 30 seconds for HTTP calls to custom SMS Gateways. If the SMS Gateway fails to reply within this time frame, the `/passwordless/start` endpoint will also return an HTTP 400 code. The response will have the format shown above and the `error_description` field will be **Timeout while calling the SMS gateway: \<Timeout Code>**. (Again, the error description verbiage is subject to change at any time.)