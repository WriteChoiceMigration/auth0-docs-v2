---
og:description: Learn about Custom Token Exchange Early Access features.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Accès anticipé à l’échange de jetons personnalisé
og:url: https://auth0.com/docs/
permalink: custom-token-exchange
title: Accès anticipé à l’échange de jetons personnalisé
twitter:description: Learn about Custom Token Exchange Early Access features.
twitter:title: Accès anticipé à l’échange de jetons personnalisé
---

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange is currently in Early Access for Enterprise customers only. Reach out to your Auth0 contact to request access. To learn more about Auth0's product release cycle, read [Product Release Stages](/docs/troubleshoot/product-lifecycle/product-release-stages).

</Callout>

As defined in [RFC 8693](https://datatracker.ietf.org/doc/html/rfc8693), Custom Token Exchange allows you to enable applications to exchange their existing tokens for Auth0 tokens when calling the `/oauth/token` endpoint. This is useful for advanced integration use cases, such as:

* Get Auth0 tokens for another <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip>
* Integrate an external <Tooltip tip="Identity Provider (IdP): Service that stores and manages digital identities." cta="View Glossary" href="/docs/glossary?term=identity+provider">identity provider</Tooltip>
* Migration vers Auth0

Pour en savoir plus, consultez [Exemples de cas d’utilisation et exemples de code](#example-use-cases-and-code-samples).

To govern the token exchange and adjust it to the specific needs of your use case, you can define one or more [Custom Token Exchange Profiles](#custom-token-exchange-profile). Each profile establishes a one-to-one mapping between a `subject_token_type`, which provides information about the user for the transaction, and an [Action](/docs/customize/actions/actions-overview). In that Action, you can write custom code to decode and validate subject tokens passed to the `/oauth/token` endpoint.

You can use Custom Token Exchange to authenticate users. For example, in an Action, you can apply the authorization logic for your use case and set the user for the transaction. Auth0 will then issue access, ID, and <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=refresh+tokens">refresh tokens</Tooltip> for the user.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange gives you the added flexibility to set the user for the transaction by taking on the additional responsibility of securely validating the corresponding subject token that identifies the user for the transaction.

Remember that subject tokens used with Custom Token Exchange can be any token format or type you require, as long as your Action code can interpret them. **You must implement strong validation of the tokens you receive and accept.** If you fail to do so, you open yourself up to different attack vectors, such as spoofing or replay attacks, resulting in bad actors being able to authenticate with someone else’s user ID.

To learn about different options for implementing secure validation of your subject tokens, read and apply the recommendations included in [Example Use Cases and Code Samples](#example-use-cases-and-code-samples). Make sure you also take into consideration and apply [Attack Protection](#attack-protection) capabilities.

</Callout>

## Configuration

### Application

To use Custom Token Exchange, you must [create a new application](/docs/get-started/auth0-overview/create-applications) with the <Tooltip tip="Auth0 Dashboard: Auth0's main product to configure your services." cta="View Glossary" href="/docs/glossary?term=Auth0+Dashboard">Auth0 Dashboard</Tooltip> or the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip>. You can create multiple applications to use Custom Token Exchange.

Lorsque vous créez une nouvelle application :

1. By default, Custom Token Exchange is disabled. To enable Custom Token Exchange, use the Management API to make a POST call to [Create a Client](https://auth0.com/docs/api/management/v2/clients/post-clients) or a PATCH call to [Update a Client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id). Set the `allow_any_profile_of_type` attribute under `token_exchange` to `["custom_authentication"]`:

```json lines
{
  "token_exchange": {
    "allow_any_profile_of_type": ["custom_authentication"]
  }
}
```






2. Enable the [database connection](/docs/authenticate/database-connections) or [enterprise connection](/docs/authenticate/enterprise-connections) you want to use with Custom Token Exchange for the application.

3. Make sure your application is flagged as [First-Party](/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications) and it is configured as [OIDC Conformant in Dashboard > Applications > Advanced Settings > OAuth](/docs/get-started/applications/application-settings#oauth).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom DBs with [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) enabled are only supported for `setUserById` operations.

</Callout>

Une fois l’application créée, notez le `client_id` et le `client_secret` pour une utilisation ultérieure lors de l’appel du point de terminaison `/oauth/token`.

### Profil de l’échange de jeton personnalisé

Chaque profil d’échange de jetons personnalisé est mappé à un `subject_token_type` et est associé à une action qui contient la logique du code pour ce cas d’utilisation.

Les demandes d’échange de jetons personnalisé envoyées au point de terminaison `/oauth/token` avec une valeur spécifique `subject_token_type` sont mappées au profil de jeton personnalisé correspondant et acheminées vers l’action associée pour traitement.

Pour créer un profil d’échange de jetons personnalisé, créez d’abord une Action pour le profil.

#### Créer une Action

Dans Auth0 Dashboard :

1. Navigate to [**Actions > Library**](https://manage.auth0.com/#/actions/library).

2. Select **Create Action** > **Build from Scratch**.

3. In the **Create Action** dialog, enter a name and select the **Custom Token Exchange** trigger from the drop-down.

<Frame>![](/images/cdy7uua7fh8z/22vz9dsCFj5Ruot7U0HIVx/1c3dc4b562334dab9d6ac415028ea76e/Screenshot_2025-02-05_at_8.48.34_AM.png)</Frame>

4. Select **Create**.

5. **Deploy** the Action.

<Frame>![](/images/cdy7uua7fh8z/56NZA69Gmzha167xfgRD0W/302e59276815d2e2644ab2da3b9b5f1f/Screenshot_2025-02-03_at_10.29.17_AM.png)</Frame>

Lors du déploiement de l’action, Auth0 lui attribue un identifiant. Vous devez encore ajouter votre logique personnalisée à l’action, mais commencez par obtenir l’identifiant de l’action pour créer le profil d’échange de jetons personnalisé.

6. To get the Action ID in the Auth0 Dashboard, navigate to the URL of the browser window. The Action ID should be the last part of the URL, as shown in the following image:

<Frame>![](/images/cdy7uua7fh8z/1Xx4UbgZR0FIuLC1KVvhKG/bde4469d770c2ff8d37c19895a0c8e66/Screenshot_2025-02-03_at_10.31.18_AM.png)</Frame>

You can also get the Action ID via the Management API. First, [get a Management API token](/docs/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens) to consume the API. Then, make the following GET request to the `/actions` endpoint:

```bash lines
curl --location 'https://{{YOUR _TENANT}}/api/v2/actions/actions?actionName={{ACTION_NAME}}' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
```






Vous devriez recevoir l’identifiant de l’action dans le corps de la réponse, dans `actions[0].id`. Vous avez besoin de l’identifiant de l’action pour créer le profil d’échange de jetons personnalisé.

#### Créer le profil d’échange de jetons personnalisé

Pour créer le profil d’échange de jetons personnalisé, utilisez Management API pour effectuer une requête POST avec les paramètres suivants sur le point de terminaison `/token-exchange-profiles` :

```bash lines
curl --location 'https://{{YOUR _TENANT}}/api/v2/token-exchange-profiles' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
--data '{
    "name": "{{PROFILE_NAME}}",
    "subject_token_type": "{{UNIQUE_PROFILE_TOKEN_TYPE_URI}}",
    "action_id": "{{ACTION_ID}}",
    "type": "custom_authentication"
}'
```






<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>subject_token_type</code></td>
<td>Unique profile token type URI starting with `https://` or <code>urn</code><br/><br/>The following namespaces are reserved and you can’t use them:<br/><br/><ul><li>`http://auth0.com`</li><li>`https://auth0.com`</li><li>`http://okta.com`</li><li>`https://okta.com`</li><li><code>urn:ietf</code></li><li><code>urn:auth0</code></li><li><code>urn:okta</code></li></ul></td>
</tr>
<tr>
<td><code>action_id</code></td>
<td>Action ID of Action associated with the Custom Token Profile.</td>
</tr>
<tr>
<td><code>type</code></td>
<td>Should be set to <code>custom_authentication</code>.</td>
</tr>
</tbody>
</table>

Si vous avez créé avec succès un profil d’échange de jetons personnalisé, vous devriez recevoir une réponse similaire à celle-ci :

```json lines
{
  "id":"tep_9xqewuejpa2RTltf",
  "name":"{{PROFILE_NAME}}",
  "type":"custom_authentication",
  "subject_token_type":"{{UNIQUE_PROFILE_TOKEN_TYPE_URI}}",
  "action_id":"{{ACTION_ID}}",
  "created_at":"2025-01-30T13:19:00.616Z",
  "updated_at":"2025-01-30T13:19:00.616Z"
}
```






Vous êtes prêt à commencer à coder et à tester votre échange de jetons personnalisé pour mettre en œuvre votre cas d’utilisation.

### Gérer le profil d’échange de jetons personnalisé

Pour gérer votre profil d’échange de jetons personnalisé, utilisez Management API pour effectuer des requêtes au point de terminaison `/token-exchange-profiles`.

To get all your Custom Token Exchange Profiles, make the following request. This endpoint supports [checkpoint pagination](https://auth0.com/docs/api/management/v2/introduction#checkpoint-based-pagination) in case you have several profiles.

```bash lines
curl --location 'https://{{YOUR _TENANT}}/api/v2/token-exchange-profiles' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
```






Pour mettre à jour le `name` ou le `subject_token_type` d’un profil d’échange de jetons personnalisé, utilisez la requête PATCH suivante. Vous ne pouvez pas modifier l’identifiant de l’action, mais vous pouvez modifier le code personnalisé qu’il exécute avec l’éditeur d’actions :

```bash lines
curl --location --request PATCH 'https://{{YOUR _TENANT}}/api/v2/token-exchange-profiles/{{PROFILE_ID}}' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
--data '{
    "name": "external-idp-migration",
    "subject_token_type": "urn:partner0:external-idp-migration"
}'
```






Pour supprimer un profil d’échange de jetons personnalisé, effectuez la demande DELETE suivante :

```bash lines
curl --location --request DELETE 'https://{{YOUR _TENANT}}/api/v2/token-exchange-profiles/{{PROFILE_ID}}' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
--data ''
```






## Actions API

### Échange de jetons personnalisé par rapport à Action post-connexion

L’action d’échange de jetons personnalisé, accessible dans le cadre de l’accès anticipé à l’échange de jetons personnalisé, peut utiliser les nouvelles méthodes API répertoriées dans [Utiliser Actions API](#use-the-actions-api).

For other needs, such as adding custom claims to <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip>, your [Post Login Actions trigger](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger) executes after the Custom Token Exchange Action runs for the user that you set for the transaction, thus giving you the same functionality as other login flows.

To identify a transaction that uses the token exchange grant type, look for an `event.transaction.protocol` value equal to `oauth2-token-exchange` in your [Post Login Action](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger). Because the token exchange grant type is used by both the Custom Token Exchange and Native Social Login transactions, you can use the value of the `subject_token_type` to distinguish between the two, where the `subject_token_type` corresponds to one of your Custom Token Exchange Profiles.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange Early Access does not support [multi-factor authentication](/docs/secure/multi-factor-authentication). Enabling MFA as a tenant policy or using `api.multifactor.enable()`, `api.authentication.challengeWith(),` or `api.authentication.enrollWith()` is not yet supported for Custom Token Exchange and, within your Post-Login Action trigger, will result in the transaction failing with a non-recoverable error. Make sure you skip enabling MFA when `event.transaction.protocol==oauth2-token-exchange` depending on the `subject_token_type` value.

MFA support will be added in next iterations of Custom Token Exchange EA.

</Callout>

### Utiliser Actions API

Auth0 fournit plusieurs méthodes API à utiliser avec votre action d’échange de jetons. Vous devez implémenter une action qui décode et valide le jeton du sujet en fonction du `subject_token_type`. Cela vous fournira des informations sur l’utilisateur de la transaction. Grâce à ces informations, votre code devra également appliquer la politique d’autorisation requise pour la transaction. Une fois que vous êtes certain que la transaction peut se poursuivre, vous pouvez la confirmer en définissant l’utilisateur correspondant. Auth0 émettra alors des jetons d’accès, d’ID et d’actualisation pour cet utilisateur. Vous pouvez considérer cela comme un moyen d’authentifier les utilisateurs.

Chaque transaction d’échange de jetons personnalisé génère un journal des événements de locataire. Les transactions réussies génèrent des journaux d’événements de type `secte`, tandis que les transactions échouées génèrent des journaux d’événements de type `fecte`. Utilisez ces types de journaux pour mieux comprendre les erreurs que vous pourriez rencontrer. Les erreurs provenant du point de terminaison `/oauth/token` révèlent moins de détails.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange gives you the added flexibility to set the user for the transaction by taking on the additional responsibility of securely validating the corresponding subject token that identifies the user for the transaction.

Remember that subject tokens used with Custom Token Exchange can be any token format or type you require, as long as your Action code can interpret them. **You must implement strong validation of the tokens you receive and accept.** If you fail to do so, you open yourself up to different attack vectors, such as spoofing or replay attacks, resulting in bad actors being able to authenticate with someone else’s user ID.

To learn about different options for implementing secure validation of your subject tokens, read and apply the recommendations included in [Example Use Cases and Code Samples](#example-use-cases-and-code-samples). Make sure you also take into consideration and apply [Attack Protection](#attack-protection) capabilities.

</Callout>

#### api.authentication.setUserById(user_id)

Définit les attributs utilisateur en fonction d’un identifiant utilisateur déterminé pour tout type de connexion. Cela vous permet d’indiquer un utilisateur existant sans mettre à jour le profil. Cette méthode échoue si l’utilisateur n’existe pas ou est bloqué.

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>user_id</code></td>
<td>The user ID, such as <code>auth0&amp;#124;55562040asf0aef</code>.</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // 1. Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // 2.  Apply your authorization policy on the user
  const isAuthorized = await authorizeAccess(subject_token.sub);
  if (!isAuthorized) {
    api.access.deny('Unauthorized_login', 'User cannot login due to reason: X');
  }

  // 3. Set the user for the transaction
  api.authentication.setUserById(subject_token.sub);

  return;
};
```






#### api.authentication.setUserByConnection(connection_name, user_profile, options)

Sets a user and their associated profile attributes in a specified connection. This is equivalent to returning the specified user profile from the federated IdP (or the corresponding Custom DB with [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) disabled) when a user logs into this connection. You can configure whether this operation should create the user if it does not exist, and whether it should update the profile using the provided user profile attributes.

Le nombre de connexions sera incrémenté pour chaque utilisateur connecté via `setUserByConnection()`. Cette méthode échoue systématiquement pour les utilisateurs bloqués.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange EA currently supports `setUserByConnection()` for Auth0 database connections, Enterprise and Social connections, and Custom DBs with [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) disabled.

</Callout>

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>connection_name</code></td>
<td>The name of the connection where the user profile will be set. Limited to 512 characters.</td>
</tr>
<tr>
<td><code>user_profile</code></td>
<td>An object containing the user profile attributes to be set. Limited to 24 properties.</td>
</tr>
<tr>
<td><code>options</code></td>
<td>An object specifying update and creation behavior.<br/><br/><code>\{updateBehavior: 'replace' | 'none',creationBehavior: 'create_if_not_exists' | 'none',}</code><br/><br/>If the user exists, <code>updateBahaviour</code> does the following:<br/><ul><li> <code>replace</code>: the user attributes and the <code>user_id</code> for the provided connection are replaced (existing user attributes that are not provided will be removed from the user. Partial updates are not supported).</li><li><code>none</code>: if the user exists, the profile is not updated. If the user does not exist, it will be created with the provided profile attributes depending on <code>creationBehavior</code> configuration.</li><li>If the user does not exist, <code>creationBehavior</code> does the following:</li><ul><li><code>create_if_not_exists</code>: create the user</li><li><code>none</code>: does not create the user and return with an error</li></ul></ul></td>
</tr>
</tbody>
</table>

```js lines expandable
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // 1. Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // 2.  Apply your authorization policy on the user
  const isAuthorized = await authorizeAccess(subject_token.sub);
  if (!isAuthorized) {
    api.access.deny('Unauthorized_login', 'User cannot login due to reason: X');
  }

  // 3. Set the user for the transaction
  api.authentication.setUserByConnection(
    'My Connection',
    {
      user_id: subject_token.sub,
      email: subject_token.email,
      email_verified: subject_token.email_verified,
      phone_number: subject_token.phone_number,
      phone_verified: subject_token.phone_number_verified,
      username: subject_token.preferred_username,
      name: subject_token.name,
      given_name: subject_token.given_name,
      family_name: subject_token.family_name,
      nickname: subject_token.nickname,
      verify_email: false
    },
    {
      creationBehavior: 'create_if_not_exists',
      updateBehavior: 'none'
    }
  );

  return;
};
```






##### Attributs de profil utilisateur pris en charge

The `setUserByConnection()` method allows you to set profile attributes supported by the [Update a User](https://auth0.com/docs/api/management/v2/users/patch-users-by-id) endpoint:

* `user_id` (required): user's unique identifier for this connection/provider. It is typically the user ID provided by the external identity provider for the connection. This is the only required parameter when both `creationBehaviour` and `updateBehaviour` are set to `none`.
* `email_verified`
* `email_verified`. La valeur par défaut est `false`.
* `phone_verified`
* Vérification de l’adresse de courriel
* `phone_verified`. La valeur par défaut est `false`.
* `name`
* `given_name`
* `family_name`
* `nickname`
* `picture`

Utilisez des champs de métadonnées si vous devez définir des attributs non pris en compte dans la liste ci-dessus.

##### Stratégies de connexion prises en charge

La version actuelle prend en charge les stratégies de connexion suivantes. La méthode `setUserByConnection()` échoue pour les autres stratégies. Veuillez contacter le support Auth0 pour demander la prise en charge d’autres stratégies.

Connexions d’entreprise :

* Custom database connections with  [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) disabled

[IdP SAML](/authenticate/identity-providers/enterprise-identity-providers/saml)

* [Active Directory](/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap)
* [SAML IdPs](/docs/authenticate/identity-providers/enterprise-identity-providers/saml)
* [OIDC IdPs](/docs/authenticate/identity-providers/enterprise-identity-providers/oidc)
* [Okta](/docs/authenticate/identity-providers/enterprise-identity-providers/okta)
* [ADFS](/docs/authenticate/identity-providers/enterprise-identity-providers/adfs)

Facebook

* Github
* Facebook
* Github
* Windowslive
* Comportement de création
* Les utilisateurs sont créés dynamiquement uniquement lorsque `creationBehavior` est défini sur `create_if_not_exists`.

##### Lors de la création d’utilisateurs :

Vous devez fournir un identifiant configuré par votre connexion. Par défaut, une adresse courriel est requise.

Pour les connexions qui utilisent des [identifiants et attributs flexibles](/authenticate/database-connections/flexible-identifiers-and-attributes), vous pouvez fournir un nom d’utilisateur et un numéro de téléphone si l’attribut correspondant est activé pour la connexion.

* Pour les connexions qui n’utilisent pas d’identifiants et d’attributs flexibles :
* For connections that use [Flexible Identifiers and Attributes](/docs/authenticate/database-connections/flexible-identifiers-and-attributes), you may provide a username and phone number if the corresponding attribute is enabled for the connection.
* Vous ne pouvez pas fournir `phone_number`.

  + Vous pouvez préciser Auth0 envoie automatiquement des courriels de vérification lorsque vous créez un utilisateur avec `email_verified=false`. Vous pouvez contourner ce comportement en indiquant `verify_email=false` comme attribut de profil utilisateur. Cet attribut ne sera pas enregistré dans le profil utilisateur. et `phone_verified`.
  + You may provide a username when the connection’s **Require Username** is set to `true`. To learn more, read [Adding Username for Database Connections](/docs/authenticate/database-connections/require-username).
  + Mise à jour de comportement
  * Le profil utilisateur est mis à jour uniquement lorsque `updateBehavior` est défini sur `replace`.

A random password is generated for users dynamically created in Auth0 database connections. There are different options to trigger a [password reset flow](/docs/authenticate/database-connections/password-change) when needed after user creation.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Set `creationBehavior` to `none` when you want to log the user in but don’t want to create the user if they do not already exist in the connection.

Future iterations of Custom Token Exchange will make the email attribute optional dependent on the connection configuration.

</Callout>

##### `email_verified`

`phone_verified`

Vérification de l’adresse de courriel

* `email_verified`
* `phone_verified`
* Vérification de l’adresse de courriel
* Auth0 envoie automatiquement des courriels de vérification lorsque vous créez un utilisateur avec `email_verified=false`. Vous pouvez contourner ce comportement en indiquant `verify_email=false` comme attribut de profil utilisateur. Cet attribut ne sera pas enregistré dans le profil utilisateur.
* Si vous avez [configuré et activé un modèle de courriel de bienvenue](/customize/email/email-templates), Auth0 envoie automatiquement un courriel de bienvenue aux utilisateurs nouvellement créés lorsqu’aucune vérification par courriel n’est envoyée.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If you want to use `setUserByConnection()` to update a user profile that already contains `email`, `username`, or Vérification de l’adresse de courriel attributes, you must pass these attributes with the same value they already have. Otherwise, the method returns an error. Additionally, this action does not update the upstream Enterprise/Social IdP or the Custom DB, so make your updates match the latest version of the profile on the IdP/Custom DB if you want them to be in sync.

</Callout>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Set `updateBehavior` to `none` when you want to log the user in but don’t want to change any profile attributes if they already exist in the connection.

</Callout>

##### Définir les métadonnées

Contrairement au point de terminaison [Update a User](), la méthode `setUserByConnection()` ne permet pas de définir les métadonnées de l’utilisateur ou de l’application. Vous pouvez plutôt utiliser `api.user.setAppMetadata`. Pour savoir comment utiliser correctement les métadonnées, consultez [Fonctionnement des métadonnées dans les profils utilisateurs](/manage-users/user-accounts/metadata). Pour connaître les bonnes pratiques en matière de métadonnées, consultez [Comment gérer les métadonnées utilisateur avec le déclencheur post-connexion](/manage-users/user-accounts/metadata/manage-user-metadata#best-practices).

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // Create a user but don't verify email
  api.authentication.setUserByConnection(
    'My Connection',
    {
      user_id: subject_token.sub,
      email: subject_token.email,
      email_verified: false,
      verify_email: false
    },
    {
      creationBehavior: 'create_if_not_exists',
      updateBehavior: 'none'
    }
  );

  return;
};
```






If you have [configured and enabled a welcome email template](/docs/customize/email/email-templates), Auth0 automatically sends a welcome email to newly created users when no email verification is sent.

##### Définit les métadonnées de l’application pour l’utilisateur qui se connecte.

Unlike the [Update a User](https://auth0.com/docs/api/management/v2/users/patch-users-by-id) endpoint, the `setUserByConnection()` method does not allow you to set user or application metadata. Instead, you can use `api.user.setAppMetadata`. To learn how to correctly use metadata, read [How Metadata Works in User Profiles](/docs/manage-users/user-accounts/metadata). For metadata best practices, read [How to Manage User Metadata with the Post-login Trigger](/docs/manage-users/user-accounts/metadata/manage-user-metadata#best-practices).

#### api.user.setUserMetadata(name, value)

Définit les métadonnées générales pour l’utilisateur qui se connecte.

Cette méthode suit un comportement de fusion; vous pouvez donc indiquer les nouveaux attributs à ajouter ou à mettre à jour sans affecter les attributs existants. Pour supprimer un attribut, définissez sa valeur sur `null`.

<table class="table"><thead>
<tr>
<th><strong>Parameters</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>String. The name of the metadata property.</td>
</tr>
<tr>
<td><code>value</code></td>
<td>String, object or array. The name of the metadata property.</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {
  // Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // set the user for the transaction
  api.authentication.setUserById(subject_token.id);

  // set user group based on info contaiened in subject_token
  api.user.setAppMetadata('group', subject_token.group);

  return;
};
```






#### Refuse la transaction et augmente le compteur de tentatives infructueuses pour l’adresse IP externe d’où provient la demande. La demande d’échange de jetons personnalisé est rejetée avec une réponse d’erreur `400 Bad Request` avec le code d’erreur `invalid_request`.

Refuse la transaction de connexion et renvoie une erreur à l’appelant.

Utilisez cette méthode chaque fois que vous recevez une demande d’échange de jetons personnalisés dont le jeton n’est pas correctement signé/chiffré ou expiré, ou dans toute circonstance indiquant une utilisation frauduleuse, comme une usurpation d’identité ou une attaque par réinsertion. Cela permet à Auth0 d’activer la protection contre la limitation des adresses IP suspectes selon votre configuration.

<table class="table"><thead>
<tr>
<th><strong>Parameters</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>String. The name of the metadata property.</td>
</tr>
<tr>
<td><code>value</code></td>
<td>String, object or array. The name of the metadata property.</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {
  // Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // set the user for the transaction
  api.authentication.setUserById(subject_token.id);

  // set user preferred_locale based on info contaiened in subject_token
  api.user.setUserMetadata('preferred_locale', subject_token.locale);

  return;
};
```






#### Refuse la transaction et augmente le compteur de tentatives infructueuses pour l’adresse IP externe d’où provient la demande. La demande d’échange de jetons personnalisé est rejetée avec une réponse d’erreur `400 Bad Request` avec le code d’erreur `invalid_request`.

Lorsque le nombre maximum de tentatives infructueuses est atteint, Auth0 bloque le trafic pendant un certain temps pour toutes les demandes d’échange de jetons personnalisé provenant de cette adresse IP avec une réponse d’erreur `429 Too Many Requests` avec le code d’erreur `too_many_attempts`. Pour en savoir plus, consultez [Protection contre les attaques](#attack-protection).

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>code</code></td>
<td>A string returned in the error property in the response.<br/><br/>Two standard error codes can be used:<ul><li><code>invalid_request</code>: Returns a <code>400</code> status code</li><li><code>server_error</code>: Returns <code>500</code> status code</li></ul><br/>If you use your own error code, it returns a <code>400</code> status code.</td>
</tr>
<tr>
<td><code>reason</code></td>
<td>A string returned in the <code>error_description</code> property in the response.</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // 1. Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // 2.  Apply your authorization policy on the user
  const isAuthorized = await authorizeAccess(subject_token.sub);
  if (!isAuthorized) {
    api.access.deny('Unauthorized_login', 'User cannot login due to reason: X');
  }

  // if user is authorized, go on as indicated here

};
```






#### Utilisez cette méthode chaque fois que vous recevez une demande d’échange de jetons personnalisés dont le jeton n’est pas correctement signé/chiffré ou expiré, ou dans toute circonstance indiquant une utilisation frauduleuse, comme une usurpation d’identité ou une attaque par réinsertion. Cela permet à Auth0 d’activer la protection contre la limitation des adresses IP suspectes selon votre configuration.

Par défaut, la limitation des adresses IP suspectes autorise un maximum de 10 tentatives, à raison de 6 tentatives par heure. Pour en savoir plus, consultez la section [Protection contre les attaques](#attack-protection).

api.cache.delete(key)

Use this method whenever you receive a Custom Token Exchange request with a subject token that is not properly signed/encrypted or expired, or under any circumstance that points to any non-legitimate usage such as in a spoofing or replay attack. This allows Auth0 to activate <Tooltip tip="Suspicious IP Throttling: Form of attack protection that protects your tenant against suspicious logins targeting too many accounts from a single IP address." cta="View Glossary" href="/docs/glossary?term=Suspicious+IP+Throttling">Suspicious IP Throttling</Tooltip> protection as per your configuration.

Ces méthodes sont utiles pour la mise en cache des données utilisées pour la validation des jetons de sujet, telles que les clés publiques pour la validation des signatures. Cela peut améliorer les performances lors de la récupération des clés depuis un `jwks-uri`.

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reason</code></td>
<td>A string returned in the <code>error_description</code> property in the response</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {

  try {
    // Validate subject_token
    const subject_token = await validateToken(event.transaction.subject_token, jwksUri);
    // set the user for the transaction
    api.authentication.setUserById(subject_token.id);

  } catch (error) {
    if (error.message === 'Invalid Token') {
      // If specifically the problem is the subject_token is invalid
      console.error('Invalid Token error');
      api.access.rejectInvalidSubjectToken('Invalid subject_token');
    } else {
      // if there is any other unexpected error, throw a server error
      throw error;
    }
  }

};
```






#### api.cache.delete(key)

Supprimez un enregistrement décrivant une valeur mise en cache à la `key (clé)` fournie, si elle existe.

Renvoie un objet `CacheWriteResult` de type `success` si une valeur a été supprimée du cache. Une opération ayant échoué renvoie un objet de type `error`. Pour les erreurs, l’objet renvoyé aura une propriété `code` qui indique la nature de l’échec.

##### Important : ce cache est conçu pour des données éphémères et de courte durée. Certains éléments peuvent ne pas être disponibles lors de transactions ultérieures, même s’ils se trouvent à l’lintérieur de leur durée de vie prévue.

Récupérez un enregistrement décrivant une valeur mise en cache dans la `clé` fournie, si elle existe. Si un enregistrement est trouvé, la valeur mise en cache se trouve dans la propriété `value` de l’objet renvoyé.

Renvoie un enregistrement de cache si un élément est trouvé dans le cache pour la `clé` fournie. Les enregistrements de cache sont des objets avec une propriété `value` contenant la valeur mise en cache, ainsi qu’une propriété `expires_at` indiquant l’expiration maximale de l’enregistrement en millisecondes depuis l’heure Unix.

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>String. The key of the record stored in the cache.</td>
</tr>
</tbody>
</table>

##### Important : ce cache est conçu pour des données éphémères et de courte durée. Certains éléments peuvent ne pas être disponibles lors de transactions ultérieures, même s’ils se trouvent à l’lintérieur de leur durée de vie prévue.

Les valeurs stockées de cette manière auront une durée de vie allant jusqu’aux valeurs indiquées `ttl` ou `expires_at`. Si aucune durée de vie n’est indiquée, une durée de vie par défaut de 15 minutes sera utilisée. Les durées de vie ne peuvent pas dépasser la durée maximale indiquée dans les [Limites du cache Actions](/customize/actions/limitations).

Stockez ou mettez à jour une valeur de chaîne dans le cache à la clé indiquée.

Les valeurs stockées dans ce cache sont limitées au déclencheur dans lequel elles sont définies. Elles sont soumises aux [Limites du cache Actions](/customize/actions/limitations).

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>String. The key of the record stored in the cache.</td>
</tr>
</tbody>
</table>

##### Les valeurs stockées de cette manière auront une durée de vie allant jusqu’aux valeurs indiquées `ttl` ou `expires_at`. Si aucune durée de vie n’est indiquée, une durée de vie par défaut de 15 minutes sera utilisée. Les durées de vie ne peuvent pas dépasser la durée maximale indiquée dans les [Limites du cache Actions](/customize/actions/limitations).

Renvoie `CacheWriteSuccess` si les valeurs sont correctement stockées. Sinon, vous recevrez `CacheWriteError`.

Values stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](/docs/customize/actions/limitations).

Values stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default lifetime of 15 minutes will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](/docs/customize/actions/limitations).

Déployer l’action

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>String. The key of the record stored in the cache.</td>
</tr>
<tr>
<td><code>value</code></td>
<td>String. The value of the record to be stored.</td>
</tr>
<tr>
<td><code>options</code></td>
<td>Optional object. Options for adjusting cache behavior.</td>
</tr>
<tr>
<td><code>options.expires_at</code></td>
<td>Optional number. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the supplied <code>expires_at</code>.<br/><br/><strong>Note:</strong> This value should not be supplied if a value was also provided for <code>ttl</code>. If both options are supplied, the earlier expiry of the two will be used.</td>
</tr>
<tr>
<td><code>options.ttl</code></td>
<td>Optional number. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the supplied <code>ttl</code>.<br/><br/><strong>Note:</strong> This value should not be supplied if a value was also provided for expires_at. If both options are supplied, the earlier expiry of the two will be used.</td>
</tr>
</tbody>
</table>

## Après avoir créé votre action d’échange de jetons à l’aide des objets API et Event ci-dessus, déployez les modifications en cliquant sur **Déployer** en haut de la page.

Échange de jeton personnalisé

<table class="table"><thead>
<tr>
<th><strong>Property</strong></th>
<th><strong>Type</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>client</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>client_id</code></td>
<td>string</td>
<td><code>HOVc2PDFTH7eahimN4yNCo8mOtjfNjLV</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td>string</td>
<td><code>My Web App</code></td>
</tr>
<tr>
<td><code>metadata</code></td>
<td>object</td>
<td><code>\{“foo”: “bar” }</code></td>
</tr>
<tr>
<td><em>tenant</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>id</code></td>
<td>string</td>
<td><code>dev_1234</code></td>
</tr>
<tr>
<td>request</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>geoip</code></td>
<td>object</td>
<td><code>\{ … geoip object}</code></td>
</tr>
<tr>
<td><code>hostname</code></td>
<td>string</td>
<td><code>dev_1234.us.auth0.com</code></td>
</tr>
<tr>
<td><code>ip</code></td>
<td>string</td>
<td><code>123.42.42.34</code></td>
</tr>
<tr>
<td><code>user_agent</code></td>
<td>string</td>
<td><code>Mozilla/5.0</code></td>
</tr>
<tr>
<td><code>language</code></td>
<td>string</td>
<td><code>en</code></td>
</tr>
<tr>
<td><code>body</code></td>
<td>object</td>
<td><code>\{ // raw req.body }</code></td>
</tr>
<tr>
<td><code>method</code></td>
<td>string</td>
<td><code>POST</code></td>
</tr>
<tr>
<td><em>transaction</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>subject_token_type</code></td>
<td>string</td>
<td><code>urn://cic-migration-token</code></td>
</tr>
<tr>
<td><code>subject_token</code></td>
<td>string</td>
<td><code>41598922a1745f7af70</code></td>
</tr>
<tr>
<td><code>requested_scopes</code></td>
<td>string[]</td>
<td><code>[“openid”, “email”]</code></td>
</tr>
<tr>
<td><em>resource_server</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>id</code></td>
<td>string</td>
<td><code>http://acme-api/v1/profile</code></td>
</tr>
</tbody>
</table>

## Pour utiliser l’échange de jetons personnalisé, envoyez une demande `POST` au point de terminaison `/oauth/token` avec les paramètres suivants. N’oubliez pas :

Les `subject_tokens` utilisés avec l'échange de jetons personnalisés peuvent être de n’importe quel format ou type de jeton, à condition que votre code d'action puisse les interpréter.

<Frame>![](/images/cdy7uua7fh8z/61fgdh8VJEmfiYn0l7Tem0/3ceac5de5413373662e8b800d8f80210/Screenshot_2025-02-03_at_9.30.50_PM.png)</Frame>

## Chaque `subject_token_type` correspond à un profil d’échange de jetons personnalisé donné et est associé à une action donnée qui sera exécutée pour contrôler cette transaction.

Les autres paramètres d’extension sont ignorés, bien qu’ils soient inclus dans `event.request.body` dans l’action correspondante.

* Exemple de requête
* Protection contre les attaques

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>grant_type</code></td>
<td>For Custom Token Exchange, use <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</td>
</tr>
<tr>
<td><code>subject_token_type</code></td>
<td>The type of the subject token. For Custom Token Exchange, this can be any URI scoped under your own ownership, such as `http://acme.com/legacy-token` or <code>urn:acme:legacy-token</code>.<br/><br/>The following namespaces are reserved and cannot be used:<ul><li>`http://auth0.com`</li><li>`https://auth0.com`</li><li>`http://okta.com`</li><li>`https://okta.com`</li><li><code>urn:ietf</code></li><li><code>urn:auth0</code></li><li><code>urn:okta</code></li></ul></td>
</tr>
<tr>
<td><code>subject_token</code></td>
<td>The subject token, which your action should validate and use to identify the user.</td>
</tr>
<tr>
<td><code>client_id</code></td>
<td>The client ID of the application you are using for the Token Exchange. As for other grant types, you can also pass the client ID in the Authorization header using HTTP Basic Auth.</td>
</tr>
<tr>
<td><code>client_secret</code></td>
<td>The client secret of the application you are using for the Token Exchange. As for other grant types, you can also pass the client secret in the Authorization header using HTTP Basic Auth.<br/><br/>Other alternatives are also available as explained in <a href="https://auth0.com/docs/api/authentication#authentication-methods">Auth0 Authentication API reference docs</a>.<br/><br/>Note Custom Token Exchange can be used by public Applications. Make sure to read <a href="#attack-protection">Attack Protection</a> in that case.</td>
</tr>
<tr>
<td><code>audience</code></td>
<td>The API identifier defined in Auth0.</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>The OAuth2 scope parameter.</td>
</tr>
</tbody>
</table>

Pour se protéger contre les attaques par usurpation d’identité et par réinsertion, où un acteur menaçant tente de deviner ou de réutiliser un jeton d’objet, l’échange de jetons personnalisé intègre la prise en charge de la [limitation des adresses IP suspectes](/secure/attack-protection/suspicious-ip-throttling). Cela vous permet de signaler précisément depuis votre code dans les actions lorsqu’un [jeton d’objet n’est pas valide](#api-access-rejectinvalidsubjecttoken-reason-), afin qu’Auth0 puisse compter les tentatives infructueuses envoyées depuis cette adresse IP externe.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Prise en charge donnée de l’usurpation d’identité (p. ex., jeton d’acteur et demande d’acteur) is not yet supported in Custom Token Exchange EA. Adding an organization parameter results in the request being rejected. Prise en charge donnée de l’usurpation d’identité (p. ex., jeton d’acteur et demande d’acteur) support will be added in the next iterations of Custom Token Exchange.

</Callout>

### Lorsque le nombre de tentatives infructueuses à partir d’une adresse IP atteint un seuil préconfiguré, Auth0 bloque le trafic pour une demande d’échange de jetons personnalisés provenant de cette adresse IP avec l’erreur suivante :

```bash lines
curl --location 'https://{{YOUR_TENANT}}/oauth/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=urn:ietf:params:oauth:grant-type:token-exchange' \
--data-urlencode 'audience=https://api.acme.com' \
--data-urlencode 'scope=openid offline_access acme-scope1 acme-scope2' \
--data-urlencode 'subject_token_type=urn:acme:external-idp-migration' \
--data-urlencode 'subject_token=t8e7S2D9trQm73e .... iqBR3GjxDtbDVjpfQU' \
--data-urlencode 'client_id={{CLIENT_ID}}' \
--data-urlencode 'client_secret={{CLIENT_SECRET}}'
```






## L’adresse IP peut recommencer à envoyer des demandes après une période de temps configurée.

To protect against spoofing and replay attacks, in which a <Tooltip tip="Bad Actors: Entity (a person or group) that poses a threat to the business or environment with the intention to cause harm." cta="View Glossary" href="/docs/glossary?term=bad+actor">bad actor</Tooltip> tries to guess or reuse a subject token, Custom Token Exchange incorporates support for [Suspicious IP Throttling](/docs/secure/attack-protection/suspicious-ip-throttling). This enables you to specifically signal from your code in Actions when [a subject token is invalid](#api-access-rejectinvalidsubjecttoken-reason-), so Auth0 can count the failed attempts sent from that external IP.

Pour utiliser correctement la protection contre la limitation des adresses IP suspectes, n’oubliez pas d’utiliser `api.access.rejectInvalidSubjectToken` dans votre code d'action chaque fois que le jeton d’objet reçu ne passe pas une validation rigoureuse.

```json lines
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
{
    "error": "too_many_attempts",
    "error_description": "We have detected suspicious login behavior and further attempts will be blocked. Please contact the administrator."
}
```






La limitation des adresses IP suspectes est activée par défaut pour les locataires Auth0. Pour en savoir plus sur son activation (et sa désactivation) ainsi que sa configuration, consultez [Limitation des adresses IP suspectes](/secure/attack-protection/suspicious-ip-throttling). Une fois activée, les paramètres par défaut de l’échange de jetons personnalisé seront appliqués :

Seuil : 10. Nombre maximum de tentatives infructueuses pour une adresse IP.

Taux de limitation : Six par heure. Une tentative supplémentaire sera possible toutes les 10 minutes jusqu'à ce que le seuil soit rechargé.

Suspicious IP Throttling is activated by default for Auth0 tenants. To learn more about how to (de)activate and configure it, read [Suspicious IP Throttling](/docs/secure/attack-protection/suspicious-ip-throttling). When activated, the default settings for Custom Token Exchange will be applied:

* Tout d’abord, [obtenez un jeton Management API](/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens) pour utiliser l’API. Ensuite, envoyez la requête GET suivante au [point de terminaison Get Suspicious IP Throttling (Obtenir les paramètres de limitation d’adresses IP suspectes)]() :
* Vous recevrez une réponse comme celle-ci :

<Frame>![](/images/cdy7uua7fh8z/47PB3OAci9fotSHFrCNBVn/1bafbaacbeb22a4d94eb78506ab89bb8/Screenshot_2025-02-03_at_4.44.29_PM.png)</Frame>

Utilisez la requête `PATCH` suivante pour mettre à jour l’étape `pre-custom-token-exchange` avec les valeurs nécessaires. Notez que le taux correspond à l’intervalle de temps, en millisecondes, auquel les nouvelles tentatives sont accordées.

First, [get a Management API token](/docs/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens) to consume the API. Then, send the following GET request to the [Get Suspicious IP Throttling settings endpoint](https://auth0.com/docs/api/management/v2/attack-protection/get-suspicious-ip-throttling):

```bash lines
curl --location 'https://{{YOUR _TENANT}}/api/v2/attack-protection/suspicious-ip-throttling' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
```






Vous pouvez utiliser l’échange de jetons personnalisé pour résoudre des scénarios d’intégration avancés où les stratégies de connexion fédérée classiques basées sur la redirection de l’utilisateur final ne peuvent pas être appliquées en raison de contraintes techniques ou d’expérience utilisateur. Le code fourni pour les cas d’utilisation est incomplet et vise uniquement à illustrer les étapes logiques à suivre pour résoudre le cas d’utilisation. Consultez les [exemples de code](#code-samples) pour plus de détails.

```json lines
{
  "enabled": true,
  "shields": [
    "admin_notification",
    "block"
  ],
  "allowlist": [],
  "stage": {
    "pre-login": {
      "max_attempts": 100,
      "rate": 864000
    },
    "pre-user-registration": {
      "max_attempts": 50,
      "rate": 1200
    },
    "pre-custom-token-exchange": {
      "max_attempts": 10,
      "rate": 600000
    }
  }
}
```






Cette section décrit des exemples de cas d’utilisation et des exemples de code particuliers, accompagnés de recommandations pour la mise en œuvre de votre scénario. Pour illustrer ces cas d’utilisation, nous utiliserons GearUp, une société fictive de location de voitures.

```bash lines
curl --location --request PATCH 'https://{{YOUR _TENANT}}/api/v2//attack-protection/suspicious-ip-throttling' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
--data '{"stage":{"pre-custom-token-exchange":{"max_attempts":10,"rate":600000}}}'
```






## Cas d’utilisation : migration transparente vers Auth0

GearUp possède une application mobile utilisée par des millions de personnes et souhaite moderniser sa solution d’identité. C’est pourquoi l’entreprise a décidé de passer à Auth0. Cependant, elle souhaite éviter de forcer les utilisateurs à se réauthentifier lors de la migration depuis leur ancien fournisseur d’identité (IdP), car cela complique l’expérience utilisateur.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0 recommends using normal, out-of-the-box federated login whenever possible. By allowing you to set the user for the transaction, Custom Token Exchange gives you more flexibility by taking on the additional responsibility of securely validating and handling the transaction.

</Callout>

Pour résoudre ce problème et limiter les risques, GearUp procède à une migration progressive. Pour chaque utilisateur, l’entreprise souhaite échanger le jeton d’actualisation de son ancien fournisseur d’identité contre un jeton d’accès Auth0, un jeton d’actualisation et un ensemble de jetons d’ID. Cela permet à l’application d’utiliser Auth0 comme fournisseur d’identité pour cet utilisateur en toute transparence, et d’utiliser les API GearUp avec les jetons émis par Auth0. Une fois l’échange effectué pour tous les utilisateurs, l’application sera entièrement migrée et l’ancien fournisseur d’identité pourra être déconnecté, sans répercussions sur les utilisateurs finaux ni sur l’activité de GearUp.

### Comme condition préalable, GearUp a effectué une [importation d’utilisateurs en bloc](/manage-users/user-migration/bulk-user-imports) dans son locataire Auth0 et l’application mobile dispose d’un jeton d’actualisation hérité valide pour chaque utilisateur à migrer.

L’exemple de code suivant montre comment implémenter cette fonctionnalité dans l’action d’échange de jetons personnalisé. Dans ce cas, les profils utilisateurs étaient déjà importés dans une connexion à la base de données Auth0 :

To solve this, and to limit risks, GearUp is migrating incrementally. For each user, they wish to exchange the refresh token from their legacy IdP for an Auth0 access token, refresh token and <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+token">ID token</Tooltip> set. This allows their app to seamlessly start using Auth0 as the IdP for this user, as well as consume GearUp APIs using Auth0-issued tokens. Once the exchange is done for all users, the app will be fully migrated and the old IdP can be disconnected–all without impacting end users and GearUp’s business.

<Frame>![](/images/cdy7uua7fh8z/2Ke6p3yZl06KT4HHqtaVu9/5d9c5feb98d614d6d793fb01ccc03e92/Screenshot_2025-02-03_at_5.00.32_PM.png)</Frame>

As a prerequisite, GearUp has done a [bulk user import](/docs/manage-users/user-migration/bulk-user-imports) into their Auth0 tenant and the mobile app has a valid legacy refresh token for each user to be migrated.

1. The mobile app makes a request to Auth0 to exchange the legacy refresh token, setting it as the subject token.
2. The corresponding Custom Token Exchange profile Action executes. It validates the refresh token with the legacy IdP and gets the external user ID from the user profile. It then applies the required authorization policy and finally sets the user.
3. Auth0 responds with Auth0 access token, ID token, and refresh token.
4. The mobile app can now use the Customer APIs using Auth0 tokens without the user having to re-authenticate.

Nous utilisons l’identifiant utilisateur IdP externe pour définir l’utilisateur dans la connexion correspondante.

* Consultez [Exemples de code ](#code-samples) pour un exemple plus détaillé sur la façon de valider un jeton d’actualisation opaque avec l’IdP hérité.
* Cas d’utilisation : réutiliser un fournisseur d’authentification externe

Nous ne voulons pas vérifier les courriels lors de la création des utilisateurs.

```javascript lines expandable
/**
* Handler to be executed while executing a custom token exchange request
* @param {Event} event - Details about the incoming token exchange request.
* @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
*/
exports.onExecuteCustomTokenExchange = async (event, api) => {

 // 1. VALIDATE the refresh_token received in the subject_token by using it to get
 // the UserProfile from the external IdP
 const { isValid, user } = await getUserProfile(
   event.transaction.subject_token,
   event.secrets.CLIENT_SECRET,
 );

 if (!isValid) {
   // Mark the subject token as invalid and fail the transaction.
   api.access.rejectInvalidSubjectToken("Invalid subject_token");
 } else {
   // 2. Apply your AUTHORIZATION POLICY as required to determine if the request is valid.
   // Use api.access.deny() to reject the transaction in those cases.

   // 3. When we have the profile, we SET THE USER in the target connection
   api.authentication.setUserByConnection(
     connectionName,
     {
       // only the user_id in the connection is needed, as we are not
       // creating nor updating the user
       user_id: user.sub,
     },
     {
       creationBehavior: "none",
       updateBehavior: "none",
     },
   );
 }
};

/**
* Exchange the refresh token and load the user profile from the legacy IdP
* @param {string} refreshToken
* @param {string} clientSecret
* @returns {Promise<{ isValid: boolean, user?: object }>} If the refresh token was exchanged successfully, returns the user profile
*/
async function getUserProfile(refreshToken, clientSecret) {
 // Add your code here. REFER TO CODE SAMPLES FOR DETAILED EXAMPLES
}
```






Là encore, la solution doit être invisible pour les utilisateurs finaux, évitant ainsi une réauthentification auprès de GearUp. Pour résoudre ce problème, la bibliothèque JavaScript de GearUp peut effectuer un échange de jetons en utilisant le jeton d’ID externe Air0 comme entrée. Cela génère un jeton d’accès Auth0, qui est associé à l’utilisateur GearUp correspondant en fonction de son adresse courriel. Une fois le jeton d’accès obtenu, la bibliothèque GearUp peut utiliser les API de GearUp pour proposer des services de location de voitures directement sur le site Web d’Air0.

### Comme condition préalable, GearUp a configuré Air0 IdP en tant qu’entreprise fédérée ou connexion via réseau social, afin que l’utilisateur puisse s’authentifier à partir d’une connexion fédérée ou via l’échange de jetons personnalisé comme suit :

Le code suivant illustre comment mettre en œuvre cette fonctionnalité dans l’action d’échange de jetons personnalisé. Dans ce cas :

Nous utilisons l’identifiant utilisateur IdP externe pour définir l’utilisateur dans la connexion correspondante.

<Frame>![](/images/cdy7uua7fh8z/34AVzwyYARK6fn2IEnLsQn/409082d736d8495b637626406977fb1f/Screenshot_2025-02-03_at_5.08.47_PM.png)</Frame>

Nous voulons créer l’utilisateur s’il n’existe pas encore.

1. The Single Page App gets the ID token from the external IdP once the user authenticates.
2. It then requests the exchanges of the ID token, setting it as the subject token.
3. The corresponding Custom Token Exchange profile Action executes. It validates the ID token and gets the user ID and other profile attributes from the token. It then applies the required authorization policy and finally sets the user.
4. Auth0 responds with Auth0 access token, ID token and refresh token.
5. The javascript code running in the SPA can now use the Customer APIs using Auth0 tokens without the user having to re-authenticate.

Consultez [Valider les JWT signés avec des clés asymétriques](#validate-jwts-signed-with-asymmetric-keys) pour des exemples de code développés sur ce cas d’utilisation.

* Nous ne voulons pas vérifier les courriels lors de la création des utilisateurs.
* Voir [Exemples de code](#code-samples) pour un exemple plus détaillé sur la façon de valider en toute sécurité les JWT.
* Cas d’utilisation : obtenir des jetons Auth0 pour une autre audience
* GearUp souhaite améliorer la façon dont elle autorise les appels entre ses microservices internes pour répondre aux requêtes API. Elle souhaite une politique centralisée contrôlant les ressources que chaque service peut utiliser. Ce problème peut également être résolu grâce à l’échange de jetons.

```javascript lines expandable
const jwksUri = "https://example.com/.well-known/jwks.json";

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // 1. VALIDATE the id_token received in the subject_token
  const { isValid, payload } = await validateToken(
    event.transaction.subject_token,
  );

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
  } else {
    // 2. Apply your AUTHORIZATION POLICY as required to determine if the request is valid.
    // Use api.access.deny() to reject the transaction in those cases.

    // 3. SET THE USER in the target connection.
    // We don't want to verify emails when users are created
    // This example assumes subject_token (id_token) contains standard OIDC claims. Other custom mappings
    // are also possible.
    api.authentication.setUserByConnection(
      'Enterprise-OIDC',
      {
          user_id: formattedUserId,
          email: subject_token.email,
          email_verified: subject_token.email_verified,
          phone_number: subject_token.phone_number,
          phone_verified: subject_token.phone_number_verified,
          username: subject_token.preferred_username,
          name: subject_token.name,
          given_name: subject_token.given_name,
          family_name: subject_token.family_name,
          nickname: subject_token.nickname,
          verify_email: false
      },
      {
          creationBehavior: 'create_if_not_exists',
          updateBehavior: 'none'
      }
    );
  }

  /**
   * Validate the subject token
   * @param {string} subjectToken
   * @returns {Promise<{ isValid: boolean, payload?: object }>} Payload of the token
   */
  async function validateToken(subjectToken) {
    // Add your code here. REFER TO CODE SAMPLES FOR DETAILED EXAMPLES
  }
};
```






Read [code samples](#code-samples) for a more detailed example on how to securely validate <Tooltip tip="JSON Web Token (JWT): Standard ID Token format (and often Access Token format) used to represent claims securely between two parties." cta="View Glossary" href="/docs/glossary?term=JWTs">JWTs</Tooltip>.

### L’application GearUp a initialement obtenu un jeton d’accès pour utiliser l’API A au nom d’un utilisateur :

Le code suivant illustre comment mettre en œuvre cette fonctionnalité dans l’action d’échange de jetons personnalisé. Dans ce cas :

Nous utilisons l’identifiant utilisateur Auth0 pour définir l’utilisateur, il n’est donc pas nécessaire de le définir dans le cadre d’une connexion.

<Frame>![](/images/cdy7uua7fh8z/5Zw7yaJGct9eHAl4rdf72D/42274a5896851a16bea402ac52037f52/Screenshot_2025-02-03_at_5.17.14_PM.png)</Frame>

Nous ne voulons pas créer ou mettre à jour l’utilisateur.

1. The app sends the request with the initial access token to API A.
2. API A backend service validates the access token and requests to exchange by setting it as the subject token for a new access token to consume API B.
3. The corresponding Custom Token Exchange profile Action executes. It validates the access token and gets the Auth0 user ID from the token. It then applies the required authorization policy and finally sets the user.
4. Auth0 responds with an Auth0 access token to consume the API B audience.
5. API A backend service calls API B using the new access token, which is still associated with the same user.

Consultez [Valider les JWT signés avec des clés asymétriques](#validate-jwts-signed-with-asymmetric-keys) pour des exemples de code développés sur ce cas d’utilisation.

* Voir [Exemples de code](#code-samples) pour un exemple plus détaillé sur la façon de valider en toute sécurité les JWT.
* Exemples de code

Les exemples de code suivants présentent les meilleures pratiques pour les scénarios courants de validation des jetons de sujet entrants de manière sécurisée et performante.

```javascript lines expandable
const jwksUri = "https://example.com/.well-known/jwks.json";

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {
  // 1. VALIDATE the access_token received in the subject_token
  const { isValid, payload } = await validateToken(
    event.transaction.subject_token,
  );

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
  } else {
    // 2. Apply your AUTHORIZATION POLICY as required to determine if the request is valid.
    // Use api.access.deny() to reject the transaction in those cases.

    // 3. SET THE USER
    api.authentication.setUserById(payload.sub);
  }

  /**
   * Validate the subject token
   * @param {string} subjectToken
   * @returns {Promise<{ isValid: boolean, payload?: object }>} Payload of the token
   */
  async function validateToken(subjectToken) {
    // Add your code here. REFER TO CODE SAMPLES FOR DETAILED EXAMPLES
  }
};
```






Utilisez des algorithmes et des clés asymétriques autant que possible, car vous n’avez pas besoin de partager de secret avec Auth0. Cela simplifie également la rotation des clés, par exemple lors de l’exposition d’un point de terminaison URI JWKS pour annoncer les clés publiques applicables.

### Valider les JWT signés avec des clés asymétriques

Tenez compte des recommandations suivantes :

Utilisez les méthodes d’actions [api.cache](#api-cache) pour éviter d’avoir à récupérer les clés de connexion pour chaque transaction.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

It is your responsibility to ensure that subject tokens are protected with a strong algorithm and keys/secrets with enough entropy.

</Callout>

#### Adhérez aux meilleures pratiques [RFC8725]()

Utilisez des algorithmes sécurisés tels que HS256, ainsi que des secrets aléatoires à haute entropie (p. ex., d’au moins 256 bits de long)

* N’utilisez pas et n’acceptez pas l’algorithme « none »
* Adhere to [RFC8725](https://www.rfc-editor.org/rfc/rfc8725.txt) best practices
* Use RS\*, PS\*, ES\* or Ed25519 algorithms
* Tenez compte des recommandations suivantes :
* Utilisez des [Secrets d’actions](/customize/actions/write-your-first-action#add-a-secret) pour stocker en toute sécurité vos secrets symétriques.

```javascript lines expandable
const { jwtVerify } = require("jose");

const jwksUri = "https://example.com/.well-known/jwks.json";
const fetchTimeout = 5000; // 5 seconds

const validIssuer = "urn:my-issuer"; // Replace with your issuer

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {
  const { isValid, payload } = await validateToken(
    event.transaction.subject_token,
  );

  // Apply your authorization policy as required to determine if the request is valid.
  // Use api.access.deny() to reject the transaction in those cases.

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
  } else {
    // Set the user in the current request as authenticated, using the user ID from the subject token.
    api.authentication.setUserById(payload.sub);
  }

  /**
   * Validate the subject token
   * @param {string} subjectToken
   * @returns {Promise<{ isValid: boolean, payload?: object }>} Payload of the token
   */
  async function validateToken(subjectToken) {
    try {
      const { payload, protectedHeader } = await jwtVerify(
        subjectToken,
        async (header) => await getPublicKey(header.kid),
        {
          issuer: validIssuer,
        },
      );

      // Perform additional validation on the token payload as required

      return { isValid: true, payload };
    } catch (/** @type {any} */ error) {
      if (error.message === "Error fetching JWKS") {
        throw new Error("Internal error - retry later");
      } else {
        console.log("Token validation failed:", error.message);
        return { isValid: false };
      }
    }
  }

  /**
   * Get the public key to use for key verification. Load from the actions cache if available, otherwise
   * fetch the key from the JWKS endpoint and store in the cache.
   * @param {string} kid - kid (Key ID) of the key to be used for verification
   * @returns {Promise<Object>}
   */
  async function getPublicKey(kid) {
    const cachedKey = api.cache.get(kid);
    if (!cachedKey) {
      console.log(`Key ${kid} not found in cache`);
      const key = await fetchKeyFromJWKS(kid);
      api.cache.set(kid, JSON.stringify(key), { ttl: 600000 });
      return key;
    } else {
      return JSON.parse(cachedKey.value);
    }
  }

  /**
   * Fetch public signing key from the provided JWKS endpoint, to use for token verification
   * @param {string} kid - kid (Key ID) of the key to be used for verification
   * @returns {Promise<object>}
   */
  async function fetchKeyFromJWKS(kid) {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), fetchTimeout);

    /** @type {any} */
    const response = await fetch(jwksUri);

    if (!response.ok) {
      console.log(`Error fetching JWKS. Response status: ${response.status}`);
      throw new Error("Error fetching JWKS");
    }
    const jwks = await response.json();
    const key = jwks.keys.find((key) => key.kid === kid);
    if (!key) {
      throw new Error("Key not found in JWKS");
    }
    return key;
  }
};
```






#### Adhérez aux meilleures pratiques [RFC8725]()

Utilisez des algorithmes sécurisés tels que HS256, ainsi que des secrets aléatoires à haute entropie (p. ex., d’au moins 256 bits de long)

* Use [Actions Secrets](/docs/customize/actions/write-your-first-action#add-a-secret) to securely store your symmetric secrets.
* Adhere to [RFC8725](https://www.rfc-editor.org/rfc/rfc8725.txt) best practices
* Limites

```javascript lines expandable
const { jwtVerify } = require("jose");

const validIssuer = "urn:my-issuer"; // Replace with your issuer

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {
  // Initialize the shared symmetric key from Actions Secrets
  const encoder = new TextEncoder();
  const symmetricKey = encoder.encode(event.secrets.SHARED_SECRET);

  const { isValid, payload } = await validateToken(
    event.transaction.subject_token,
    symmetricKey,
  );

  // Apply your authorization policy as required to determine if the request is valid.
  // Use api.access.deny() to reject the transaction in those cases.

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
  } else {
    // Set the user in the current request as authenticated, using the user ID from the subject token.
    api.authentication.setUserById(payload.sub);
  }
};

/**
 * Validate the subject token
 * @param {string} subjectToken
 * @param {Uint8Array} symmetricKey
 * @returns {Promise<{ isValid: boolean, payload?: object }>} Payload of the token
 */
async function validateToken(subjectToken, symmetricKey) {
  try {
    // Validate token is correctly signed with the shared symmetric key
    // It also checks it is not expired as long as it includes an 'exp' attribute.
    const { payload, protectedHeader } = await jwtVerify(
      subjectToken,
      symmetricKey,
      {
        issuer: validIssuer,
      },
    );

    return { isValid: true, payload };
  } catch (/** @type {any} */ error) {
    console.log("Token validation failed:", error.message);
    return { isValid: false };
  }
}
```






#### Il s’agit d’une fonctionnalité en accès anticipé, qui comporte donc certaines limitations et incompatibilités avec d’autres fonctionnalités Auth0.

Use [Action Secrets](/docs/customize/actions/write-your-first-action#add-a-secret) to securely store your external IdP <Tooltip tip="Client Secret: Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable." cta="View Glossary" href="/docs/glossary?term=client+secret">client secret</Tooltip>.

```javascript lines expandable
const tokenEndpoint = "EXTERNAL_TOKEN_ ENDPOINT";
const userInfoEndpoint = "EXTERNAL_USER_INFO_ENDPOINT";
const clientId = "EXTERNAL_CLIENT_ID";
const connectionName = "YOUR_CONNECTION_NAME";
const fetchTimeout = 5000; // 5 seconds

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {
  const { isValid, user } = await getUserProfile(
    event.transaction.subject_token,
    event.secrets.CLIENT_SECRET,
  );

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
    return;
  }

  // Apply your authorization policy as required to determine if the request is valid.
  // Use api.access.deny() to reject the transaction in those cases.

  // When we have the profile, we set the user in the target connection
  api.authentication.setUserByConnection(
    connectionName,
    {
      // only the user_id in the connection is needed, as we are not
      // creating nor updating the user
      user_id: user.sub,
    },
    {
      creationBehavior: "none",
      updateBehavior: "none",
    },
  );
};

/**
 * Exchange the refresh token and load the user profile from the legacy IdP
 * @param {string} refreshToken
 * @param {string} clientSecret
 * @returns {Promise<{ isValid: boolean, user?: object }>} If the refresh token was exchanged successfully, returns the user profile
 */
async function getUserProfile(refreshToken, clientSecret) {
  const { isValid, accessToken } = await refreshAccessToken(
    refreshToken,
    clientSecret,
  );
  if (!isValid) {
    return { isValid: false };
  }

  const controller = new AbortController();
  setTimeout(() => controller.abort(), fetchTimeout);

  /** @type {any} */
  const response = await fetch(userInfoEndpoint, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json",
    },
  });

  if (!response.ok) {
    console.log(`Failed to fetch user info. Status: ${response.status}`);
    throw new Error("Error fetching user info");
  }

  const userProfile = await response.json();

  return { isValid: true, user: userProfile };
}

/**
 * Use the Refresh Token with the legacy IdP to validate it and get an access token
 * @param {string} refreshToken
 * @param {string} clientSecret
 * @returns {Promise<{ isValid: boolean, accessToken?: string }>} If the refresh token was exchanged successfully, returns the access token
 */
async function refreshAccessToken(refreshToken, clientSecret) {
  const controller = new AbortController();
  setTimeout(() => controller.abort(), fetchTimeout);

  /** @type {any} */
  let response;

  try {
    response = await fetch(tokenEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: refreshToken,
        client_id: clientId,
        client_secret: clientSecret,
      }).toString(),
    });
  } catch (error) {
    console.error("Error refreshing token");
    throw error;
  }

  if (!response.ok) {
    const errorBody = await response.json();
    console.error("Error refreshing token:", errorBody.error);

    // If we receive an error indicating the refresh token is invalid (for example, an invalid_grant error),
    // then we should explicitly indicate an invalid token using api.access.rejectInvalidSubjectToken
    // to prevent against brute force attacks on the refresh token by activating Suspicious IP Throttling.
    // For other errors which indicate a generic error making the request to the IdP, we should throw
    // an error to indicate a transient failure.
    if (errorBody.error === "invalid_grant") {
      return { isValid: false };
    } else {
      throw new Error("Error refreshing token");
    }
  }

  // Parse the response, in the form { access_token: "...", expires_in: ..., }
  const data = await response.json();
  console.log("Successfully exchanged refresh token");
  return { isValid: true, accessToken: data.access_token };
}
```






## Organizations

MFA : les commandes `api.authentication.challengeWith()` et `api.multifactor.enable()` des actions de post-connexion ne sont pas encore prises en charge par l’échange de jetons personnalisé et entraîneront l’échec de la transaction avec une erreur irrécupérable. De même, les transactions échoueront également lorsque l’authentification multifacteur est configurée comme stratégie de locataire.

Connexions de base de données personnalisées

* Prise en charge donnée de l’usurpation d’identité (p. ex., jeton d’acteur et demande d’acteur)
* <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=MFA">MFA</Tooltip>: `api.authentication.challengeWith()` and `api.multifactor.enable()` commands in Post Login actions are not yet supported for Custom Token Exchange and will result in the transaction failing with a non-recoverable error; similarly, transactions will also fail when MFA is configured as a tenant policy
* Custom DB Connections with [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) enabled are not supported for `setUserByConnection()` operations
* Les demandes d’échange de jetons personnalisé adressées au point de terminaison `/oauth/token` sont limitées à 10 % de la limite anti-attaques globale d’Authentication API pour le niveau de performance applicable.
* Les requêtes de lecture sur les points de terminaison `api/v2/token-exchange-profiles` sont également limitées comme suit :

## Limites d’entités

Un maximum de 100 profils d’échange de jetons personnalisé peuvent être créés par locataire.

<table class="table"><thead>
<tr>
<th><strong>Performance Tier</strong></th>
<th><strong>Global Authentication API limit (RPS)</strong></th>
<th><strong>Custom Token Exchange limit (RPS)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Enterprise</td>
<td>100</td>
<td>10</td>
</tr>
<tr>
<td>Private Cloud Basic (1x)</td>
<td>100</td>
<td>10</td>
</tr>
<tr>
<td>Private Cloud Performance (5x)</td>
<td>500</td>
<td>50</td>
</tr>
<tr>
<td>Private Cloud Performance (15x)</td>
<td>1500</td>
<td>150</td>
</tr>
<tr>
<td>Private Cloud Performance (30x)</td>
<td>3000</td>
<td>300</td>
</tr>
<tr>
<td>Private Cloud Performance (60x)</td>
<td>6000</td>
<td>600</td>
</tr>
<tr>
<td>Private Cloud Performance (100x)</td>
<td>10000</td>
<td>1000</td>
</tr>
</tbody>
</table>

Le nombre total d’actions est également limité en fonction de votre forfait Auth0. Pour en savoir plus, consultez la [page des tarifs d’Auth0]().

<table class="table"><thead>
<tr>
<th>Performance Tier</th>
<th>Custom Token Exchange limit (RPS)</th>
<th>Custom Token Exchange limit (RPM)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enterprise</td>
<td>20</td>
<td>200</td>
</tr>
<tr>
<td>Private Cloud Basic (1x)</td>
<td>20</td>
<td>200</td>
</tr>
<tr>
<td>Private Cloud Performance (5x)</td>
<td>100</td>
<td>300</td>
</tr>
<tr>
<td>Private Cloud Performance (15x)</td>
<td>300</td>
<td>3000</td>
</tr>
<tr>
<td>Private Cloud Performance (30x)</td>
<td>600</td>
<td>6000</td>
</tr>
<tr>
<td>Private Cloud Performance (60x)</td>
<td>1200</td>
<td>12000</td>
</tr>
<tr>
<td>Private Cloud Performance (100x)</td>
<td>2000</td>
<td>20000</td>
</tr>
</tbody>
</table>

## Dépanner

Réponse "Consent required”

The total number of Actions is also limited depending on your Auth0 plan. To learn more, read [Auth0's Pricing Page](https://auth0.com/pricing).

## Pour résoudre ce problème, activez l’option **Autoriser l'absence de consentement de l'utilisateur** pour votre API dans Auth0 Dashboard.

### "Consent required" response

You may receive an `invalid_request` error with a `consent_required` error description when calling the `/oauth/token` endpoint.

To resolve this issue, enable the **Allow Skipping User Consent** option for your API in the Auth0 Dashboard.

<Frame>![](/images/cdy7uua7fh8z/4eKWTJtCQwSHUZyKU81mWm/33c1966367d2b7c157b414fa1f04c026/Screenshot_2025-02-03_at_5.36.38_PM.png)</Frame>