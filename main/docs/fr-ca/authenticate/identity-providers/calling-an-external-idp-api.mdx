---
og:description: Describes how to call an external Identity Provider API.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Appeler une API de fournisseur d’identité
og:url: https://auth0.com/docs/
permalink: calling-an-external-idp-api
title: Appeler une API de fournisseur d’identité
twitter:description: Describes how to call an external Identity Provider API.
twitter:title: Appeler une API de fournisseur d’identité
---

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If you have [Token Vault](/docs/secure/tokens/token-vault) enabled for your connection, access and refresh tokens will no longer be stored in the user’s `identities` array. Instead, they will be stored in a secure tokenset within the Token Vault. To enable Token Vault, read [Configure Token Vault](/docs/secure/tokens/token-vault/configure-token-vault).

</Callout>

Once you successfully authenticate a user with an external <Tooltip tip="Identity Provider (IdP): Service that stores and manages digital identities." cta="View Glossary" href="/docs/glossary?term=Identity+Provider">Identity Provider</Tooltip> (IdP), such as Facebook or GitHub, the IdP often includes an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> in the user profile it returns to Auth0.

Vous pouvez récupérer et utiliser ce jeton pour appeler l’API de l’IdP.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

This article assumes that you have already configured the connection with the IdP of your choice. If not, go to [Identity Providers Supported by Auth0](/docs/authenticate/identity-providers/social-identity-providers), select the IdP you want, and follow the configuration steps.

</Callout>

La procédure à suivre diffère selon que votre code s’exécute dans le système dorsal ou dans le système du côté client.

* Si votre code s’exécute dans le système dorsal, nous pouvons supposer que votre serveur est fiable pour stocker des secrets en toute sécurité (comme vous le verrez, nous utilisons un secret dans le scénario du système dorsal). Si c’est le cas, passez à la section [système dorsal](#from-the-backend) de cet article.
* Si votre code s’exécute dans le système du côté client (par exemple, il s’agit d’une application à page unique, d’une application native de bureau ou d’une application mobile), votre application ne peut pas conserver les informations d’identification de manière sécurisée et doit suivre une autre approche. Dans ce cas, passez à la section [système du côté client](#from-the-frontend) de cet article.

## Depuis le système dorsal

Lorsque vous authentifiez un utilisateur, l’IdP inclut souvent un jeton d’accès dans le profil utilisateur qu’il renvoie à Auth0.

For security and compliance reasons, Auth0 does not send this token to your app as part of the user profile. To get it, you must access the Auth0 <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> and retrieve the full user's profile:

1. Get an Access Token that allows you to call the [Auth0 Management API](https://auth0.com/docs/api/management/v2).
2. Call the Auth0 Management API's [Get Users by ID endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) using the Access Token obtained in step one. This endpoint returns the full user's profile, which contains the IdP Access Token.
3. Extract the IdP Access Token from the response and use it to call the IdP's API.

### Étape 1 : Obtenir un jeton

You will need an Access Token to call the [Management API](https://auth0.com/docs/api/management/v2).

#### Créer une application d’essai pour Management API

If this is the first time you are requesting a [Management APIv2 Token](https://auth0.com/docs/api/management/v2/tokens), you will need to create and configure an application that can be used to call the Management API:

1. Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select the [Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients).
2. Select the **API Explorer** view, and click **Create & Authorize a Test Application**.

Cela créera une nouvelle application et accordera toutes les permissions de Management API, ce qui signifie que les jetons générés pour cette application pourront accéder à tous les points de terminaison du Management API.

<Card title="Can't see the button?">

If you don't see this button, it means that you already have at least one authorized application for the Management API. In this case, you can either update the scopes of the existing application and use that, or create a new one following these steps:

1. Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **Create Application**.
2. Select **Machine to Machine Applications**, and then **Create**.
3. From the **Select an API** dropdown, select `Auth0 Management API`.
4. Enable required scopes, and select **Authorize**.
5. Select the **APIs** view, and enable the toggle for **Auth0 Management API**.

</Card>

<Warning>

For security reasons, we recommend that you assign only the required scopes to the application you will be using. For this particular case, the scopes you need are: `read:users`, `read:user_idp_tokens`. Required scopes are listed for each endpoint in the [Management API Explorer](https://auth0.com/docs/api/management/v2).

</Warning>

To grant or remove scopes from the [registered Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients), select the [**Machine to Machine Applications** view](https://manage.auth0.com/#/apis/management/authorized-clients):

<Frame>![Edit the scopes granted to the Application](/images/cdy7uua7fh8z/6nuMjQMrTWhoVqtRwJBQz7/28a0f7c89c696426e273f43bd849b5e5/2025-02-25_11-11-36.png)</Frame>

#### Obtenir le jeton de Management API

Vous avez maintenant terminé la configuration et êtes prêt à obtenir votre jeton de Management API :

1. From the [registered Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients), select the [**Test** view](https://manage.auth0.com/#/apis/management/test).
2. Choose your application from the **Application** dropdown to pre-populate the ready-to-use snippets with customized variables.
3. Choose your language of preference for the snippet, and copy and run it.
4. Extract the `access_token` property from the response. This is what you will use to access the Management API.

<Card title="What are the snippets doing?">

The snippets make a `POST` operation to the [/oauth/token endpoint of the Auth0 Authentication API](https://auth0.com/docs/api/authentication#client-credentials), using the **OAuth 2.0 Client Credentials grant**. This is the grant that machine-to-machine processes use to access an API. To learn more about the flow, read [Client Credentials Flow](/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).

</Card>

#### Expiration du jeton

Par défaut, le jeton que vous avez reçu expire dans 24 heures (86 400 secondes). Pour changer cela :

1. Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select the [Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients).
2. Select the **Settings** view, locate the **Token Expiration (Seconds)** field, enter a new value, and click **Save**. The maximum value you can set is 2,592,000 seconds (30 days), though we recommend that you keep the default value.

Le prochain jeton que vous générerez utilisera le délai d’expiration mis à jour.

<Warning>

These tokens **cannot be revoked**. To minimize risk, we recommend issuing short-lived tokens and granting only the necessary scopes for each application. For a production environment, you can configure a simple CLI that will fetch a new token when the old one expires.

</Warning>

### Étape 2 : Obtenir le profil utilisateur complet

To get a user's profile, call the [Get a User endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) of the Management API using the Access Token you extracted in the previous section:

<CodeGroup>
```bash cURL lines
curl --request GET \
  --url 'https://{yourDomain}/api/v2/users/%7BuserId%7D' \
  --header 'authorization: Bearer {yourAccessToken}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/%7BuserId%7D");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourAccessToken}");
IRestResponse response = client.Execute(request);
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/%7BuserId%7D"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.get("https://{yourDomain}/api/v2/users/%7BuserId%7D")
  .header("authorization", "Bearer {yourAccessToken}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/users/%7BuserId%7D',
  headers: {authorization: 'Bearer {yourAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/%7BuserId%7D"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/%7BuserId%7D",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourAccessToken}" }

conn.request("GET", "/{yourDomain}/api/v2/users/%7BuserId%7D", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/%7BuserId%7D")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = ["authorization": "Bearer {yourAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/%7BuserId%7D")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Remplacer ces valeurs :

* `{userId}` : ID de l’utilisateur pour lequel vous souhaitez appeler l’API de l’IdP.
* `{yourAccessToken}` : Jeton d’accès que vous avez extrait dans la section précédente.

<Card title="Where do I find the User ID?">

* For testing purposes, you can find a user ID at [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users). Locate a user, and copy the value of the **user_id** field.

* For your implementation, you can either extract the user ID from the `sub` claim in the [ID Token](/docs/secure/tokens/id-tokens), or call the [/userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) of the Authentication API and extract it from the `user_id` response property.

</Card>

### Étape 3 : Extraire le jeton d’accès de l’IdP

Vous pouvez trouver le jeton d’accès utilisé pour appeler l’API de l’IdP dans le tableau `identities` de l’utilisateur : `user.identities[0].access_token`.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

For certain Identity Providers, Auth0 will also store a Refresh Token, which you can use to obtain a new Access Token for the IdP. This works for: BitBucket, Google (OAuth 2.0), OAuth 2.0, SharePoint, and Azure AD. To learn more, read [Identity Provider Access Tokens](/docs/secure/tokens/access-tokens/identity-provider-access-tokens).

</Callout>

In most cases, the user will only have one identity, but if the user has signed in multiple times through different connections and you have used [account linking](/docs/manage-users/user-accounts/user-account-linking/link-user-accounts), there may be more.

Dans cet exemple de réponse, nous voyons que notre utilisateur n’a qu’une seule identité : `google-oauth2`.

```json lines expandable
{
  "email": "john.doe@test.com",
  "email_verified": true,
  "name": "John Doe",
  "given_name": "John",
  "family_name": "Doe",
  "picture": "https://myavatar/photo.jpg",
  "gender": "male",
  "locale": "en",
  "updated_at": "2017-03-15T07:14:32.451Z",
  "user_id": "google-oauth2|111199914890750704174",
  "nickname": "john.doe",
  "identities": [
    {
      "provider": "google-oauth2",
      "access_token": "ya29.GlsPBCS6ahokDlgCYnVLnDKNE71HBXPEzNhAPoKJLAGKDSe1De3_xclahNcdZXoU-26hCpa8h6240TV86dtaEQ4ZWoeeZduHDq_yeu9QyQqUr--S9B2CR9YJrLTD",
      "expires_in": 3599,
      "user_id": "111199914890750704174",
      "connection": "google-oauth2",
      "isSocial": true
    }
  ],
  "created_at": "2017-03-15T07:13:41.134Z",
  "last_ip": "127.0.0.1",
  "last_login": "2017-03-15T07:14:32.451Z",
  "logins_count": 99
}
```






Vous êtes maintenant prêt à appeler l’API de l’IdP. Veuillez vous référer à la documentation de l’IdP pour plus de détails sur la façon de procéder.

<Warning>

Don't expose IdP tokens to your client-side application! If your application is public, see the [frontend section](#from-the-frontend) of this article.

</Warning>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

To learn more about how to request specific scopes for an Identity Provider Access Token, read [Add scopes/permissions to call Identity Provider's APIs](/docs/authenticate/identity-providers/adding-scopes-for-an-external-idp).

</Callout>

## Depuis le côté client

Si vous travaillez avec une application publique (application à page unique, bureau natif ou application mobile), vous êtes au bon endroit.

Lorsque vous travaillez avec une application du côté client, le processus d’appel des IdP API diffère du processus du système dorsal, car les applications du côté client sont des applications publiques qui **ne peuvent pas conserver les informations d’identification en toute sécurité**. Étant donné que le code d’une application à page unique peut être consulté et modifié, et que les applications natives/mobiles peuvent être décompilées et inspectées, on ne peut pas leur faire confiance pour conserver des informations sensibles telles que des clés secrètes ou des mots de passe.

Specifically, they cannot securely hold the **<Tooltip tip="Client Secret: Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable." cta="View Glossary" href="/docs/glossary?term=Client+Secret">Client Secret</Tooltip>** for the Machine to Machine Application, which you use to call `/oauth/token` during the first step of the backend process.

Au lieu de cela, vous devez construire un proxy pour votre système dorsal et l’exposer à votre application en tant qu’API.

### Construire un proxy

Tout d’abord, vous allez construire un processus dans votre programme dorsal qui mettra en œuvre les étapes incluses dans [la section du système dorsal](#from-the-backend) de cet article, et l’exposer à votre application en tant qu’API.

Vous appellerez l’API de l’IdP à partir du même processus dorsal, de sorte que le jeton d’accès ne soit jamais exposé à votre application publique.

Then, you will call your proxy API from your public application using the [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).

<Card title="Show me how">

If you haven't implemented this before, you might find our [Single-page Applications (SPA) with API](/docs/get-started/architecture-scenarios/spa-api) architecture scenario useful. It covers a different scenario, but it explains how to configure Auth0, how to call an API from a SPA, and how to implement API validations. It comes with a sample that uses [Angular 2](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-spa/angular) and [Node.js](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-api/node).

We also offer a [Mobile Applications with API](/docs/get-started/architecture-scenarios/mobile-api) variation (the sample uses [Android](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-mobile/android) and [Node.js](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-api/node)).

</Card>