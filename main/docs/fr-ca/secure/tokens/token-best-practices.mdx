---
og:description: Lists best practices when using tokens in authentication and authorization.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Meilleures pratiques concernant les jetons
og:url: https://auth0.com/docs/
permalink: token-best-practices
title: Meilleures pratiques concernant les jetons
twitter:description: Lists best practices when using tokens in authentication and
  authorization.
twitter:title: Meilleures pratiques concernant les jetons
---

Voici quelques éléments de base à prendre en compte lors de l’utilisation d’un jeton :

* **Gardez-le secret. Gardez-le en sécurité** : la clé de connexion doit être traitée comme n’importe quel autre justificatif d’identité et n’être révélée qu’aux services qui en ont besoin.
* **N’ajoutez pas de données sensibles à la charge utile** : les jetons sont signés afin de les protéger contre toute manipulation et sont facilement décodés. Pour obtenir une performance et une sécurité optimales, ajoutez le nombre minimal de demandes à la charge utile.
* **Donnez une date d’expiration aux jetons** : techniquement, une fois qu’un jeton est signé, il est valable pour toujours, à moins que la clé de connexion ne soit modifiée ou que l’expiration ne soit explicitement définie. Cela peut poser des problèmes potentiels, raison pour laquelle il convient de prévoir une stratégie d’expiration et/ou de révocation des jetons.
* **Adoptez le protocole HTTPS** : n’envoyez pas de jetons via des connexions non HTTPS, car ces demandes peuvent être interceptées et les jetons compromis.
* **Considérez tous vos cas d’utilisation d’autorisation** : l’ajout d’un système secondaire de vérification des jetons qui garantit que les jetons ont été générés à partir de votre serveur peut s’avérer nécessaire pour répondre à vos besoins.
* **Store and reuse:** Reduce unnecessary roundtrips that extend your application's attack surface, and optimize plan token limits (where applicable) by storing <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip> obtained from the <Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/docs/glossary?term=authorization+server">authorization server</Tooltip>. Rather than requesting a new token, use the stored token during future calls until it expires. How you store tokens will depend on the characteristics of your application: typical solutions include databases (for apps that need to perform API calls regardless of the presence of a session) and HTTP sessions (for apps that have an activity window limited to an interactive session). For an example of server-side storage and token reuse, see [Token Storage](/docs/secure/security-guidance/data-security/token-storage).

## Jetons par rapport aux Témoins

Typically, single-page apps (such as React, Vue, and AngularJS + Node), native mobile apps (such as iOS and Android), and web APIs (written in Node, Ruby, ASP.NET, or a mix of those) benefit most from token-based authentication. Traditional, server-side web applications have traditionally used cookie-based authentication.

Token-based authentication is implemented by generating a token when the user authenticates and then setting that token in the `Authorization` header of each subsequent request to your API. You want that token to be something standard, like <Tooltip tip="JSON Web Token (JWT): Standard ID Token format (and often Access Token format) used to represent claims securely between two parties." cta="View Glossary" href="/docs/glossary?term=JSON+web+tokens">JSON web tokens</Tooltip> since you will find libraries in most of the platforms and you don't want to do your own crypto.

Ces deux approches vous permettent d’obtenir la même quantité d’informations de la part de l’utilisateur. Cela est contrôlé par le paramètre `scope` envoyé dans la demande de connexion (soit en utilisant Lock, notre bibliothèque JavaScript ou un simple lien). `Scope` est un paramètre de la méthode `.signin({scope:  ’openid name email’})` qui finit par faire partie de la chaîne de requête dans la demande de connexion.

By default, we use `scope=openid` in token-based authentication to avoid having a huge token. You can control any standard <Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=OpenID">OpenID</Tooltip> Connect (OIDC) claims that you want to get in the token by adding them as scope values. For example, `scope=openid name email family_name address phone_number`. To learn more, see [Standard Claims on openid.net](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).

You can mix token-based authentication with cookie-based authentication. Take into account that cookies will work just fine if the web app and the API are served from the same domain, so you might not need token based authentication. If you need to, we also return a JWT on the web app flow. Each of our SDKs will do it differently. If you want to call your APIs from JavaScript(instead of using the existing cookie), then you have to set the access tokens using Web Workers or JavaScript closures to handle token transmissions and storage. To learn more, read the Browser in-memory scenarios section of our [Token Storage](/docs/secure/security-guidance/data-security/token-storage) page.

## Utilisation du jeton d’actualisation

You can only get a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+token">Refresh token</Tooltip> if you are implementing the following flows:

* [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow)
* [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/add-login-using-the-authorization-code-flow-with-pkce)
* [Resource Owner Password Flow](/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)
* [Device Authorization Flow](/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)

If you limit offline access to your API, a safeguard configured via the **Allow Offline Access** switch at [Auth0 Dashboard > Applications > APIs > Settings](https://manage.auth0.com/#/apis), Auth0 will not return a Refresh Token for the API (even if you include the `offline_access` scope in your request).

Les règles s’appliqueront à l’échange de jetons d’actualisation. Pour exécuter une logique spéciale, vous pouvez examiner la propriété `context.protocol` dans votre règle. Si la valeur est `oauth2-refresh-token`, la règle s’exécute pendant l’échange.

When trying to get a refresh token, the <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> parameter is not available on the Rules context object. If you receive an error when attempting to add the audience parameter, verify that you do not have it set on the token.

Si vous essayez de faire une redirection avec `context.redirect`, le flux d’authentification renverra une erreur.

Si vous avez ajouté des demandes personnalisées à vos jetons en appliquant une règle, les demandes personnalisées apparaîtront dans les nouveaux jetons émis lors de l’utilisation d’un jeton d’actualisation tant que votre règle sera appliquée. Bien que les nouveaux jetons n’héritent pas automatiquement des demandes personnalisées, les règles s’exécutent pendant le flux du jeton d’actualisation, ce qui signifie que le même code sera exécuté. Cela vous permet d’ajouter ou de modifier des demandes personnalisées dans les jetons nouvellement émis sans contraindre les applications précédemment autorisées à obtenir un nouveau jeton d’actualisation.

### Limites des jetons d’actualisation

Auth0 limite le nombre de jetons d’actualisation actifs à 200 par utilisateur et par application. Cette limite ne s’applique qu’aux jetons actifs. Si la limite est atteinte et qu’un nouveau jeton d’actualisation est créé, le système révoque et supprime le jeton le plus ancien pour cet utilisateur et cette application. Les jetons retirés et expirés ne comptent pas dans la limite.

#### Tests automatisés

Refresh tokens accumulate due to automated tests and are generally used for the test lifetime. To avoid a token stockpile subject to refresh token limits, you can use the Auth0 <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> to remove unnecessary refresh tokens.

1. [Create a user](https://auth0.com/docs/api/management/v2#!/Users/post_users) with Management API. You will use this user for testing.
2. The response returns a `user_id` that you need to persist during tests to be used later.
3. Once tests are complete, [delete the user](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id) through Management API. When the test user is deleted, the associated artifacts are also removed, including refresh tokens.

<Warning>

For this use case, we don’t recommend using a static user ID. We do not recommended that you keep test users and artifacts, or cleaning the refresh tokens using the device credential endpoints as you could hit rate limits on the Management API. To learn more, read [Management API Endpoint Rate Limits.](/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/management-api-endpoint-rate-limits)

</Warning>

Si vous souhaitez conserver l’utilisateur de test pour des tests ultérieurs :

1. List the user’s refresh tokens using [Management API's device credential endpoint](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials). The endpoint will return a maximum of 1000 tokens without specific order regardless of accumulated tokens or the use of pagination.
2. Delete those credentials [using the DELETE](https://auth0.com/docs/api/management/v2#!/Device_Credentials/delete_device_credentials_by_id) method.
3. If the user has more than 1k tokens, repeat listing and deleting tokens until no more tokens left for the user.

#### Configuration des jetons d’actualisation sur le point d’expirer

When users log into your application with Auth0, and when the `offline_access` is requested in the authorization request, a new refresh token is issued to the user. In the case users log out and in again with the same device, a new refresh token is issued. Depending on how your application stores and uses refresh tokens, the old refresh token from the first login might become obsolete, and your application will most likely use the new refresh tokens if both tokens are issued with the same audience. To learn more, read [Token Storage](/docs/secure/security-guidance/data-security/token-storage).

To avoid accumulating obsolete refresh tokens, even though the refresh token limit removes the oldest token first, we recommend you configure refresh token expiration. Both rotating and non-rotating (or reusable) refresh tokens can be configured to expire with either idle or absolute expiry values. Both expiration values help remove tokens that are not in active use and avoid accumulating tokens for the user. To learn more, read [Configure Refresh Token Expiration](/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration).

## Validation JWT

We strongly recommend that you use middleware or one of the existing open source third-party libraries to parse and validate JWTs. At [JWT.io](https://jwt.io/#libraries-io), you can find libraries for various platforms and languages, such as .NET, Python, Java, Ruby, Objective-C, Swift, and PHP.

## Algorithmes de signature

The algorithm used to sign tokens issued for your application or API. A signature is part of a JWT and is used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way. To learn more about JWTs, read [JSON Web Tokens](/docs/secure/tokens/json-web-tokens). To learn more about signatures, read [JSON Web Token Structure](/docs/secure/tokens/json-web-tokens/json-web-token-structure).

You can select from the following <Tooltip tip="Signing Algorithm: Algorithm used to digitally sign tokens to ensure the token has not been tampered with." cta="View Glossary" href="/docs/glossary?term=signing+algorithms">signing algorithms</Tooltip>:

* **RS256** (RSA Signature with SHA-256): An asymmetric algorithm, which means that there are two keys: one public key and one private key that must be kept secret. Auth0 has the private key used to generate the signature, and the consumer of the JWT retrieves a public key from the Metadata endpoints provided by Auth0 and uses it to [validate the JWT signature](/docs/secure/tokens/json-web-tokens/validate-json-web-tokens).
* **HS256** (HMAC with SHA-256): A symmetric algorithm, which means that there is only one private key that must be kept secret, and it is shared between the two parties. Since the same key is used both to generate the signature and to validate it, care must be taken to ensure that the key is not compromised. This private key (or secret) is created when you register your Application (**<Tooltip tip="Client Secret: Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable." cta="View Glossary" href="/docs/glossary?term=Client+Secret">Client Secret</Tooltip>**) or API (**Signing Secret**) and choose the HS256 signing algorithm.

La pratique la plus sûre, et notre recommandation, est d’utiliser **RS256** pour les raisons suivantes :

* Avec RS256, vous êtes sûr que seul le détenteur de la clé privée (Auth0) peut signer les jetons, tandis que n’importe qui peut vérifier si le jeton est valide à l’aide de la clé publique.
* Avec RS256, vous pouvez demander un jeton valide pour différents publics.
* Avec RS256, si la clé privée est compromise, vous pouvez mettre en œuvre la rotation des clés sans avoir à redéployer votre application ou votre API avec le nouveau secret (ce que vous devriez faire si vous utilisiez HS256).
* Avec HS256, si la clé secrète est compromise, vous devez redéployer l’API avec le nouveau secret.

## Clés de connexion

Une bonne pratique consiste à supposer que plusieurs clés de connexion peuvent être présentes dans votre JWKS. Cela peut sembler inutile puisque le point de terminaison Auth0 JWKS contient généralement une seule clé de connexion; cependant, plusieurs clés peuvent se trouver dans le JWKS lors de la rotation des certificats de signature.

Nous vous recommandons de mettre en cache vos clés de connexion afin d’améliorer les performances de l’application et d’éviter de vous heurter à des **limites anti-attaques**. Toutefois, si le décodage d’un jeton échoue, vous devez vous assurer d’invalider le cache et de récupérer de nouvelles clés de connexion avant de réessayer une dernière fois.

## Learn more

* [Tokens](/docs/secure/tokens)
* [Token Storage](/docs/secure/security-guidance/data-security/token-storage)