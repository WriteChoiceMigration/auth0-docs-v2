---
og:description: Describes how refresh token rotation provides greater security by
  issuing a new refresh token with each request made to Auth0 for a new access token
  by a client using refresh tokens.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Rotation des jetons d’actualisation
og:url: https://auth0.com/docs/
permalink: refresh-token-rotation
title: Rotation des jetons d’actualisation
twitter:description: Describes how refresh token rotation provides greater security
  by issuing a new refresh token with each request made to Auth0 for a new access
  token by a client using refresh tokens.
twitter:title: Rotation des jetons d’actualisation
---

<Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+token">Refresh token</Tooltip> rotation is a technique for getting new <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip> using refresh tokens that goes beyond [silent authentication](/docs/authenticate/login/configure-silent-authentication). Refresh tokens are typically longer-lived and can be used to request new access tokens after the shorter-lived access tokens expire. Refresh tokens are often used in native applications on mobile devices in conjunction with short-lived access tokens to provide seamless UX without having to issue long-lived access tokens.

With <Tooltip tip="Refresh Token Rotation: Strategy of frequently replacing refresh tokens to minimize vulnerability. With refresh token rotation, every time your application exchanges a refresh token to get a new access token, Auth0 also returns a new refresh token." cta="View Glossary" href="/docs/glossary?term=refresh+token+rotation">refresh token rotation</Tooltip> enabled in the <Tooltip tip="Refresh Token Rotation: Strategy of frequently replacing refresh tokens to minimize vulnerability. With refresh token rotation, every time your application exchanges a refresh token to get a new access token, Auth0 also returns a new refresh token." cta="View Glossary" href="/docs/glossary?term=Auth0+Dashboard">Auth0 Dashboard</Tooltip>, every time an application exchanges a refresh token to get a new access token, a new refresh token is also returned. Therefore, you no longer have a long-lived refresh token that, if compromised, could provide illegitimate access to resources. As refresh tokens are continually exchanged and invalidated, the threat is reduced.

The way refresh token rotation works in Auth0 conforms with the [OAuth 2.0 BCP](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-4.12) and works with the following flows:

* [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)
* [Authorization Code Flow with Proof Key for Code Exchange](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)
* [Device Authorization Flow](/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)
* [Resource Owner Password Flow](/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)

## Maintenir les sessions utilisateurs dans les SPA

Until very recently, SPAs maintained the user’s session by using the Authorization Code Flow with PKCE in conjunction with silent authentication. Recent developments in browser privacy technology, such as Intelligent Tracking Prevention (ITP) prevent access to the Auth0 <Tooltip tip="Session Cookie: Entity that, when present, allows the user to be considered authenticated." cta="View Glossary" href="/docs/glossary?term=session+cookie">session cookie</Tooltip>, thereby requiring users to reauthenticate.

<Frame>![Refresh Token Rotation Maintain User Sessions in SPAs diagram](/images/cdy7uua7fh8z/3sf7RRsy81bt3zcXMnHUSe/2171fdab4ffeb0987c329aa897038abc/rt-and-at.png)</Frame>

Malheureusement, les jetons d’actualisation d’une longue durée de vie ne sont pas appropriés avec la Prévention du suivi intelligent (ITP) puisqu’il n’y a pas de mécanisme de stockage dans le navigateur qui puisse assurer un accès uniquement par l’application. Parce qu’il existe des vulnérabilités qui peuvent être exploitées pour obtenir ces artefacts de grande valeur et octroyer un passage à des acteurs malicieux vers des ressources protégées, l’utilisation des jetons d’actualisation avec les SPA est fortement découragée.

La rotation des jetons d’actualisation offre une façon de remédier aux sessions d’utilisateurs finaux perdues en raison des effets secondaires des mécanismes de navigateurs privés. Parce que la rotation de jeton d’actualisation ne repose pas sur l’accès au témoin de session Auth0, il n’est pas affecté par l’ITP ou des mécanismes similaires.

Le schéma suivant illustre comment la rotation des jetons d’actualisation est utilisée conjointement avec le Flux Code d’autorisation avec PKCE, mais le principe général d’obtention d’un nouveau jeton d’actualisation avec chaque échange s’applique à tous les flux pris en charge.

<Frame>![Refresh Token Rotation Maintain User Sessions in SPAs State diagram](/images/cdy7uua7fh8z/41avsR2u0B4fSP3Bwh0WZz/d803a9057ea6e606d602c7c97d99fc3a/rtr-state-diagram.png)</Frame>

Cela signifie que vous pouvez utiliser les jetons d’actualisation en toute sécurité pour mitiger les effets négatifs des outils des navigateurs privés et fournir un accès continu aux utilisateurs finaux, cela sans inconvénient au service.

## Détection automatique de réutilisation

Lorsqu’un client a besoin d’un nouveau jeton d’accès, il envoie le jeton d’actualisation avec une requête à Auth0 pour obtenir une paire de jetons. Dès que la nouvelle paire est émise à Auth0, le jeton d’actualisation utilisé dans la requête est invalidé. Cela protège votre application contre les attaques par réinsertion résultant de jetons compromis.

Without enforcing sender-constraint, it’s impossible for the <Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/docs/glossary?term=authorization+server">authorization server</Tooltip> to know which actor is legitimate or malicious in the event of a replay attack. So it’s important that the most recently issued refresh token is also immediately invalidated when a previously-used refresh token (already invalidated) is sent to the authorization server. This prevents any refresh tokens in the same token family (all refresh tokens descending from the original refresh token issued for the client) from being used to get new access tokens.

Par exemple, considérez les scénarios suivants :

<Frame>![Refresh Token Rotation Reuse Detection state diagram](/images/cdy7uua7fh8z/33fe73R81Cpm6eTmOWfAnm/e7d168edc27861507a121910b32f1ee2/reuse-detection1.png)</Frame>

1. Legitimate Client has **refresh token 1**, and it is leaked to or stolen by Malicious Client.
2. Legitimate Client uses **refresh token 1** to get a new refresh token/access token pair.
3. Auth0 returns **refresh token 2/access token 2**.
4. Malicious Client then attempts to use **refresh token 1** to get an access token. Auth0 recognizes that refresh token 1 is being reused, and immediately invalidates the refresh token family, including **refresh token 2**.
5. Auth0 returns an access denied response to Malicious Client.
6. **Access token 2** expires and Legitimate Client attempts to use **refresh token 2** to request a new token pair. Auth0 returns an access denied response to Legitimate Client.
7. Re-authentication is required.

This protection mechanism works regardless of whether the legitimate client or the malicious client is able to exchange **refresh token 1** for a new token pair before the other. As soon as reuse is detected, all subsequent requests will be denied until the user re-authenticates. When reuse is detected, Auth0 captures detected reuse [events](/docs/deploy-monitor/logs/log-event-type-codes) (such as `ferrt` indicating a failed exchange) in logs. This can be especially useful in conjunction with Auth0’s [log streaming](/docs/customize/log-streams) capabilities to detect suspicious activity.

Un autre exemple est celui où le client malveillant vole le **jeton d’actualisation 1** et l’utilise avec succès pour acquérir un jeton d’accès avant que le client légitime ne tente d’utiliser le **jeton d’actualisation 1**. Dans ce cas, l’accès du client malveillant serait de courte durée, car le **jeton d’actualisation 2** (ou tout autre jeton d’actualisation émis ultérieurement) est automatiquement révoqué lorsque le client légitime tente d’utiliser le **jeton d’actualisation 1**, comme le montre le diagramme suivant :

<Frame>![Refresh Token Rotation Reuse Detection State diagram](/images/cdy7uua7fh8z/36rAUgLOAqW7k7Fdl1eRN1/c1a57be5093416b50d42ec41a1e3a233/reuse-detection2.png)</Frame>

## Assistance trousse SDK

Les trousses SDK suivantes incluent la prise en charge de la rotation des jetons d’actualisation et la détection de réutilisation automatique.

* Trousse SDK Auth0 pour les applications à page unique (SPA)
* Flutter (Web)
* Trousse SDK Swift (iOS)
* Trousse SDK pour Android
* Flutter
* Trousse SDK native React
* WPF/Winforms
* Xamarin

For documentation specific to these SDKs, visit the [Auth0 SDK Libraries](/docs/libraries) page.

You can choose to store tokens in either local storage or browser memory. The default is in browser memory. See [Token Best Practices](/docs/secure/tokens/token-best-practices) for recommendations about token storage. You must enable offline access and request the offline access scope in the client SDK.

## Learn more

* [Configure Refresh Token Rotation](/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)
* [Disable Refresh Token Rotation](/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation)
* [Configure Refresh Token Expiration](/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)
* [Token Best Practices](/docs/secure/tokens/token-best-practices)