---
og:description: Learn about managing Refresh Tokens with Actions
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Jetons d’actualisation avec des Actions
og:url: https://auth0.com/docs/
permalink: manage-refresh-tokens-actions
title: Jetons d’actualisation avec des Actions
twitter:description: Learn about managing Refresh Tokens with Actions
twitter:title: Jetons d’actualisation avec des Actions
---

Using <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+tokens">Refresh tokens</Tooltip> with [Actions](/docs/customize/actions) allows you to configure post-authentication risk detection and response capabilities to protect your applications and users against compromised refresh tokens. You can also dynamically customize the [refresh token expirations](/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration).

Pour faciliter cela, les Actions post-connexion comportent deux objets clés :

* **event.refresh_token**: Provides relevant information for existing refresh_tokens including `id`, `created_at`, `expires_at`, `idle_expires_at`, `clients_id`, `device` information, such as `ASN`, `IP`, and `User_agent`, and for browser-based flows, `session_id`. This object is populated by [refresh token exchange](/docs/secure/tokens/refresh-tokens/use-refresh-token-rotation) flows.
* **api.refreshToken** : Vous permet de gérer les jetons d’actualisation existants en révoquant des sessions ou en modifiant les dates d’expiration.

Vous pouvez utiliser l’objet `event.refresh_token` pour examiner la propriété `last_exchange_at` et évaluer les risques associés aux transactions en cours. Vous pouvez également combiner l’objet `event.refresh_token` avec d’autres objets d’événement, tels que `event.authentication`.

Vous pouvez ensuite utiliser l’objet `api.refreshToken` pour définir des dates d’expiration du jeton d’actualisation ou révoquer le jeton d’actualisation.

Pour en savoir plus sur ces objets, consultez :

* [Event object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-event-object): Learn about the refresh token Event object and properties.
* [API object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-api-object): Learn about the refresh token API object and methods.

## Révoquer les jetons d’actualisation à l’aide d’actions

The post-login **api.refreshToken.revoke(reason)** method allows you to react to risks associated with a transaction. Revoking the refresh token, invalidates the refresh token, returns a 403 HTTP status code to deny the current transaction, and logs a refresh token revoked event in the [tenant logs](/docs/deploy-monitor/logs/log-event-type-codes) (`srrt`).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If you want to use the `api.refreshToken.revoke(reason)` method, ensure that the event.refresh_token object exists.

</Callout>

### Surveiller les événements de révocation du journal

The revoke operation adds the following log event in your [tenant logs](/docs/deploy-monitor/logs):

Un code d’événement `srrt` indiquant qu’un jeton d’actualisation a été révoqué.

Si le jeton d’actualisation est lié à une session précédemment authentifiée, le journal inclura une référence à la session authentifiée dans l’attribut `session_id`.

## Cas d’utilisation des jetons d’actualisation avec les Actions

Vous pouvez modifier les dates d’expiration des jetons d’actualisation avec les méthodes de post-connexion suivantes :

* **api.refreshToken.setExpiresAt(absolute)** vous permet de définir une nouvelle date d’expiration absolue pour un jeton d’actualisation spécifié.
* **api.refreshToken.setIdleExpiresAt(idle)** vous permet de définir une nouvelle date d’expiration du délai d’inactivité pour un jeton d’actualisation spécifié.

Vous pouvez utiliser ces méthodes pour personnaliser dynamiquement les stratégies de durée de vie et d’inactivité des jetons d’actualisation en fonction de :

* L’organisation d’un utilisateur
* La connexion Auth0 d’un utilisateur
* L’adhésion ou le profil de groupe d’un utilisateur spécifique
* L’évaluation des risques
* Tout autre critère dynamique disponible lors de l’exécution de l’Action

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

The `api.refreshToken.setExpiresAt(absolute)` and `api.refreshToken.setIdleExpiresAt(idle)` methods allow to define the expiration of a refresh token, before its issuance, or modify an existing refresh token expiration during a [refresh token exchange](/docs/secure/tokens/refresh-tokens/use-refresh-tokens) flow.

The `api.refreshToken.setExpiresAt(absolute)` and the `api.refreshToken.setIdleExpiresAt(idle)` methods will convert non-expiring refresh tokens to expiring refresh tokens using the defaults [Refresh Token expirations](/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration) settings as maximum values.

The `api.refreshToken.setIdleExpiresAt(idle)` method sets the inactivity timeout for refresh tokens. If the method is not called in every successful exchange, the inactivity timeout will be overwritten using the refresh token lifetime application settings.

</Callout>

## Limites

Les jetons d’actualisation émis à partir du 21-09-2023 (22-02-2024 pour les locataires de la région US-3) contiennent la propriété identification de session (`session_id`) avec la valeur appropriée. Les jetons d’actualisation émis avant cette date contiennent cette propriété avec une valeur `null`.

Refresh tokens issued before the release of the post-login API method `api.refreshToken.revoke(reason)` will not contain `event.refresh_token.device` information.

Les jetons d’actualisation qui n’expirent pas ou les jetons d’actualisation qui n’ont pas été échangés ne contiendront pas la propriété `event.refresh_token.last_exchanged_at​`.

For security reasons, inactivity and absolute timeouts cannot be set above the application refresh token settings defined in the [refresh token expirations](/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration). If you attempt to set a date above the expiration settings, the API methods will update up to the [refresh token expirations](/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration) and log a warning event (`w`) in the tenant logs.

## Cas d’utilisation : Révocation d’un jeton d’actualisation

You can use [Actions](/docs/customize/actions) to configure risk detections and revoke refresh tokens with the `api.refreshToken.revoke(reason)` method and the event objects.

### Révoquer les jetons d’actualisation en raison d’ImpossibleTravel

You can use the <Tooltip tip="Adaptive Multi-factor Authentication: Multi-factor authentication (MFA) that is only triggered for users when an attempted login is determined to be a low confidence login." cta="View Glossary" href="/docs/glossary?term=Adaptive+MFA">Adaptive MFA</Tooltip> [assessments](/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa#assessments-object) object to determine if a user is logging from a location that indicates ImpossibleTravel and revoke the current refresh token associated with the transaction.

```js lines
exports.onExecutePostLogin = async (event, api) => {
  const { riskAssessment } = event.authentication ?? {};
  const ImpossibleTravel = riskAssessment?.assessments.ImpossibleTravel;

  // If this is an impossible travel and this is a refresh token exchange
  if (ImpossibleTravel?.code === "impossible_travel_from_last_login") {
    if (event.refresh_token) {
      api.refreshToken.revoke("Refresh token revoked due to impossible travel");
    }
  }
};
```






Dans cet exemple, une vérification se produit au début de l’Action pour vérifier si `event.authentication.ImpossibleTravel.code` est égal à `impossible_travel_from_last_login property`. Si la valeur est `true`, l’Action appelle `api.refreshToken.revoke()` pour :

* refuser la transaction;
* Révoquer le jeton d’actualisation
* renvoyer une erreur « 403 access_denied »;
* émettre l’erreur « Jeton d’actualisation révoqué en raison d’un voyage impossible »

### Révoquer les jetons d’actualisation en raison d’une liaison IP

If you use the post-login object properties `event.refresh_token.device.initial_ip` and `event.request.ip` to ensure a refresh token transaction stays with the same IP address for its duration. In this scenario, any IP change is considered a risk, and a new refresh token is required.

```js lines
exports.onExecutePostLogin = async (event, api) => {
  const refreshTokenInitialIp = event.refresh_token?.device?.initial_ip;
  const requestCurrentIp = event.request.ip;

  // if there is a refresh token and the IP changes
  if (
    refreshTokenInitialIp &&
    requestCurrentIp &&
    refreshTokenInitialIp != requestCurrentIp
  ) {
    api.refreshToken.revoke("Invalid IP change");
  }
};
```






Dans cet exemple, une vérification se produit au début de l’Action pour suivre les adresses IP avec les propriétés `event.refresh_token.device.initial_ip` et `event.request.ip`. L’Action détermine si l’adresse IP de la transaction a changé. Si la valeur est `true`, l’Action appelle `api.refreshToken.revoke()` pour :

* refuser la transaction;
* Révoquer le jeton d’actualisation
* renvoyer une `erreur` 403 `access_denied`
* émettre l’erreur « `Invalid IP change` » (Changement d’adresse IP invalide)

Pour une Action moins restrictive, vous pouvez également suivre les propriétés event.`request.asn` et `event.refresh_token.device.initial_asn` pour surveiller les changements d’ASN au lieu des changements d’IP.

## Cas d’utilisation : Personnaliser les dates d’expiration des jetons d’actualisation

You can use [Actions](/docs/customize/actions) to customize the refresh token lifetime and inactivity dates. Specifically, you can configure the refresh token idle and absolute expiration dates for a particular transaction using the post-login `api.refreshToken.setExpiresAt(absolute)` and `api.refreshToken.setIdleExpiresAt(idle)` methods.

### Personnalisation de la date d’expiration absolue du jeton d’actualisation en fonction de l’organisation

Vous pouvez utiliser l’Action post-connexion pour définir une durée de vie du jeton d’actualisation par organisation. L’exemple ci-dessous utilise les métadonnées `refresh_token_timeout` de l’Organization pour définir l’heure d’expiration du jeton d’actualisation.

```js lines
exports.onExecutePostLogin = async (event, api) => {
  // Refresh token timeout (in miliseconds) metadata configured in the Organizations
  const organization_refresh_token_lifetime =
    event.organization?.metadata?.refresh_token_timeout;

  if (organization_refresh_token_lifetime) {
    // Refresh token already exists
    if (event.refresh_token) {
      const created = Date.parse(event.refresh_token.created_at);

      const new_expiration_time =
        created + Number(organization_refresh_token_lifetime);
      api.refreshToken.setExpiresAt(new_expiration_time);
    } else {
      // Refresh token doesn't exist yet (e.g., token is being issued)
      const current_time = new Date().getTime();

      const new_expiration_time =
        current_time + Number(organization_refresh_token_lifetime);
      api.refreshToken.setExpiresAt(new_expiration_time);
    }
  }
};
```






Dans cet exemple, s’il existe un délai d’expiration absolu spécifique défini pour une Organization, l’Action définit le délai d’expiration absolu du jeton d’actualisation de façon à être égal à :

* Jetons nouvellement émis : `current_time` plus `organization_refresh_token_lifetime`
* Jetons existants : `event.refresh_token.created_at` plus `organization_refresh_token_lifetime`

### Personnalisation du délai d’inactivité du jeton d’actualisation en fonction du rôle d’adhésion

You can use post login action to define a refresh token idle timeout using [application](/docs/get-started/applications/configure-application-metadata) and [user metadata](/docs/manage-users/user-accounts/metadata). The example below uses the user metadata roles to define the user membership role and Application metadata to define the expected refresh token idle timeout.

```js lines
exports.onExecutePostLogin = async (event, api) => {
  // admins are configured with a shorter idle timeout for refresh tokens, in an application metadata
  const max_idle_lifetime =
    event.client.metadata?.admin_refresh_token_idle_timeout;

  // Check the user app metadata roles attribute to check if it is an admin user.
  const isAdmin = event.user?.app_metadata?.roles?.find(
    (role) => role === "admin",
  );

  // If the application has an specific idle timeout defined, set the timeout
  if (max_idle_lifetime && isAdmin) {
    const current_time = new Date().getTime();

    api.refreshToken.setIdleExpiresAt(current_time + Number(max_idle_lifetime));
  }
};
```






Dans cet exemple, s’il y a un délai d’inactivité spécifique défini pour l’application et que l’utilisateur est un administrateur, l’Action définit le délai d’inactivité du jeton d’actualisation de façon à être égal à la valeur `current_time` plus le `refresh_token_idle_timeout`. Notez que nous modifions le délai d’expiration des jetons nouvellement émis et des jetons existants lors de l’échange de jetons d’actualisation.