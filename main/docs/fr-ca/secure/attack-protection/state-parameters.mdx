---
og:description: Describes how to use the state parameter in authentication requests
  to help prevent CSRF attacks and restore state
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Prévenir les attaques et rediriger les utilisateurs avec les paramètres
  d’état OAuth 2.0
og:url: https://auth0.com/docs/
permalink: state-parameters
title: Prévenir les attaques et rediriger les utilisateurs avec les paramètres d’état
  OAuth 2.0
twitter:description: Describes how to use the state parameter in authentication requests
  to help prevent CSRF attacks and restore state
twitter:title: Prévenir les attaques et rediriger les utilisateurs avec les paramètres
  d’état OAuth 2.0
---

Les protocoles d’autorisation fournissent un paramètre `state` qui vous permet de rétablir l’état précédent de votre application. Le paramètre `state` préserve certains objets d’état définis par le client dans la demande d’autorisation et les met à la disposition du client dans la réponse.

## Attaques CSRF

The primary reason for using the `state` parameter is to mitigate [CSRF attacks](https://en.wikipedia.org/wiki/Cross-site_request_forgery) by using a unique and non-guessable value associated with each authentication request about to be initiated. That value allows you to prevent the attack by confirming that the value coming from the response matches the one you sent.

Le paramètre `state` est une chaîne de caractères, vous pouvez donc y encoder toute autre information. Vous envoyez une valeur aléatoire lors du lancement d’une demande d’authentification et vous validez la valeur reçue lors du traitement de la réponse. Vous stockez quelque chose du côté de l’application client (dans les témoins, la session ou le stockage local) qui vous permet d’effectuer la validation. Si vous recevez une réponse dont l’état ne correspond pas, vous pouvez en déduire que vous êtes peut-être la cible d’une attaque, car la réponse provient soit d’une demande non sollicitée, soit d’une personne qui tente de falsifier la réponse.

A CSRF attack specifically targets state-changing requests to initiate an action instead of getting user data because the attacker has no way to see the response to the forged request. For the most basic cases the state parameter should be a <Tooltip tip="Nonce: Arbitrary number issued once in an authentication protocol to detect and prevent replay attacks." cta="View Glossary" href="/docs/glossary?term=nonce">nonce</Tooltip>, used to correlate the request with the response received from the authentication.

Most modern OIDC and <Tooltip tip="OAuth 2.0: Authorization framework that defines authorization protocols and workflows." cta="View Glossary" href="/docs/glossary?term=OAuth">OAuth</Tooltip> SDKs, including Auth0.js in single-page applications, handle the state generation and validation automatically.

### Définir et comparer les valeurs des paramètres d’état

1. Before redirecting a request to the Identity Provider (IdP), have the app generate a random string. For example:

   ```text lines
   xyzABC123
   ```

   la longueur autorisée pour l’état n’est pas illimitée. Si vous obtenez l’erreur `414 Request-URI Too Large`, essayez une valeur plus petite.
2. Store the string locally. For example:

   ```text lines
   storeStateLocally(xyzABC123)
   ```


   

   
3. Add the `state` parameter to the request (URL-encoding if necessary). For example:

   ```javascript lines
   // Encode the String   
   tenant.auth0.com/authorize?...&state=xyzABC123
   ```


   

   

   Une fois la demande envoyée, Auth0 redirige l’utilisateur vers l’application. La valeur `state` sera incluse dans cette redirection. Notez qu’en fonction du type de connexion utilisée, cette valeur peut se trouver dans le corps de la requête ou dans la chaîne de requête.

   ```text lines
   /callback?...&state=xyzABC123
   ```


   

   
4. Retrieve the returned `state` value and compare it with the one you stored earlier. If the values match, then approve the authentication response, else deny it.

   ```javascript lines
   // Decode the String
   var decodedString = Base64.decode(encodedString);
   if(receivedState === retrieveStateStoredLocally()) {
    // Authorized request
   } 
   else {
     // This response is not for us, reject it
   }
   ```


   

   

## Rediriger les utilisateurs

Vous pouvez utiliser le paramètre `state` pour coder un état de l’application qui placera l’utilisateur à son emplacement d’avant le début du processus d’authentification. Par exemple, si un utilisateur a l’intention d’accéder à une page protégée dans votre application et que cette action déclenche une demande d’authentification, vous pouvez stocker cette URL pour rediriger l’utilisateur vers la page voulue une fois l’authentification terminée.

Générez et stockez un nombre aléatoire localement (dans les témoins, la session ou le stockage local) avec toutes les données d’état souhaitées, comme l’URL de redirection. Utilisez le nombre aléatoire comme état dans le message de protocole. Si l’état renvoyé correspond à le nombre aléatoire stockée, acceptez le message OAuth2 et récupérez les données d’état correspondantes dans le stockage. C’est l’approche utilisée dans auth0.js.

### Utiliser l’URL stockée pour rediriger les utilisateurs

1. Set the nonce state parameter value that you used to mitigate Attaques CSRF as explained above.
2. Store the nonce locally, using it as the key to store all the other application state information such as the URL where the user intended to go. For example:

   ```json lines
   {
     "xyzABC123" : {
       redirectUrl: '/protectedResource',
       expiresOn: [...]
     }
   }
   ```


   

   
3. Authenticate the user, [sending the generated nonce as the state](/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).
4. As part of the callback processing and response validation, verify that the state returned matches the nonce stored locally. If it does, retrieve the rest of the application state (like the `redirectUrl`).
5. Once you complete the callback processing, redirect the user to the URL previously stored.

### Autre procédé de redirection

1. Generate and store a nonce value locally.
2. Encode any desired state (like the redirect URL) along with the nonce in a protected message (that will need to be encrypted/signed to avoid tampering).
3. In the response processing, unprotect the message, getting the nonce and other properties stored.
4. Validate that the included nonce matches what was stored locally and, if so, accept the OAuth2 message.

## Limites et considérations

* Choisissez une méthode de stockage en fonction de votre type d’application.

  <table class="table"><thead>
  <tr>
  <th>App Type</th>
  <th>Storage Recommendation</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Regular Web App</td>
  <td>Cookie or session</td>
  </tr>
  <tr>
  <td>SPA</td>
  <td>Local browser</td>
  </tr>
  <tr>
  <td>Native App</td>
  <td>Memory or local</td>
  </tr>
  </tbody>
  </table>
* Du point de vue de la sécurité, ni la demande ni la réponse ne sont protégées en termes d’intégrité, ce qui permet à n’importe quel utilisateur de les manipuler. Il en va de même pour l’ajout d’un paramètre à `redirect_uri`.
* La longueur autorisée pour la valeur du paramètre d’état n’est pas illimitée. Si vous obtenez l’erreur `414 Request-URI Too Large`, essayez une valeur plus petite.
* Transmettre des URL en texte clair ou de manière prévisible n’est pas sécurisé. Assurez-vous que la valeur du paramètre d’état est :

  + Unique et opaque afin qu’elle puisse être utilisée pour la défense contre les attaques CSRF et par hameçonnage.
  + Si elle est stockée dans un témoin, elle doit être signée afin d’éviter toute falsification.

## Learn more

* [Which OAuth 2.0 Flow Should I Use?](/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)
* [Sessions](/docs/manage-users/sessions)