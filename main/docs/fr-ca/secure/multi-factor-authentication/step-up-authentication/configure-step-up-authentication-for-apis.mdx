---
og:description: Learn how an API can check if a user has logged in with Multi-factor
  Authentication by examining their access token.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Configurer l’authentification renforcée pour les API
og:url: https://auth0.com/docs/
permalink: configure-step-up-authentication-for-apis
title: Configurer l’authentification renforcée pour les API
twitter:description: Learn how an API can check if a user has logged in with Multi-factor
  Authentication by examining their access token.
twitter:title: Configurer l’authentification renforcée pour les API
---

Avec l’authentification renforcée, les applications qui permettent d’accéder à différents types de ressources peuvent exiger des utilisateurs qu’ils s’authentifient à l’aide d’un mécanisme plus puissant pour accéder à des informations sensibles ou effectuer certaines transactions.

Par exemple, l’utilisateur d’une application bancaire peut être autorisé à transférer de l’argent entre ses comptes uniquement après avoir confirmé son identité à l’aide de l’authentification multifacteur (MFA).

Lorsque votre audience est une API, vous pouvez mettre en œuvre une authentification renforcée avec Auth0 en utilisant des permissions, des jetons d’accès et des [Actions](/actions). Lorsqu’une application souhaite accéder aux ressources protégées d’une API, elle doit fournir un jeton d’accès. Les ressources auxquelles elle aura accès dépendent des autorisations incluses dans le jeton d’accès. Ces autorisations sont exprimées sous la forme de [permissions](/apis/scopes/api-scopes).

## Valider les jetons d’accès pour la MFA

Outre la vérification de la permission, l’API doit [valider le jeton d’accès](/security/tokens/access-tokens/validate-access-tokens) pour :

* Vérifier la signature du jeton, utilisée pour vérifier que l’expéditeur du jeton est bien celui qu’il prétend être et pour s’assurer que le message n’a pas été modifié en cours de route.
* Valider les demandes standard :

## Scénario : Transactions bancaires avec notifications poussées

Dans le scénario suivant, une application authentifie un utilisateur à l’aide de son nom d’utilisateur et de son mot de passe, puis demande le solde de son compte. Avant de récupérer les informations sur le solde du compte, l’utilisateur doit s’authentifier avec le facteur Guardian poussé.

L’API bancaire peut accepter deux niveaux d’autorisation différents : consulter le solde du compte (permission `view:balance`) ou transférer des fonds (permission `transfer:funds`). Lorsque l’application demande à l’API de récupérer le solde de l’utilisateur, le jeton d’accès doit contenir la permission `view:balance`. Pour transférer de l’argent vers un autre compte, le jeton d’accès doit contenir la permission `transfer:funds`.

### Processus

1. L’utilisateur se connecte à l’application en utilisant l’authentification par nom d’utilisateur et mot de passe. La connexion standard permet à l’utilisateur d’interagir avec l’API et de récupérer son solde. Cela signifie que le jeton d’accès que l’application reçoit après l’authentification de l’utilisateur contient la permission `view:balance`.
2. L’application envoie une demande à l’API pour récupérer le solde, en utilisant le jeton d’accès identifiants.
3. L’API valide le jeton et envoie les informations relatives au solde à l’application, afin que l’utilisateur puisse les consulter.
4. L’utilisateur souhaite transférer des fonds d’un compte à un autre, ce qui est considéré comme une transaction sensible nécessitant la permission `transfer:funds`. L’application envoie une demande à l’API en utilisant le même jeton d’accès.
5. L’API valide le jeton et refuse l’accès parce qu’il manque au jeton la permission `transfer:funds`.
6. L’application redirige vers Auth0, où une action est utilisée pour demander à l’utilisateur de s’authentifier avec la MFA puisqu’un champ d’application de grande valeur a été demandé. Une fois que l’utilisateur s’est authentifié avec succès avec la MFA, un nouveau jeton d’accès comprenant la permission appropriée est généré et envoyé à l’application dans le cadre de la réponse.
7. L’application envoie une autre demande de transfert de fonds à l’aide du nouveau jeton d’accès, qui inclut cette fois la permission `transfer:funds`.
8. L’API valide le jeton, l’ignore et procède à l’opération.

### Prérequis

Pour ce scénario, vous devez configurer les éléments suivants dans Dashboard :

* [Enregistrer une application Web à page unique](/get-started/create-apps/single-page-web-apps).
* [Créer une connexion de base de données](%24%7Bmanage_url%7D/#/connections/database).
* [Enregistrer l’API](/get-started/set-up-apis). Créez deux permissions : `view:balance` et `transfer:funds`.
* [Activer la MFA](/mfa/enable-mfa) pour utiliser les notifications poussées.

### Créer une action

Créez une action qui demande à l’utilisateur de s’authentifier avec la MFA lorsque la permission `transfer:funds` est demandée. Allez à [Dashboard > Actions > Flux](%24%7Bmanage_url%7D/#/actions/flows) et créez une action qui contient ce qui suit :

* La variable `CLIENTS_WITH_MFA` qui contient les identifiants clients des applications à laquelle vous voulez appliquer cette action. Vous pouvez la supprimer (et la condition `if` qui suit) si vous n’en avez pas besoin.
* La propriété `event.transaction.requested_scopes` contient toutes les permissions pour lesquelles la demande d’authentification a été effectuée. Si elle inclut la valeur `transfer:funds`, nous demandons alors la MFA en définissant la propriété `context.multifactor` sur la valeur appropriée. Dans ce cas, nous demandons la MFA en utilisant une notification poussée [push](/mfa/mfa-factors/configure-push-notifications-for-mfa).

### Configurer l’application

Configurez l’application pour qu’elle envoie la demande d’authentification appropriée à l’API, selon que l’utilisateur tente ou non d’effectuer la transaction sensible qu’est le transfert de fonds. Notez que la seule différence entre les deux demandes d’authentification (avec ou sans MFA) est la permission.

* Avec MFA :
* Sans MFA :



### Configurer l’API

Configurez l’API pour valider le jeton entrant et vérifier les autorisations accordées.

1. Configurez deux points de terminaison pour notre API : 
`GET /balance` : pour récupérer le solde actuel
`POST /transfer` : pour transférer des fonds
2. Utilisez `Node.js` et plusieurs modules :

1. [express](https://expressjs.com/) : ajoute le cadre d’applications Web Express.
2. [jwks-rsa](https://github.com/auth0/node-jwks-rsa) : récupère les clés de connexion RSA à partir d’un point de terminaison **JWKS** (JSON Web Key Set). À l’aide de `expressJwtSecret` nous pouvons générer un fournisseur de secrets qui fournit la bonne clé de connexion à `express-jwt` en fonction du `kid` dans l’en-tête JWT.
3. [express-jwt](https://github.com/auth0/express-jwt) : vous permet d’authentifier les requêtes HTTP à l’aide de jetons JWT dans vos applications Node.js. Il fournit plusieurs fonctions qui facilitent le travail avec les JWT.
4. [express-jwt-authz](https://github.com/auth0/express-jwt-authz) : vérifie si le jeton d’accès contient une permission précise.
3. Installez les dépendances :
`npm install express express-jwt jwks-rsa express-jwt-authz --save`
4. Définissez les points de terminaison de l’API, créez une fonction de médiation pour valider le jeton d’accès et sécurisez les points de terminaison à l’aide de ce logiciel médiateur. Le code de votre fichier `server.js` ressemble à l’exemple de script suivant : 
Chaque fois que l’API reçoit une demande, il se produit ce qui suit :

1. Le point de terminaison appelle le logiciel médiateur `checkJwt`.
2. `express-jwt` décode le jeton et achemine la demande, l’en-tête et les données utiles vers `jwksRsa.expressJwtSecret`.
3. `jwks-rsa` télécharge toutes les clés de connexion à partir du point de terminaison JWKS et vérifie si l’une des clés de connexion correspond à la valeur `kid` dans l’en-tête du jeton d’accès. Si aucune des clés de connexion ne correspond à la valeur `kid` reçue, une erreur sera générée. S’il y a une correspondance, transmettez la bonne clé de connexion à `express-jwt`.
4. `express-jwt` poursuit sa propre logique pour valider la signature du jeton, l’expiration, l’audience et l’émetteur.
5. `jwtAuthz` vérifie si la permission requise par le point de terminaison fait partie du jeton d’accès. Si les permissions spécifiées sont absents du jeton d’accès, la demande est rejetée avec un message d’erreur 403.