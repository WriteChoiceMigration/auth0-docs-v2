---
og:description: Describes how to identify user attributes that you do not want to
  save in Auth0 databases.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Ajouter des attributs d’utilisateur à la liste rouge
og:url: https://auth0.com/docs/
permalink: denylist
title: Ajouter des attributs d’utilisateur à la liste rouge
twitter:description: Describes how to identify user attributes that you do not want
  to save in Auth0 databases.
twitter:title: Ajouter des attributs d’utilisateur à la liste rouge
---

If there are user fields that should not be stored in Auth0 databases due to privacy reasons, you can add them to the Deny List. To add attributes to the Deny List, make a `PATCH` call to the Update Connection endpoint of the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip>.

1. Get a valid access token to access the `/patch_connections_by_id` [endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). The token must include the `update:connections` scope. See [Management API Access Tokens](/docs/secure/tokens/access-tokens/management-api-access-tokens) for details.
2. With the access token and the list of attributes to be denied, call the API. Here is an example HTTP request that denies two attributes: ethnicity and gender. Keep in mind you need to retrieve the options object and send the whole object in your PATCH request as there is no "merge" when you only update one or two values.

   <CodeGroup>
   ```bash cURL lines
    curl --request PATCH \
      --url 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID' \
      --header 'authorization: Bearer YOUR_TOKEN' \
      --header 'content-type: application/json' \
      --data '{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}'
   ```
   ```csharp C# lines
    var client = new RestClient("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID");
    var request = new RestRequest(Method.PATCH);
    request.AddHeader("authorization", "Bearer YOUR_TOKEN");
    request.AddHeader("content-type", "application/json");
    request.AddParameter("application/json", "{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}", ParameterType.RequestBody);
    IRestResponse response = client.Execute(request);
   ```

   ```go Go lines expandable
    package main

    import (
      "fmt"
      "strings"
      "net/http"
      "io/ioutil"
    )

    func main() {

      url := "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID"

      payload := strings.NewReader("{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}")

      req, _ := http.NewRequest("PATCH", url, payload)

      req.Header.Add("authorization", "Bearer YOUR_TOKEN")
      req.Header.Add("content-type", "application/json")

      res, _ := http.DefaultClient.Do(req)

      defer res.Body.Close()
      body, _ := ioutil.ReadAll(res.Body)

      fmt.Println(res)
      fmt.Println(string(body))

    }
   ```
   ```java Java lines
    HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")
      .header("authorization", "Bearer YOUR_TOKEN")
      .header("content-type", "application/json")
      .body("{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}")
      .asString();
   ```

   ```javascript Node.JS lines
    var axios = require("axios").default;

    var options = {
      method: 'PATCH',
      url: 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID',
      headers: {authorization: 'Bearer YOUR_TOKEN', 'content-type': 'application/json'},
      data: {options: {non_persistent_attrs: ['ethnicity', 'gender']}}
    };

    axios.request(options).then(function (response) {
      console.log(response.data);
    }).catch(function (error) {
      console.error(error);
    });
   ```
   ```obj-c Obj-C lines expandable
    #import <Foundation/Foundation.h>

    NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_TOKEN",
                              @"content-type": @"application/json" };
    NSDictionary *parameters = @{ @"options": @{ @"non_persistent_attrs": @[ @"ethnicity", @"gender" ] } };

    NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID"]
                                                          cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                      timeoutInterval:10.0];
    [request setHTTPMethod:@"PATCH"];
    [request setAllHTTPHeaderFields:headers];
    [request setHTTPBody:postData];

    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                    if (error) {
                                                        NSLog(@"%@", error);
                                                    } else {
                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                        NSLog(@"%@", httpResponse);
                                                    }
                                                }];
    [dataTask resume];
   ```

   ```php PHP lines expandable
    $curl = curl_init();

    curl_setopt_array($curl, [
      CURLOPT_URL => "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID",
      CURLOPT_RETURNTRANSFER => true,
      CURLOPT_ENCODING => "",
      CURLOPT_MAXREDIRS => 10,
      CURLOPT_TIMEOUT => 30,
      CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
      CURLOPT_CUSTOMREQUEST => "PATCH",
      CURLOPT_POSTFIELDS => "{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}",
      CURLOPT_HTTPHEADER => [
        "authorization: Bearer YOUR_TOKEN",
        "content-type: application/json"
      ],
    ]);

    $response = curl_exec($curl);
    $err = curl_error($curl);

    curl_close($curl);

    if ($err) {
      echo "cURL Error #:" . $err;
    } else {
      echo $response;
    }
   ```
   ```python Python lines
    import http.client

    conn = http.client.HTTPSConnection("")

    payload = "{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}"

    headers = {
        'authorization': "Bearer YOUR_TOKEN",
        'content-type': "application/json"
        }

    conn.request("PATCH", "/{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID", payload, headers)

    res = conn.getresponse()
    data = res.read()

    print(data.decode("utf-8"))
   ```

   ```ruby Ruby lines
    require 'uri'
    require 'net/http'
    require 'openssl'

    url = URI("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")

    http = Net::HTTP.new(url.host, url.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Patch.new(url)
    request["authorization"] = 'Bearer YOUR_TOKEN'
    request["content-type"] = 'application/json'
    request.body = "{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}"

    response = http.request(request)
    puts response.read_body
   ```
   ```swift Swift lines expandable
    import Foundation

    let headers = [
      "authorization": "Bearer YOUR_TOKEN",
      "content-type": "application/json"
    ]
    let parameters = ["options": ["non_persistent_attrs": ["ethnicity", "gender"]]] as [String : Any]

    let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

    let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,
                                        timeoutInterval: 10.0)
    request.httpMethod = "PATCH"
    request.allHTTPHeaderFields = headers
    request.httpBody = postData as Data

    let session = URLSession.shared
    let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
      if (error != nil) {
        print(error)
      } else {
        let httpResponse = response as? HTTPURLResponse
        print(httpResponse)
      }
    })

    dataTask.resume()
   ```
   </CodeGroup>
   
   Where:
   1. `{yourConnectionId}` is the [connection ID](/docs/authenticate/identity-providers/locate-the-connection-id) for which these attributes will be denied.
   2. `{yourToken}` is the access token you received in the previous step.
   3. `options.non_persistent_attrs` object holds an array of the attributes that will be denied. If the claim that you want to deny is being sent by an upstream Identity Provider (IdP), you should set the claim exactly as sent by the upstream IdP. For example, for a claim received as `https://acme.com/temporary_idtoken`, the above sample `non_persistent_attrs` object would read:

      ```json wrap lines
      {"non_persistent_attrs": ["ethnicity", "gender", "https://acme.com/temporary_idtoken"]}
      ```
      

## Limites

* Only [root fields](/docs/manage-users/user-accounts/user-profiles/user-profile-structure) (such as `user.name` or `user.phone_number`) can be denied.

  + Si `user.name` ou `user.nickname` est refusé, il ne sera pas inclus dans les jetons.
  + Si `user.email` est refusé, la valeur ne peut pas être mappée à une demande personnalisée. Par exemple, dans une règle, `context.idToken[namespace + ’work_email’] = user.email` ne fonctionnerait pas.
* Lorsque vous refusez des attributs, ils seront toujours disponibles via des règles et des jetons sortants. Cependant, si l’une des conditions suivantes s’applique, les attributs de la liste rouge ne seront **pas** inclus dans les jetons :

  + Vous avez activé l’authentification multifacteur (MFA)
  + Vous avez effectué une redirection à l’aide de règles
  + Votre application utilise la délégation (et vous n’avez pas défini `permission = passthrough`)
  + Votre application utilise l’usurpation d’identité
  + Vous avez activé le paramètre **Utiliser Auth0 au lieu de l’IdP pour effectuer une authentification unique** (anciens locataires uniquement)
* Pour les connexions SAMLP, si vous activez le mode Debug, vos journaux contiendront des informations sur les attributs de la liste rouge

If any of these limitations are unacceptable, you can write a [rule](/docs/customize/rules) to encrypt the data and have the data persist to the `user.app_metadata` object.

## Learn more

* [Revoke Access to APIs Using Application Grants](/docs/get-started/applications/revoke-api-access)
* [Auth0 IP Addresses for Allow Lists](/docs/secure/security-guidance/data-security/allowlist)