---
og:description: Learn about how Highly Regulated Identity enables transactional authorization
  with the Authorization Code Flow.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Autorisation transactionnelle avec authentification contextuelle forte du
  client
og:url: https://auth0.com/docs/
permalink: transactional-authorization-with-authorization-code-flow
title: Autorisation transactionnelle avec authentification contextuelle forte du client
twitter:description: Learn about how Highly Regulated Identity enables transactional
  authorization with the Authorization Code Flow.
twitter:title: Autorisation transactionnelle avec authentification contextuelle forte
  du client
---

Highly Regulated Identity enables Transactional Authorization with the [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) by applying step-up <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=multi-factor+authentication">multi-factor authentication</Tooltip> (MFA) to authorize a transaction. Step-up MFA challenges the user with a second authentication factor to explicitly authorize the transaction details of a one-time operation, which is useful in use cases that require financial-grade security:

* Sécurisation des opérations sensibles exécutées à partir de vos propres services, telles que l’approbation des virements bancaires, l’accès à l’historique des opérations et la modification des identifiants d’accès.
* Sécurisation des opérations sensibles demandées à des services tiers, telles que l’approbation des paiements numériques et l’autorisation d’un accès unique pour la vérification d’un compte.

This article walks you through the end-to-end journey of approving a bank transfer. The same transactional <Tooltip tip="Authorization Flow: Authorization grant (or workflow) specified in the OAuth 2.0 framework." cta="View Glossary" href="/docs/glossary?term=authorization+flow">authorization flow</Tooltip> can be applied to other use cases.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

You must configure transactional authorization for each API. Once activated, it applies to the scopes and `authorization_details.types` for that API.

</Callout>

## Prérequis

<Warning>

Do not pass fine-grained transaction authorization data or other sensitive or regulated data outside of `authorization_details`.

</Warning>

Before getting started, follow the instructions in [Configure Rich Authorization Requests](/docs/get-started/apis/configure-rich-authorization-requests) to register the `authorization_details.types` for your API or <Tooltip tip="Resource Server: Server hosting protected resources. Resource servers accept and respond to protected resource requests." cta="View Glossary" href="/docs/glossary?term=resource+server">resource server</Tooltip>.

## Définissez `transactional-authorization-with-mfa` comme `consent_policy`.

Enregistrez les `authorization_details.types` que vous souhaitez utiliser.

1. Securely redirect the user to Auth0 with the transaction details. In this step, avoid revealing sensitive information on the front channel (e.g. the browser).
2. [mutual-TLS (mTLS) pour OAuth](/authenticate-with-mtls) after the user authenticates. Using [Actions](/docs/customize/actions), you can dynamically decide on the next steps based on the transaction details and other information you may get from sources such as external APIs. To learn more, read [Apply dynamic policy](#apply-dynamic-policy).
3. Challenge the user with a second authentication factor and show transaction details for the user to explicitly approve. This step depends on the authentication factor you chose to apply using Actions.
4. Get the access token and proceed with the sensitive operation. Your API validates the approved transaction details associated with the access token.

<Frame>![](/images/cdy7uua7fh8z/6VYcY5YJRT9Ngaomj5f9yi/ea5f0caa41a7db330a1c1d980ce7116c/Transactional_Authorization__1_.png)</Frame>

Flux de bout en bout

### Le diagramme suivant montre le flux de bout en bout de l’autorisation transactionnelle avec SCA contextuel. Il y a quatre phases principales :

Nous examinerons chaque phase en détail dans les sections suivantes.

To meet financial-grade security standards, Highly Regulated Identity uses Pushed Authorization Requests (PAR) to hide transaction details from the browser. Instead of sending query parameters through the browser to the `/authorize` endpoint, PAR directly sends parameters from your backend to a special `/par` endpoint using a POST request. To learn how to set it up, read [Configure Pushed Authorization Requests](/docs/get-started/applications/configure-par).

L’utilisateur accède pour la première fois à votre application Web après s’être authentifié auprès d’Auth0. Dans notre exemple de cas d’utilisation, l’utilisateur demande ensuite un transfert d’argent à l’un de ses contacts.

```json lines
"authorization_details": [
 {
   "type": "money_transfer",
   "instructedAmount": {
     "amount": 150,
     "currency": "USD"
   },
   "sourceAccount": "xxxxxxxxxxx1234",
   "destinationAccount": "xxxxxxxxxxx9876",
   "beneficiary": "Hanna Herwitz",
   "subject": "A Lannister Always Pays His Debts"
 }
]
```






Use Actions to inspect the `authorization_details` to determine which authentication factors to use based on the transaction. To learn more about `authorization_details` and how to use it along PAR, read [Authorization Code Flow with Rich Authorization Requests](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar).

If you want to meet FAPI 1 Advanced Security compliance requirements, you must also use public key cryptography to authenticate the backend against the `/par` or the `/token` endpoint. This is more secure than sending a <Tooltip tip="Client Secret: Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable." cta="View Glossary" href="/docs/glossary?term=Client+Secret">Client Secret</Tooltip>. Auth0 offers the following public key cryptography authentication methods:

* [Private Key JWT](/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)
* [mutual-TLS (mTLS) for OAuth](/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls)

[Clé privée JWT](/authenticate-with-private-key-jwt)

### [mutual-TLS (mTLS) pour OAuth](/authenticate-with-mtls)

When the user logs in without using <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=SSO">SSO</Tooltip> and the browser hits your Auth0 tenant’s `/authorize` endpoint, Auth0 will attempt to authenticate the user. In our example of approving a bank transfer, Auth0 has already authenticated the user to access your web application. However, when a third party redirects the user, such as for a digital payment, Auth0 presents a login screen to the user. To learn more about the authentication flow, read the [Authenticate](/docs/authenticate) documentation.

Once Auth0 has successfully authenticated the user, Auth0 triggers post-login [Actions](/docs/customize/actions), which expose transaction details about the user, app, authentication factor(s) used, and more in the [post-login event object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-event-object). Within the post-login event object, the `event.transaction.requested_authorization_details` property contains details about the authorization request that were received in the previous step.

Use the [post-login event object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-event-object) to decide how you want to proceed with the transaction. For example, you can send transaction details to an external risk engine, and after evaluating the risk level, determine whether to request step-up authentication using sms, as illustrated in the following code sample.

```js lines expandable
exports.onExecutePostLogin = async (event, api) => {
  if (event.transaction?.requested_authorization_details.some(e => e.type === 'money_transfer')) {
      const axios = require('axios');

      //details to contact risk evaluation engine
      const risk_url = 'https://risk.example.org/score';
      const risk_options = {
        headers: {
          'Content-Type': 'application/json'
        }
      };

      const tx_data = {
        email: event.user.email,
        authorization_details: event.transaction?.requested_authorization_details
      };

      //send operation details to risk evaluation engine
      var risk = await axios.post(risk_url, tx_data, risk_options);

      //if it is a risky operation use push to authorize
      if (risk.data.score >= 2) {
        api.authentication.challengeWith({ type: 'push-notification', options: {otpFallback: false}});

      }
    }
};
```






### Une fois que Auth0 a authentifié avec succès l’utilisateur, Auth0 déclenche des [Actions](/actions) post-connexion, qui exposent les détails de la transaction concernant l’utilisateur, l’application, le(s) facteur(s) d’authentification utilisé(s), et plus encore dans [l’objet événement post-login](/signup-and-login-triggers/login-trigger/post-login-event-object). Dans l’objet événement post-connexion, la propriété `event.transaction.requested_authorization_details` contient des détails sur la demande d’autorisation reçue à l’étape précédente.

You can customize what authentication factor to use depending on factors enrolled by the user, factors already satisfied by the session, and/or your own preferences. You can also provide alternatives for the user to choose from. To learn more, read [Customize MFA Selection in New Universal Login](/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).

Additionally, for SMS, email, and WebAuthn, you can customize the consent screen that Auth0 presents to the user with the information you want to show from authorization_details and other transaction details. To learn more, read [Configure Rich Authorization Requests](/docs/get-started/apis/configure-rich-authorization-requests). For push notifications, this does not apply as the mobile application is the one showing the transaction details to the end user.

Mettre au défi l’utilisateur pour obtenir l’approbation des détails de la transaction

#### Vous pouvez personnaliser le facteur d’authentification à utiliser en fonction des facteurs inscrits par l’utilisateur, des facteurs déjà satisfaits par la session et/ou de vos propres préférences. Vous pouvez également proposer des alternatives à l’utilisateur. Pour en savoir plus, consultez [Personnaliser la sélection MFA dans la nouvelle connexion universelle](/customize-mfa-selection-universal-login).

En outre, pour les SMS, les courriels et WebAuthn, vous pouvez personnaliser l’écran de consentement qu’Auth0 présente à l’utilisateur avec les informations que vous souhaitez afficher à partir de authorization_details et d’autres détails de la transaction. Pour en savoir plus, consultez [Configurer les demandes d’autorisation enrichies](/configure-rich-authorization-requests). Pour les notifications poussées, cela ne s’applique pas car c’est l’application mobile qui présente les détails de la transaction à l’utilisateur final.

<Frame>![](/images/cdy7uua7fh8z/4mEJTT4VsAAAb6I0HhJI6r/851fe5ff489bfc9e5aaa2c52b4644f2c/Mobile_Push_-_English.png)</Frame>

Les sections suivantes expliquent les différents facteurs d’authentification que vous pouvez configurer pour l’autorisation transactionnelle.

To display the `authorization_details` to the user, the mobile application must retrieve them from the `txlnkid` parameter. The [Auth0 Guardian SDK](/docs/secure/multi-factor-authentication/auth0-guardian) passes the `txlnkid` parameter from the tenant to the mobile application via a push notification.

Envoyez une notification poussée à l’appareil mobile enrôlé d’un utilisateur pendant qu’Auth0 invite l’utilisateur à afficher l’écran d’attente de l’authentification multifacteur (MFA) sur l’appareil utilisé (par exemple, l’ordinateur portable d’où provient la transaction).

<Tabs><Tab title="iOS">

```swift lines
let device: AuthenticationDevice = // the object you obtained when enrolling
if let consentId = notification.transactionLinkingId {
    Guardian
        .consent(forDomain: {yourTenantDomain}, device: device)
        .fetch(consentId: consentId, notificationToken: notification.transactionToken)
        .start{result in
            switch result {
            case .success(let payload):
                let authorizationDetails = payload.requestedDetails.authorizationDetails
            case .failure(let cause):
                // something went wrong
        }
    }
}
```






</Tab><Tab title="Android">

```kotlin lines
if (notification.getTransctionLinkingId() != null) {
    guardian
      .fetchConsent(notification, enrollment)
      .start(new Callback<Enrollment> {
        @Override
        void onSuccess(RichConsent consentDetails) {
          List<Map<String, Object>> authorizationDetails = consentDetails
                .getRequestedDetails()
                .getAuthorizationDetails();
        }

        @Override
        void onFailure(Throwable exception) {
          if (exception instanceof GuardianException) {
            GuardianException guardianException = (GuardianException) exception;
            if (guardianException.isResourceNotFound()) {
              // there is no consent associated with the transaction
            }
          }
          // something went wrong
        }
      });
}
```






</Tab></Tabs>

From the post-login Action, you can call `api.multifactor.enable()` before `api.authentication.challengeWith()` to remove the option to remember this device and force the user to validate the push challenge for all transactions. To learn more, read [Action Triggers: post-login - API object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-api-object).

La notification poussée inclut le `event.transaction.linking_id`, que [la trousse SDK Gardien Auth0](/mfa/auth0-guardian) transmet à l’application mobile. Pendant la transaction, le nom de la propriété est abrégé à `txlnkid`. Avec le `linking_id`, l’application mobile peut maintenant récupérer les détails de la transaction et les montrer à l’utilisateur. Une fois que l’utilisateur approuve ou refuse l’opération, l’application mobile peut autoriser ou rejeter le défi MFA respectivement. La transaction passe à la phase [Compléter l’opération](#complete-the-operation).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

To verify the identity of the user opening the push notification, you can add biometric authentication to the mobile application. To learn more, read [Configure WebAuthn with Device Biometrics for MFA](/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa).

</Callout>

#### **Remarque : **Pour vérifier l’identité de l’utilisateur qui ouvre la notification poussée, vous pouvez ajouter l’authentification biométrique à l’application mobile. Pour en savoir plus, consultez [Configurer WebAuthn avec la biométrie de l’appareil pour MFA](/mfa/mfa-factors/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa).

You can also set up phone, email, or WebAuthn as authentication factors to challenge the user. For these authentication factors, Auth0 prompts the user with the corresponding MFA waiting screen. After the user validates the challenge on the MFA waiting screen, Auth0 shows the transaction details to the user for explicit approval. Remember you have to [Configure Rich Authorization Requests](/docs/get-started/apis/configure-rich-authorization-requests) for the approval step to work properly.

Vous pouvez également configurer le téléphone, le courriel ou WebAuthn comme facteurs d’authentification pour mettre au défi l’utilisateur. Pour ces facteurs d’authentification, Auth0 invite l’utilisateur à consulter l’écran d’attente de la MFA correspondant. Une fois que l’utilisateur a validé le défi sur l’écran d’attente de la MFA, Auth0 montre les détails de la transaction à l’utilisateur pour qu’il les approuve explicitement. N’oubliez pas que vous devez [Configurer les demandes d’autorisation enrichies (RAR)](/configure-rich-authorization-requests) pour que l’étape d’approbation fonctionne correctement.

<Frame>![](/images/cdy7uua7fh8z/kYn2A0p2jTY5CUn1FsjVf/b926a1689ee9722e6b902e433a77223b/Phone_Challenge_-_English.png)</Frame>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

From Actions, you can call `api.multifactor.enable('any', { allowRememberBrowser: false })` before `api.authentication.challengeWith` to remove the option to remember this device and force the user to validate the push challenge for all transactions.

</Callout>

Pour le facteur d’authentification par téléphone, Auth0 envoie un code de vérification à l’utilisateur par SMS ou vocalement. La capture d’écran suivante montre l’écran d’attente de la MFA après qu’Auth0 a envoyé le code par SMS :

L’utilisateur reçoit ensuite le SMS contenant le code de vérification.

Une fois que l’utilisateur a saisi le code de vérification dans l’écran d’attente de la MFA, Auth0 l’invite à fournir les détails de la transaction sur un écran de consentement. Une fois que l’utilisateur a approuvé ou refusé les détails de la transaction, celle-ci passe à la phase [Compléter l’opération](#complete-the-operation).

<Warning>

Under PSD2, [email is not a valid authentication factor](https://www.eba.europa.eu/sites/default/documents/files/documents/10180/2622242/4bf4e536-69a5-44a5-a685-de42e292ef78/EBA%20Opinion%20on%20SCA%20elements%20under%20PSD2%20.pdf) for Strong Customer Authentication. We recommend you use another authentication factor to challenge users to meet PSD2 compliance.

</Warning>

#### Le courriel et Webauthn utilisent le même flux d’approbation transactionnelle et des écrans d’attente et d’approbation explicite de la MFA similaires.

Pas de défi

### Si vous ne demandez pas à l’utilisateur un deuxième facteur d’authentification, Auth0 lui propose l’écran de consentement pour obtenir une approbation explicite des détails de la transaction.

To complete the operation, Auth0 follows the standard [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow). If the transaction is approved, the user browser is redirected to your application with an authorization code, which is then exchanged for an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> encrypted using [JSON Web Encryption](/docs/secure/tokens/access-tokens/json-web-encryption). The access token contains the `authorization_details` that you originally passed. The following code sample shows the contents of a decrypted access token:

```json lines
{
 "iss": "https://my_tenant.auth0.com/",
 "sub": "auth0|me",
 "aud": "https://myapi.zewobnak.com",
 "iat": 1683661385,
 "exp": 1683747785,
 "azp": "my_client",
 "transaction_linking_id": "ce4842e8-2894-418a-b1f9-39a330cd4911",
 "authorization_details": [
   {
     "type": "money_transfer",
     "instructedAmount": {
       "amount": 150,
       "currency": "USD"
     },
     "sourceAccount": "xxxxxxxxxxx1234",
     "destinationAccount": "xxxxxxxxxxx9876",
     "beneficiary": "Hanna Herwitz",
     "subject": "A Lannister Always Pays His Debts",
   }
 ]
}
```






Pour compléter l’opération, Auth0 suit le [Flux de code d’autorisation](/not-found/5xWouuRIDiCUS310UW0wq3) standard. Si la transaction est approuvée, le navigateur de l’utilisateur est redirigé vers votre application avec un code d’autorisation, qui est ensuite échangé contre un jeton d’accès chiffré à l’aide du [Chiffrement Web JSON](/json-web-encryption). Le jeton d’accès contient les `authorization_details` que vous avez transmis à l’origine. L’exemple de code suivant montre le contenu d’un jeton d’accès déchiffré :

Transmettez le jeton d’accès à l’API qui facilite le transfert d’argent. L’API vérifie alors les `authorization_details` du jeton d’accès pour vérifier les détails de la transaction, tels que le montant, l’expéditeur, la destination, etc. Une fois vérifié, le transfert d’argent s’exécute avec succès et vous devriez voir apparaître l’écran d’approbation.