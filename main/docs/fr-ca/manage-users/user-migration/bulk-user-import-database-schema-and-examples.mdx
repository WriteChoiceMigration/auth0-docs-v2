---
og:description: Learn how to perform bulk user imports with the Management API.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Schéma de base données pour importation d’utilisateurs en lots et exemples
og:url: https://auth0.com/docs/
permalink: bulk-user-import-database-schema-and-examples
title: Schéma de base données pour importation d’utilisateurs en lots et exemples
twitter:description: Learn how to perform bulk user imports with the Management API.
twitter:title: Schéma de base données pour importation d’utilisateurs en lots et exemples
---

Le fichier des utilisateurs doit contenir un tableau avec les informations des utilisateurs au format JSON.



## Schéma JSON des utilisateurs

Le schéma JSON suivant décrit les utilisateurs valides :



Pour en savoir plus sur le schéma JSON, consultez l’adresse URL [jsonschema.org](http://json-schema.org).

## Propriétés

Vous pouvez importer des utilisateurs ayant les propriétés suivantes :



Pour en savoir plus sur `app_metadata` et `user_metadata`, consultez [Comprendre le fonctionnement des métadonnées dans les profils utilisateurs](/users/metadata).

## Métadonnées d’application

L’objet `user.app_metadata` ne doit contenir **aucune** de ces propriétés suivantes :

* `__tenant`
* `_id`
* `blocked`
* `clientID`
* `created_at`
* `email_verified`
* `email`
* `globalClientID`
* `global_client_id`
* `identities`
* `lastIP`
* `lastLogin`
* `loginsCount`
* `metadata`
* `multifactor_last_modified`
* `multifacteur`
* `updated_at`
* `user_id`

## Hachage de mot de passe personnalisé

L’objet `user.custom_password_hash` peut être utilisé à la place de la propriété `user.password_hash` lorsque le mot de passe a été créé avec un algorithme alternatif. Notez que ce champ et `password_hash` s’excluent mutuellement.

L’objet `user.custom_password_hash` possède les propriétés suivantes :



### Mise à jour du hachage de mot de passe personnalisé

Pendant le processus d’importation en bloc, vous pouvez mettre à jour le `Mot de passe haché personnalisé` si l’utilisateur ne s’est pas connecté en utilisant le `custom_password_hash.` initialement importé. Vous pouvez, par exemple, envoyer deux fois le fichier JSON ci-dessous au point de terminaison` `[`/api/v2/jobs/users-imports`](https://auth0.com/docs/api/management/v2?_ga=2.169020323.346193905.1601302257-746691936.1587131255#!/Jobs/post_users_imports) avec des valeurs différentes pour `custom_password_hash`. Au deuxième envoi, attribuez la valeur `upsert` à l’indicateur `true`.



Vous pouvez utiliser le [générateur de mots de passe Bcrypt](https://www.browserling.com/tools/bcrypt) disponible à l’adresse URL browserling.com pour générer des hachages de mots de passe Bcrypt.

### Algorithmes de hachage pris en charge

Auth0 prend actuellement en charge les importations de mots de passe d’utilisateurs hachés par :

* [Argon2](https://github.com/p-h-c/phc-winner-argon2)
* [bcrypt](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/)
* [LDAP](https://tools.ietf.org/html/rfc2307#section-5.3) (`RFC-2307 "userPassword"`)
* [HMAC](https://tools.ietf.org/html/rfc2104)
* [MD4](https://tools.ietf.org/html/rfc1320)
* [MD5](https://tools.ietf.org/html/rfc1321)
* [SHA1](https://tools.ietf.org/html/rfc3174)
* [SHA256 and SHA512](https://tools.ietf.org/html/rfc4634)
* [PBKDF2](https://tools.ietf.org/html/rfc2898#section-5.2)
* [scrypt](https://datatracker.ietf.org/doc/rfc7914/)

Veuillez tenir compte des sections suivantes lorsque vous fournissez un `custom_password_hash`.

#### Argon2

Lorsque l’`algorithme` est défini sur `argon2` :

* `hash.encoding` doit être au format `utf8`.
* `hash.salt` n’est pas autorisé.
* `hash.value` doit être au format de chaîne PHC, spécifié dans [P-H-C / phc-string-format](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md) sur GitHub. Il doit également être conforme aux exigences spécifiées dans [Auth0 / magic](https://github.com/auth0/magic#magicpasswordhash--magicverifypassword) sur GitHub.
* `hash.value` doit inclure le sel encodé en base64 (comme spécifié dans la documentation `PHC`).

#### bcrypt

Lorsque l’`algorithm` est défini sur `bcrypt` :

* `hash.encoding` doit être au format `utf8`.
* `hash.salt` n’est pas autorisé.
* `hash.value` doit inclure l’un des préfixes suivants :

* `$2a$`
* `$2b$`
* `$2y$`

Certains préfixes, comme `$2$`, `$sha1$`, et `$2x$`, ne sont pas pris en charge pour le moment.

Voici, par exemple, ce qui a été généré à partir de la chaîne `hello` en utilisant un paramètre de coût de 10 :

`$2b$10$nFguVi9LsCAcvTZFKQlRKeLVydo8ETv483lkNsSFI/Wl1Rz1Ypo1K`

L’algorithme `bcrypt` peut traiter un maximum de 72 octets d’entrée lorsqu’il calcule des hachages de mots de passe ou effectue des comparaisons, et la longueur de `salt.value` compte dans la limite des 72 octets d’entrée. Toute entrée dépassant la limite de 72 octets est tronquée; par exemple, si le salage consomme 10 octets, la longueur maximale du mot de passe pour le hachage ou la comparaison est de 62 octets.

Les mots de passe trop longs sont tronqués, ce qui peut affaiblir leur force ou introduire des collisions de hachage. Il est donc important de vérifier la longueur des mots de passe avant de les hacher.

#### HMAC

Lorsque l’`algorithm` est défini sur `hmac` :

* `hash.encoding` doit être au format `hex` ou `base64`.
* `hash.digest` est obligatoire et doit correspondre à l’un des formats suivants :

* `md4`
* `md5`
* `ripemd160`
* `sha1`
* `sha224`
* `sha256`
* `sha384`
* `sha512`
* `whirlpool`
* `hash.key.value` est obligatoire.
* `hash.key.encoding` doit être au format `base64`, `hex` ou `utf8`.

#### LDAP

Lorsque l’`algorithm` est défini sur `ldap` :

* `hash.encoding` doit être au format `utf8`.
* `salt` n’est pas autorisé.
* `hash.value` doit respecter le format décrit dans [RFC-2307 section-5.3 ](https://tools.ietf.org/html/rfc2307#section-5.3) sur IETF Datatracker.
* Le schéma doit être parmi les suivants : `md5|smd5|sha*|ssha*`. Voir [ici](https://www.openldap.org/faq/data/cache/347.html) pour plus d’informations.
* Notez que le schéma [crypt](https://www.openldap.org/faq/data/cache/344.html) n’est **pas pris en charge** en raison d’un comportement dépendant du système ou de l’implémentation. Pour en savoir plus, lisez le [Guide d’administration d’Open LDAP - 14.4.2. Schéma de stockage des mots de passe CRYPT](https://www.openldap.org/doc/admin24/guide.html#CRYPT%20password%20storage%20scheme).

#### MD ou SHA

Lorsque l’`algorithm` est défini sur `md4`, `md5`, `sha1`, `sha256` ou `sha512` :

* `hash.encoding` doit être au format `hex` ou `base64`.

#### PBKDF2

Lorsque l’`algorithm` est défini sur `pbkdf2` :

* `hash.encoding` doit être au format `utf8`.
* `hash.salt` n’est pas autorisé.
* `hash.value` doit être au format de chaîne PHC, spécifié dans [P-H-C / phc-string-format](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md) sur GitHub.
* `hash.value `doit inclure le sel encodé en B64 (base64 omettant les caractères de remplissage `=`, comme spécifié dans la documentation `PHC`).
* `hash.value` doit inclure les paramètres `i` (itérations) et `l` (keylen). Si ces paramètres sont omis, ils sont définis par défaut à `i=100000` et `l=64`.
* La valeur `id` doit être au format `pbkdf2-<digest>`(`pbkdf2-sha512`, `pbkdf2-md5`, etc). Les synthèses prises en charge sont les suivantes :

* `RSA-MD4`
* `RSA-MD5`
* `RSA-MDC2`
* `RSA-RIPEMD160`
* `RSA-SHA1`
* `RSA-SHA1-2`
* `RSA-SHA224`
* `RSA-SHA256`
* `RSA-SHA384`
* `RSA-SHA512`
* `md4`
* `md4WithRSAEncryption`
* `md5`
* `md5WithRSAEncryption`
* `mdc2`
* `mdc2WithRSA`
* `ripemd`
* `ripemd160`
* `ripemd160WithRSA`
* `rmd160`
* `sha1`
* `sha1WithRSAEncryption`
* `sha224`
* `sha224WithRSAEncryption`
* `sha256`
* `sha256WithRSAEncryption`
* `sha384`
* `sha384WithRSAEncryption`
* `sha512`
* `sha512WithRSAEncryption`
* `ssl3-md5`
* `ssl3-sha1`
* `whirlpool`

#### `scrypt`

Lorsque l’`algorithm` est défini sur `scrypt`:

* `hash.encoding` doit être au format `hex` ou `base64`.
* Le paramètre `keylen` est obligatoire.
* Le paramètre `cost` peut être spécifié; dans le cas contraire, la valeur par défaut est 16384.
* Le paramètre `blockSize` peut être spécifié; dans le cas contraire, la valeur par défaut est 8.
* Le paramètre `parallelization` peut être spécifié; dans le cas contraire, la valeur par défaut est 1.

### Facteurs MFA

Le tableau `user.mfa_factors` contient les inscriptions à MFA pour l’utilisateur. Pour en savoir plus, consultez [Authentification multifacteur (MFA) dans Auth0](/mfa). L’importation des inscriptions évite aux utilisateurs de devoir s’inscrire à nouveau à l'authentification multifacteur (MFA) une fois l’importation effectuée. Les types d’inscription pris en charge sont :



## Exemples

### Exemple de base

Un fichier dont le contenu est le suivant est valide :



### Exemples de hachage de mot de passe personnalisé

Quelques exemples d’utilisateurs avec des hachages fournis :



### Exemples de facteurs MFA

Comme vous vous en doutez, le tableau `user.mfa_factors` vous permet de fournir les inscriptions à MFA de l’utilisateur. Les types d’inscription pris en charge sont :

* Téléphone : sert à la vérification par SMS.
* TOTP : secret OTP à utiliser avec les applications de type MFA (Google Authenticator, Microsoft Authenticator, Authy, 1Password, LastPass).
* Courriel : utilisé pour la vérification par courriel.

Quelques exemples d’utilisateurs utilisant des facteurs MFA :