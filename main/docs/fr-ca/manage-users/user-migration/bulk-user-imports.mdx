---
og:description: Learn how to perform bulk user imports with the Management API.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Importation d’utilisateurs par lot
og:url: https://auth0.com/docs/
permalink: bulk-user-imports
title: Importation d’utilisateurs par lot
twitter:description: Learn how to perform bulk user imports with the Management API.
twitter:title: Importation d’utilisateurs par lot
---

You can bulk import user data into Auth0 using the [Create Import Users Job](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) endpoint. Bulk imports are useful for migrating users from an existing database or service to Auth0.

<Warning>

If you try to use more than one migration method (for example, automatic migration then bulk user import), you may encounter a `DUPLICATED_USER` error. This error indicates that the user exists in Auth0's internal user store but not in your tenant. To correct this error, delete the user with the Auth0 Management API [Delete a Connection User](https://auth0.com/docs/api/management/v2#!/Connections/delete_users_by_email) endpoint and then re-attempt the import.

</Warning>

## Prérequis

Avant de lancer la tâche d’importation des utilisateurs :

* Configurez une connexion de base de données dans laquelle importer les utilisateurs et activez-la pour au moins une application.
* Assurez- vous que, si vous importez des mots de passe, ceux-ci sont hachés à l’aide de l’un des algorithmes pris en charge. Les utilisateurs dont les mots de passe sont hachés au moyen d’algorithmes non pris en charge devront réinitialiser leur mot de passe lorsqu’ils se connecteront pour la première fois après l’importation en lot.
* If you are importing <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=MFA">MFA</Tooltip> enrollments, make sure they are a supported type: `email`, `phone`, or `totp`.
* [Get a Management API token](/docs/secure/tokens/access-tokens/management-api-access-tokens) for job endpoint requests.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If you are using an export file from an Auth0 tenant, you must convert the exported file from `ndjson` to [JSON](/docs/manage-users/user-migration/bulk-user-exports#json-compatible-format). To keep the same user IDs, you must remove the `auth0| prefix` from all imported user IDs.

The import process automatically adds the `auth0| prefix` to the imported user IDs. If you do not remove the `auth0|` prefix before importing, the user IDs return as `auth0|auth0|...`

</Callout>

## Créer un fichier JSON pour les utilisateurs

Create a JSON file with the user data you want to import into Auth0. How you export user data to a JSON file will vary depending on your existing user database. The <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> endpoint expects sections of the JSON file. So instead of using `fs.readFileSync`, it requires `fs.createReadStream`. The endpoint expects a piped read stream instead of the whole JSON file.

To learn more about the JSON file schema and see examples, read [Bulk Import Database Schema and Examples](/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

The file size limit for a bulk import is 500KB. You will need to start multiple imports if your data exceeds this size.

</Callout>

## Requête d’importation d’utilisateurs en lots

To start a bulk user import job, make a `POST` request to the [Create Import Users Job](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) endpoint. Be sure to replace the `MGMT_API_ACCESS_TOKEN`, `USERS_IMPORT_FILE.json`, `CONNECTION_ID`, and `EXTERNAL_ID` placeholder values with your Management API <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=Access+Token">Access Token</Tooltip>, users JSON file, database [connection ID](/docs/authenticate/identity-providers/locate-the-connection-id), and external ID, respectively.

<CodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/api/v2/jobs/users-imports' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --form users=@USERS_IMPORT_FILE.json \
  --form connection_id=CONNECTION_ID \
  --form external_id=EXTERNAL_ID
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/jobs/users-imports");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "multipart/form-data; boundary=---011000010111000001101001");
request.AddParameter("multipart/form-data; boundary=---011000010111000001101001", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"users\"; filename=\"USERS_IMPORT_FILE.json\"\r\nContent-Type: text/json\r\n\r\n\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"connection_id\"\r\n\r\nCONNECTION_ID\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"external_id\"\r\n\r\nEXTERNAL_ID\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/users-imports"

	payload := strings.NewReader("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"users\"; filename=\"USERS_IMPORT_FILE.json\"\r\nContent-Type: text/json\r\n\r\n\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"connection_id\"\r\n\r\nCONNECTION_ID\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"external_id\"\r\n\r\nEXTERNAL_ID\r\n-----011000010111000001101001--\r\n")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("content-type", "multipart/form-data; boundary=---011000010111000001101001")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/jobs/users-imports")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("content-type", "multipart/form-data; boundary=---011000010111000001101001")
  .body("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"users\"; filename=\"USERS_IMPORT_FILE.json\"\r\nContent-Type: text/json\r\n\r\n\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"connection_id\"\r\n\r\nCONNECTION_ID\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"external_id\"\r\n\r\nEXTERNAL_ID\r\n-----011000010111000001101001--\r\n")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/jobs/users-imports',
  headers: {
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'content-type': 'multipart/form-data; boundary=---011000010111000001101001'
  },
  data: '-----011000010111000001101001\r\nContent-Disposition: form-data; name="users"; filename="USERS_IMPORT_FILE.json"\r\nContent-Type: text/json\r\n\r\n\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name="connection_id"\r\n\r\nCONNECTION_ID\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name="external_id"\r\n\r\nEXTERNAL_ID\r\n-----011000010111000001101001--\r\n'
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"content-type": @"multipart/form-data; boundary=---011000010111000001101001" };
NSArray *parameters = @[ @{ @"name": @"users", @"fileName": @"USERS_IMPORT_FILE.json", @"contentType": @"text/json" },
                         @{ @"name": @"connection_id", @"value": @"CONNECTION_ID" },
                         @{ @"name": @"external_id", @"value": @"EXTERNAL_ID" } ];
NSString *boundary = @"---011000010111000001101001";

NSError *error;
NSMutableString *body = [NSMutableString string];
for (NSDictionary *param in parameters) {
    [body appendFormat:@"--%@\r\n", boundary];
    if (param[@"fileName"]) {
        [body appendFormat:@"Content-Disposition:form-data; name=\"%@\"; filename=\"%@\"\r\n", param[@"name"], param[@"fileName"]];
        [body appendFormat:@"Content-Type: %@\r\n\r\n", param[@"contentType"]];
        [body appendFormat:@"%@", [NSString stringWithContentsOfFile:param[@"fileName"] encoding:NSUTF8StringEncoding error:&error]];
        if (error) {
            NSLog(@"%@", error);
        }
    } else {
        [body appendFormat:@"Content-Disposition:form-data; name=\"%@\"\r\n\r\n", param[@"name"]];
        [body appendFormat:@"%@", param[@"value"]];
    }
}
[body appendFormat:@"\r\n--%@--\r\n", boundary];
NSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/users-imports"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/users-imports",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"users\"; filename=\"USERS_IMPORT_FILE.json\"\r\nContent-Type: text/json\r\n\r\n\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"connection_id\"\r\n\r\nCONNECTION_ID\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"external_id\"\r\n\r\nEXTERNAL_ID\r\n-----011000010111000001101001--\r\n",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "content-type: multipart/form-data; boundary=---011000010111000001101001"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"users\"; filename=\"USERS_IMPORT_FILE.json\"\r\nContent-Type: text/json\r\n\r\n\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"connection_id\"\r\n\r\nCONNECTION_ID\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"external_id\"\r\n\r\nEXTERNAL_ID\r\n-----011000010111000001101001--\r\n"

headers = {
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'content-type': "multipart/form-data; boundary=---011000010111000001101001"
    }

conn.request("POST", "/{yourDomain}/api/v2/jobs/users-imports", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/users-imports")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'multipart/form-data; boundary=---011000010111000001101001'
request.body = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"users\"; filename=\"USERS_IMPORT_FILE.json\"\r\nContent-Type: text/json\r\n\r\n\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"connection_id\"\r\n\r\nCONNECTION_ID\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"external_id\"\r\n\r\nEXTERNAL_ID\r\n-----011000010111000001101001--\r\n"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "content-type": "multipart/form-data; boundary=---011000010111000001101001"
]
let parameters = [
  [
    "name": "users",
    "fileName": "USERS_IMPORT_FILE.json",
    "contentType": "text/json"
  ],
  [
    "name": "connection_id",
    "value": "CONNECTION_ID"
  ],
  [
    "name": "external_id",
    "value": "EXTERNAL_ID"
  ]
]

let boundary = "---011000010111000001101001"

var body = ""
var error: NSError? = nil
for param in parameters {
  let paramName = param["name"]!
  body += "--\(boundary)\r\n"
  body += "Content-Disposition:form-data; name=\"\(paramName)\""
  if let filename = param["fileName"] {
    let contentType = param["content-type"]!
    let fileContent = String(contentsOfFile: filename, encoding: String.Encoding.utf8)
    if (error != nil) {
      print(error)
    }
    body += "; filename=\"\(filename)\"\r\n"
    body += "Content-Type: \(contentType)\r\n\r\n"
    body += fileContent
  } else if let paramValue = param["value"] {
    body += "\r\n\r\n\(paramValue)"
  }
}

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/users-imports")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

<table class="table"><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>users</code></td>
<td>File in JSON format that contains the users to import.</td>
</tr>
<tr>
<td><code>connection_id</code></td>
<td>ID of the connection to which users will be inserted. You can retrieve the ID using the <a href="https://auth0.com/docs/api/management/v2#!/Connections/get_connections">GET /api/v2/connections</a> endpoint.</td>
</tr>
<tr>
<td><code>upsert</code></td>
<td>Boolean value; <code>false</code> by default. When set to <code>false</code>, pre-existing users that match on email address, user ID, phone, or username will fail. When set to true, pre-existing users that match on email address will be updated, but only with upsertable attributes. For a list of user profile fields that can be upserted during import, see <a href="/docs/manage-users/user-accounts/user-profiles/user-profile-structure#user-profile-attributes">User Profile Structure: User profile attributes</a>. Note: Providing a duplicated user entry in the import file will cause an error. In this case, Auth0 will not do an insert followed by an update.</td>
</tr>
<tr>
<td><code>external_id</code></td>
<td>Optional user-defined string that can be used to correlate multiple jobs. Returned as part of the job status response.</td>
</tr>
<tr>
<td><code>send_completion_email</code></td>
<td>Boolean value; <code>true</code> by default. When set to <code>true</code>, sends a completion email to all tenant owners when the import job is finished. If you do <em>not</em> want emails sent, you must explicitly set this parameter to <code>false</code>.</td>
</tr>
</tbody>
</table>

Vous recevrez une réponse semblable à celle qui suit si la requête réussit :

```json lines
{
  "status": "pending",
  "type": "users_import",
  "created_at": "",
  "id": "job_abc123",
  "connection_id": "CONNECTION_ID",
  "upsert": false,
  "external_id": "EXTERNAL_ID",
  "send_completion_email": true
}
```






L’entité renvoyée représente la tâche d’importation.

Lorsque la tâche d’importation d’utilisateurs est terminée et si la valeur `send_completion_email` est définie sur `true`, l’administrateur du locataire reçoit un courriel l’informant de l’échec ou de la réussite de la tâche. Un courriel pour un travail qui a échoué peut informer le ou les administrateurs que le fichier JSON des utilisateurs n’a pas été analysé lors de l’importation des utilisateurs.

### Tâches d’importation simultanées

The [Create Import Users Job](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) endpoint has a limit of two concurrent import jobs. Requesting additional jobs while there are two pending returns a `429 Too Many Requests` response:

```json lines
{
  "statusCode": 429,
  "error": "Too Many Requests",
  "message": "There are 2 active import users jobs, please wait until some of them are finished and try again
}
```






## Vérifier l’état de la tâche

To check a job's status, make a `GET` request to the [Get a Job](https://auth0.com/docs/api/management/v2#!/Jobs/get_jobs_by_id) endpoint. Be sure to replace the `MGMT_API_ACCESS_TOKEN` and `JOB_ID` placeholder values with your Management API Access Token and user import job ID.

<CodeGroup>
```bash cURL lines
curl --request GET \
  --url 'https://{yourDomain}/api/v2/jobs/JOB_ID' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/jobs/JOB_ID");
var request = new RestRequest(Method.GET);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/JOB_ID"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.get("https://{yourDomain}/api/v2/jobs/JOB_ID")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/jobs/JOB_ID',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/JOB_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/JOB_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN"
    }

conn.request("GET", "/{yourDomain}/api/v2/jobs/JOB_ID", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/JOB_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/JOB_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Vous recevrez une réponse semblable à l’une des suivantes, en fonction de l’état de la tâche d’importation d’utilisateurs :

**En attente**

```json lines
{
  "status": "pending",
  "type": "users_import",
  "created_at": "",
  "id": "job_abc123",
  "connection_id": "CONNECTION_ID",
  "external_id": "EXTERNAL_ID"
}
```






**Terminé**

Si une tâche est terminée, la réponse relative à l’état de la tâche comprendra les totaux des enregistrements réussis, échoués, insérés et mis à jour.

```json lines
{
  "status": "completed",
  "type": "users_import",
  "created_at": "",
  "id": "job_abc123",
  "connection_id": "CONNECTION_ID",
  "external_id": "EXTERNAL_ID",
  "summary": {
    "failed": 0,
    "updated": 0,
    "inserted": 1,
    "total": 1
  }
}
```






En cas d’erreur dans la tâche, celle-ci sera renvoyée comme ayant échoué. Notez toutefois que des informations utilisateur non valides, telles qu’un courriel non valide, n’entraîneront pas l’échec de l’ensemble de la tâche.

Pour connaître les détails des entrées qui ont échoué, consultez **Récupérer les saisies qui ont échoué** ci-dessous.

```json lines
{
  "status": "failed",
  "type": "users_import",
  "created_at": "",
  "id": "job_abc123",
  "connection_id": "CONNECTION_ID",
  "external_id": "EXTERNAL_ID",
}
```






Délais d’expiration

## Toutes les tâches d’importation d’utilisateurs expirent au bout de **deux (2) heures**. Si votre tâche n’est pas terminée pas dans ce délai, elle est marquée comme ayant échoué.

De plus, toutes les données relatives à la tâche sont automatiquement supprimées au bout de 24 heures et ne peuvent plus être consultées par la suite. Pour cette raison, **nous vous conseillons vivement de stocker les résultats des tâches en utilisant le mécanisme de stockage qui vous convient le mieux.**.

Récupérer les saisies qui ont échoué

## Si des erreurs se sont produites dans la tâche d’importation d’utilisateurs, vous pouvez obtenir les détails de l’erreur en effectuant une requête `GET` au point de terminaison [Obtenir le détail des erreurs de la tâche](/api/management/v2#!/Jobs/get_errors). Assurez-vous de remplacer les valeurs fictives `MGMT_API_ACCESS_TOKEN` et `JOB_ID` avec votre jeton d’accès à Management API et l’ID de la tâche d’importation d’utilisateurs.

<Warning>

All of the job-related data is automatically deleted after 24 hours and cannot be accessed thereafter. Because of this, we strongly recommend storing the job results using the storage mechanism of your choice.

</Warning>

If there were errors in the user import job, you can get the error details by making a `GET` request to the [Get Job Error Details](https://auth0.com/docs/api/management/v2#!/Jobs/get_errors) endpoint. Be sure to replace the `MGMT_API_ACCESS_TOKEN` and `JOB_ID` placeholder values with your Management API Access Token and user import job ID.

<CodeGroup>
```bash cURL lines
curl --request GET \
  --url 'https://{yourDomain}/api/v2/jobs/JOB_ID/errors' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/jobs/JOB_ID/errors");
var request = new RestRequest(Method.GET);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/JOB_ID/errors"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.get("https://{yourDomain}/api/v2/jobs/JOB_ID/errors")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/jobs/JOB_ID/errors',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/JOB_ID/errors"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/JOB_ID/errors",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN"
    }

conn.request("GET", "/{yourDomain}/api/v2/jobs/JOB_ID/errors", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/JOB_ID/errors")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/JOB_ID/errors")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Chaque objet d’erreur comprendra un code d’erreur et un message expliquant l’erreur plus en détail. Les codes d’erreur possibles sont les suivants :

```json lines
[
    {
        "user": {
            "email": "test@test.io",
            "user_id": "7af4c65cb0ac6e162f081822422a9dde",
            "custom_password_hash": {
                "algorithm": "ldap",
                "hash": {
                    "value": "*****"
                }
            }
        },
        "errors": [
            {
                "code": "...",
                "message": "...",
                "path": "..."
            }
        ]
    }
]
```






Each error object will include an error code and a message explaining the error in more detail. The possible error codes are:

* ANY_OF_MISSING
* ARRAY_LENGTH_LONG
* ARRAY_LENGTH_SHORT
* CONFLICT
* CONFLICT_EMAIL
* CONFLICT_USERNAME
* CONNECTION_NOT_FOUND
* DUPLICATED_USER
* ENUM_MISMATCH
* FORMAT
* INVALID_TYPE
* MAX_LENGTH
* MAXIMUM
* MFA_FACTORS_FAILED
* MIN_LENGTH
* MINIMUM
* NOT_PASSED
* OBJECT_REQUIRED
* PATTERN

## Learn more

* [Configure Automatic Migration from Your Database](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database)
* [User Import / Export Extension](/docs/manage-users/user-migration/user-import-export-extension)
* [Bulk User Import Database Schema and Examples](/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples)
* [User Migration Scenarios](/docs/manage-users/user-migration/user-migration-scenarios)