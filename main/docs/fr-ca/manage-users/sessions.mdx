---
og:description: Describes what sessions are and how the are used in Auth0.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Sessions
og:url: https://auth0.com/docs/
permalink: sessions
sidebarTitle: Sessions
title: Sessions
twitter:description: Describes what sessions are and how the are used in Auth0.
twitter:title: Sessions
---

Une session est un groupe d’interactions entre un utilisateur et une application pendant une période donnée. Une session unique peut consister en plusieurs activités (telles que la consultation de pages, des événements, des interactions sociales et des transactions de commerce électronique) et peut stocker temporairement ces informations pendant que l’utilisateur est connecté.

With a standard Set-Cookie header implementation, a session ends when a user leaves a website or closes their browser. To prevent users from having to log in every time, applications can extend sessions by setting a maximum lifetime for the <Tooltip tip="Session Cookie: Entity that, when present, allows the user to be considered authenticated." cta="View Glossary" href="/docs/glossary?term=session+cookie">session cookie</Tooltip>. Sessions end when a user logs out or a session lifetime limit is reached.

To learn more, review [Auth0 Privacy and Cookie Policy](https://auth0.com/privacy).

## Cas d’utilisation de la session

Auth0 maintient une session de connexion pour tout utilisateur qui s’authentifie par le biais d’une application. Lorsqu’un utilisateur effectue une nouvelle connexion standard, Auth0 réinitialise la session de connexion. La mise à jour d’un mot de passe, d’une adresse courriel ou d’un numéro de téléphone entraîne également l’expiration de la session Auth0 d’un utilisateur.

When you build an application requiring authentication, you can use sessions to determine whether a user is authenticated each time a request occurs. Depending on how your app has been built, different <Tooltip tip="Authorization Flow: Authorization grant (or workflow) specified in the OAuth 2.0 framework." cta="View Glossary" href="/docs/glossary?term=authorization+flows">authorization flows</Tooltip> are recommended to support a more secure experience for users.

For example, consider an OIDC-compliant (<Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=OpenID">OpenID</Tooltip> Connect) website called storezero.io.

<Frame>![Example e-commerce website Storezero.io](/images/cdy7uua7fh8z/5XXxdX4fuApQtAapQfZU1b/2fd9161af60962e3de3fc951d95b83d1/use-case-storezero.png)</Frame>

Storezero.io n’exige pas que ses utilisateurs se connectent pour effectuer des achats. Toutefois, les utilisateurs doivent se connecter pour consulter la section Mon compte du site.

Pour les cas d’utilisation énumérés ci-dessous, considérons un scénario dans lequel un utilisateur souhaite consulter ses commandes précédentes avant de passer à la caisse. Pour ce faire, il se rend sur la page Toutes les commandes de la section Mon compte et est invité à se connecter.

### Flux de connexion

Most types of applications (such as web apps, single-page apps, and native apps) should use the [Authorization Code Flow with PKCE](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) to facilitate login authentication. This flow involves exchanging an authorization code for tokens.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

The Authorization Code Flow with PKCE replaces the prior use of implicit flow for single-page apps without a backend. New developments must use this flow to ensure optimal security. Migrating existing apps using implicit flow to the PKCE-enhanced authorization code flow is also highly recommended.

</Callout>

#### L’utilisateur se connecte avec son nom d’utilisateur et son mot de passe

Dans cet exemple, un utilisateur se connecte manuellement en utilisant son nom d’utilisateur et son mot de passe :

1. Auth0's SDK creates a local session and redirects the user to the Auth0 authorization server (`/authorize` endpoint).
2. The authorization server creates a session, then redirects the user to the login and authorization prompt.
3. The user authenticates using their username and password.
4. The Auth0 authorization server updates the user’s previously-created session to indicate they are logged in.
5. Depending on the flow used, the authorization server returns the user to your application, along with either an ID token or an authorization code.
6. Your application exchanges the token or authorization code for an access token and completes the flow.

Avec ce flux, deux sessions sont créées :

* La **session locale** (storezero.io), laquelle indique à l’application si un utilisateur est authentifié.
* The **<Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/docs/glossary?term=authorization+server">authorization server</Tooltip> session** (storezero.auth0.com), which indicates to the server whether a user is authenticated. The server session can also optionally track details about the authentication.

  + For example, the authorization server can track if a user leveraged [multi-factor authentication (MFA)](/docs/secure/multi-factor-authentication). This information can then be used to determine whether a user should be prompted to log in or use MFA the next time they arrive at the authorization server.

#### L’utilisateur se connecte avec le fournisseur d’identité

Dans cet exemple, l’utilisateur choisit de se connecter avec Facebook au lieu de son nom d’utilisateur et de son mot de passe :

1. Auth0's SDK creates a local session and redirects the user to the Auth0 authorization server (`/authorize` endpoint).
2. The authorization server creates a session, then redirects the user to the login and authorization prompt.
3. Upon choosing to log in with Facebook, the authorization server redirects the user to Facebook.
4. Facebook creates a session and authenticates the user. Facebook then updates its session to indicate the user is logged in.
5. Facebook returns the user to the Auth0 authorization server. The authorization server then updates its session to indicate the user is logged in.
6. Depending on the flow used, the authorization server returns the user to your application, along with either an ID token or an authorization code.
7. Your application exchanges the token or authorization code for an access token and completes the flow.

In this scenario, three sessions are created: the **local session** (storezero.io), the **authorization server session** (storezero.auth0.com), and an **<Tooltip tip="Identity Provider (IdP): Service that stores and manages digital identities." cta="View Glossary" href="/docs/glossary?term=identity+provider">identity provider</Tooltip> (IdP) session** (facebook.com).

The IdP session on Facebook's server authenticates the user and provides a seamless <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=SSO">SSO</Tooltip> experience. As there is a high probability that users are already logged in to Facebook, users are often authenticated without having to manually provide their Facebook credentials.

### Gestion de session pour les applications à page unique

Dans les exemples précédents, une session locale est créée lorsque l’utilisateur initie l’un ou l’autre flux de connexion. Cette session locale permet aux utilisateurs de rester connectés et de déterminer quand ils doivent se réauthentifier.

However, local sessions are not available for applications without backends, such as single-page apps (SPAs). Instead, these applications use a different approach known as [silent authentication](/docs/authenticate/login/configure-silent-authentication) to keep users logged in.

L’authentification silencieuse utilise la session sur le serveur d’autorisation pour déterminer quand un utilisateur doit se réauthentifier. Une iframe cachée redirige les demandes d’authentification vers le serveur d’autorisation avec le paramètre `prompt=none`. Ce paramètre empêche le serveur de demander à l’utilisateur d’entrer des données.

* If the session on the authorization server has not expired, the transaction continues seamlessly. The server sends an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> through WMRM (Web Message Response Mode), which leverages `postMessage`.
* Si la session sur l’autorisation a expiré ou si l’utilisateur se déconnecte, la redirection dans l’iframe renvoie une erreur. L’application doit alors diriger l’utilisateur vers le serveur d’autorisation pour une nouvelle authentification.

## Learn more

* [Session Layers](/docs/manage-users/sessions/session-layers)
* [Session Lifetime Limits](/docs/manage-users/sessions/session-lifetime-limits)
* [Configure Session Lifetime Settings](/docs/manage-users/sessions/configure-session-lifetime-settings)
* [Cookies](/docs/manage-users/cookies)
* [SameSite Cookie Attribute Changes](/docs/manage-users/cookies/samesite-cookie-attribute-changes)
* [Authenticate Single-Page Apps With Cookies](/docs/manage-users/cookies/spa-authenticate-with-cookies)