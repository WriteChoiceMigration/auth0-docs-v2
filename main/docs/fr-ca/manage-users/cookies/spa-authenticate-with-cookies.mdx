---
description: ''
og:description: Describes how to use your backend server to authenticate a single-page
  app (SPA) with cookies.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Authentifier les applications à page unique avec des témoins
og:url: https://auth0.com/docs/
permalink: spa-authenticate-with-cookies
title: Authentifier les applications à page unique avec des témoins
twitter:description: Describes how to use your backend server to authenticate a single-page
  app (SPA) with cookies.
twitter:title: Authentifier les applications à page unique avec des témoins
---

Assurer la sécurité d’une application à page unique (SPA) peut être difficile. Toutefois, si votre SPA répond aux critères suivants, vous pouvez simplifier votre mise en œuvre en utilisant des témoins pour l’authentification.

* Elle est fournie au client à l’aide de votre propre système dorsal.
* Elle possède le même domaine que votre système dorsal.
* Elle effectue des appels d’API qui nécessitent une authentification à votre système dorsal.

Here is a description of this approach as well as a sample implementation using [Node.js](https://nodejs.org/en/).

## Fonctionnement

The steps below show how tokens are retrieved and used. In this approach, the [Implicit Flow with Form Post](/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) is used instead of a traditional [Authorization Code Flow with Proof Key for Code Exchange](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). This is because Form Post Response Mode is a simpler way to implement login when it’s your own resource you are requesting to access.

<Frame>![Authenticate Single-Page Apps Using Cookies How it Works part 1 diagram](/images/cdy7uua7fh8z/7suPpG6SuHuCOFHeFmE21T/1bf0a56fd21f65460cff7fd01b4c93f4/2023-09-22_13-21-34.png)</Frame>

1. The user accesses a protected route using the browser, or performs some action that requires an authentication step to be initiated (such as clicking on a Login button)
2. The browser client redirects to a `/login` route on the backend, or to the protected route depending on what the user did
3. The backend constructs a request to the authorization server’s `/authorize` endpoint and redirects the browser client there
4. The user is prompted to authenticate themselves using whatever method the authorization server presents
5. The authorization server POSTs the tokens to the redirect URI as a URL-encoded form post. The backend is able to retrieve those tokens by parsing the body data.

À ce stade, l’utilisateur est authentifié et le système dorsal possède les jetons requis. Un témoin peut maintenant être créé pour représenter cet état sur le client. Le navigateur client est alors redirigé vers une route qui dessert la SPA et reçoit également le témoin d’authentification.

Désormais, ce témoin est échangé entre le client et le système dorsal lorsque des appels d’API sont effectués en utilisant un appel AJAX. À chaque requête, le système dorsal vérifie si le témoin est toujours valide et, dans l’affirmative, autorise la poursuite de la requête.

<Frame>![Authenticate Single-Page Apps Using Cookies How it Works part 2 diagram](/images/cdy7uua7fh8z/6SCp9KwQkwJV7L26TOuxIO/d625575a43d00a00fcf17c7310ac2bc8/2023-09-22_13-21-50.png)</Frame>

### Témoins non valides ou manquants

Lors de la mise en œuvre de cette approche, vous devrez gérer les cas où le témoin d’authentification est invalide ou manquant. L’appel d’API au système dorsal du client se fait en arrière-plan, de sorte que le client doit traiter toute réponse du serveur indiquant qu’il faut que l’utilisateur se réauthentifie.

In the following sample application, this case is handled in a naive way by prompting the user to re-authenticate if the API call results in a 302 Redirect result. The 302 occurs because, upon unsuccessful validation of the cookie, the server tries to redirect to the Authorization endpoint of the <Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/docs/glossary?term=authorization+server">authorization server</Tooltip> and sends this response to the client.

## Exemple

Pour illustrer les concepts abordés plus haut, l’exemple d’application utilise Node.js et Express.

### Prérequis

* To follow along, make sure you have the [latest version of Node](https://nodejs.org/en/download/) installed.
* Once Node is installed, [download or clone the source code](https://github.com/auth0-blog/spa-cookie-demo/) and open the project folder inside a terminal window.

  ```bash lines
  # Clone the tutorial respository using SSH
  git clone git@github.com:auth0-blog/spa-cookie-demo
  # ... or if you use HTTPS:
  git clone https://github.com/auth0-blog/spa-cookie-demo.git
  # Move into the project directory
  cd spa-cookie-demo
  ```
* La branche `master` représente l’état de l’application avant que toute authentification soit ajoutée. Si vous souhaitez consulter la version finale de l’application, consultez la branche `with-oidc` :
  `git checkout with-oidc`

### Initialiser l’application Node.js

Install the application dependencies by running `npm install` from your terminal window. To run the application, use `npm run dev`. This starts the Express server. Go to [http://localhost:3000](http://localhost:3000/) in your browser to view the application.

Les serveurs de développement utilisent `nodemon`, qui redémarre automatiquement dès qu’il détecte des changements de fichiers.

### Explorez l’application

With the application open at [http://localhost:3000](http://localhost:3000/), click the **Call API** button. You should see a message displayed on the screen.

<Frame>![SPA Authentication with Cookies Explore the Application screen](/images/cdy7uua7fh8z/7JhdgzFLig2xcDle7ziiGp/c1db6272d20d4a291ba90a6968460109/image3.png)</Frame>

Il est à noter que vous avez pu exécuter l’appel API sans être connecté. Pour remédier à cela, intégrons un logiciel médiateur qui exige que l’utilisateur se connecte avant que l’appel à l’API puisse être effectué.

### Mise en place de l’environnement

Pour que l’application fonctionne avec l’authentification, `express-openid-connect` nécessite la présence de certaines variables d’environnement. Pour cette application, ces variables peuvent être indiquées dans un fichier `.env`. Créez un fichier `.env` dans la racine du répertoire du projet, puis remplissez-le comme suit :

```env .env lines
ISSUER_BASE_URL=\<YOUR OIDC URL>
CLIENT_ID=\<YOUR OIDC CLIENT ID>
BASE_URL=http://localhost:3000
APP_SESSION_SECRET=\<YOUR SECRET VALUE>
```

### Configurer l’application dans Auth0

1. Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click **Create Application**.
2. Name your new application, select **Regular Web Applications**, and click **Create**
3. In the **Settings** for your new app, add `http:/localhost:3000/callback` to **Allowed Callback URLs**.
4. Add `http:/localhost:3000` to **Allowed Logout URLs**.
5. Click **Save Changes**.
6. Go to [Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and set up some social connections. Enable them for your app in the **Application** options in the **Connections** tab. The example uses username/password database, Facebook, Google, and X.
7. On the **Settings** screen, note the domain and client ID settings at the top.
8. There are two values that need to be configured as part of the application. Reopen the `.env` file and set these values:

   ```env .env lines
   ISSUER_BASE_URL={yourDomain}
   CLIENT_ID={yourClientId}
   BASE_URL=http://localhost:3000
   APP_SESSION_SECRET=\<YOUR SECRET VALUE>
   ```

### Exécuter l’application

1. With the server and environment configuration done, find your browser window that has the application open. If you've closed the browser and stopped the server, run the following from the terminal to restart the application:
   `npm run dev`
2. Open `http://localhost:3000` in the browser. From a user interface perspective, the app should look the same, however this time when the **Call API** button is clicked, you should receive a warning that the user is not logged in. Also note that you do not see the "Hello, World" message as before since the call to the API has been rejected.
3. Click **Log in now** to log in. Once you have been authenticated, you'll return to the app and see an updated UI that reflects your new logged-in state. You should be able to press the **Call API** button once more to invoke an API call to the server, and it now works.
4. Click the **Profile** link at the top of the page to show user information retrieved from the ID token.

## Learn more

* [Implicit Flow with Form Post](/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)
* [Secure](/docs/secure)
* [SameSite Cookie Attribute Changes](/docs/manage-users/cookies/samesite-cookie-attribute-changes)