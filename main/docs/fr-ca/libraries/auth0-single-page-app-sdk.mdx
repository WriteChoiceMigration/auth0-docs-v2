---
description: ''
og:description: Auth0 SDK for single page applications using Authorization Code Grant
  Flow with PKCE.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Trousse SDK Auth0 pour les applications à page unique (SPA)
og:url: https://auth0.com/docs/
permalink: auth0-single-page-app-sdk
title: Trousse SDK Auth0 pour les applications à page unique (SPA)
twitter:description: Auth0 SDK for single page applications using Authorization Code
  Grant Flow with PKCE.
twitter:title: Trousse SDK Auth0 pour les applications à page unique (SPA)
---

La trousse SDK Auth0 pour les applications à page unique (SPA) est une nouvelle bibliothèque JavaScript pour la implémentation de l’authentification et de l’autorisation dans les applications à page unique (SPA) avec Auth0. Il fournit une API de haut niveau et gère une grande partie des détails afin que vous puissiez sécuriser les SPA en utilisant les meilleures pratiques, tout en écrivant moins de code.

The Auth0 SPA SDK handles grant and protocol details, token expiration and renewal, as well as token storage and caching. Under the hood, it implements [Universal Login](/docs/authenticate/login/auth0-universal-login) and the [Authorization Code Grant Flow with PKCE](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).

The [library](https://github.com/auth0/auth0-spa-js) and [API documentation](https://auth0.github.io/auth0-spa-js/) are hosted on GitHub.

If you encounter any problems or errors when using the new JavaScript SDK, please [read the FAQ](https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md) to see if your issue is covered there.

## Installation

Vous avez plusieurs options pour utiliser la trousse SDK Auth0 pour les applications à page unique (SPA) dans votre projet :

* From the CDN: `<script src="https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js"></script>`. For more information, read the [FAQ](https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#how-to-use-from-a-cdn).
* With [npm](https://npmjs.org): `npm install @auth0/auth0-spa-js`
* With [yarn](https://yarnpkg.com): `yarn add @auth0/auth0-spa-js`

## Premiers pas

### Créer le client

Tout d’abord, vous devez créer une nouvelle instance de l’objet client `Auth0Client`. Créez l’instance `Auth0Client` avant d’afficher ou d’initialiser votre application. Vous pouvez le faire en utilisant soit la méthode async/await, soit les promesses. Vous ne devez créer qu’une seule instance du client.

L’utilisation de `createAuth0Client` permet de réaliser plusieurs choses automatiquement :

* Elle crée une instance de `Auth0Client`.
* Elle appelle `getTokenSilently` pour actualiser la session de l’utilisateur.
* Elle supprime toutes les erreurs provenant de `getTokenSilently`, à l’exception de `login_required`.

#### Utiliser async/await

```jsx lines
import { createAuth0Client } from '@auth0/auth0-spa-js';

const auth0 = await createAuth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}'
});
```

#### Utiliser les promesses

```jsx lines
createAuth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}'
}).then(auth0 => {
  //...
});
```

Vous pouvez également créer le client directement en utilisant le constructeur `Auth0Client`. Cela peut être utile si vous souhaitez :

* Contourner l’appel à `getTokenSilently` lors de l’initialisation.
* Effectuer une gestion personnalisée des erreurs.
* Initialiser la trousse SDK de manière synchrone.

```jsx lines
import { Auth0Client } from '@auth0/auth0-spa-js';

const auth0 = new Auth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}'
});
```

### Se connecter et obtenir des informations sur l’utilisateur

Ensuite, créez un bouton sur lequel les utilisateurs peuvent cliquer pour commencer à se connecter :

`<button id="login">Click to Login</button>`

Écoutez les événements de clic sur le bouton que vous avez créé. Lorsque l’événement se produit, utilisez la méthode de connexion souhaitée pour authentifier l’utilisateur (`loginWithRedirect()` dans cet exemple). Une fois l’utilisateur authentifié, vous pouvez récupérer le profil utilisateur à l’aide de la méthode `getUser()`.

#### Utiliser async/await

```jsx lines
document.getElementById('login').addEventListener('click', async () => {
  await auth0.loginWithRedirect({
    authorizationParams: {
      redirect_uri: 'http://localhost:3000/'
    }
  });
  //logged in. you can get the user profile like this:
  const user = await auth0.getUser();
  console.log(user);
});
```

#### Utiliser les promesses

```jsx lines
document.getElementById('login').addEventListener('click', () => {
  auth0.loginWithRedirect({
    authorizationParams: {
      redirect_uri: 'http://localhost:3000/'
    }
  }).then(token => {
    //logged in. you can get the user profile like this:
    auth0.getUser().then(user => {
      console.log(user);
    });
  });
});
```

### Appeler une API

To call your API, start by getting the user's <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=Access+Token">Access Token</Tooltip>. Then use the Access Token in your request. In this example, the `getTokenSilently` method is used to retrieve the Access Token:

`<button id="callApi">Call an API</button>`

#### Utiliser async/await

```jsx lines
document.getElementById('callApi').addEventListener('click', async () => {
  const accessToken = await auth0.getTokenSilently();
  const result = await fetch('https://exampleco.com/api', {
    method: 'GET',
    headers: {
      Authorization: 'Bearer ' + accessToken
    }
  });
  const data = await result.json();
  console.log(data);
});
```

#### Utiliser les promesses

```jsx lines
document.getElementById('callApi').addEventListener('click', () => {
  auth0
    .getTokenSilently()
    .then(accessToken =>
      fetch('https://exampleco.com/api', {
        method: 'GET',
        headers: {
          Authorization: 'Bearer ' + accessToken
        }
      })
    )
    .then(result => result.json())
    .then(data => {
      console.log(data);
    });
});
```

### Déconnexion

Ajoutez un bouton sur lequel les utilisateurs peuvent cliquer pour se déconnecter :

`<button id="logout">Logout</button>`

```jsx lines
$('#logout').click(async () => {
  auth0.logout({
    logoutParams: {
      returnTo: 'http://localhost:3000/'
    }
  });
});
```

### Modifier les options de stockage

The Auth0 SPA SDK stores tokens in memory by default. However, this does not provide persistence across page refreshes and browser tabs. Instead, you can opt-in to store tokens in local storage by setting the `cacheLocation` property to `localstorage` when initializing the SDK. This can help to mitigate some of the effects of browser privacy technology that prevents access to the Auth0 <Tooltip tip="Session Cookie: Entity that, when present, allows the user to be considered authenticated." cta="View Glossary" href="/docs/glossary?term=session+cookie">session cookie</Tooltip> by storing Access Tokens for longer.

<Warning>

Storing tokens in browser local storage provides persistence across page refreshes and browser tabs. However, if an attacker can achieve running JavaScript in the SPA using a cross-site scripting (XSS) attack, they can retrieve the tokens stored in local storage. A vulnerability leading to a successful XSS attack can be either in the SPA source code or in any third-party JavaScript code (such as bootstrap, jQuery, or Google Analytics) included in the SPA.

Read more about [token storage](/docs/secure/tokens/token-best-practices).

</Warning>


```jsx lines
const auth0 = await createAuth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}',
  cacheLocation: 'localstorage'
});
```

### Utilisation de jetons d’actualisation rotatifs

The Auth0 SPA SDK can be configured to use [rotating Refresh Tokens](/docs/secure/tokens/refresh-tokens/refresh-token-rotation) to get new access tokens silently. These can be used to bypass browser privacy technology that prevents access to the Auth0 session cookie when authenticating silently, as well as providing built-in reuse detection.

Pour ce faire, configurez la trousse SDK en définissant `useRefreshTokens` sur `true` lors de l’initialisation :


```jsx lines
const auth0 = await createAuth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}',
  useRefreshTokens: true
});

// Request a new access token using a refresh token
const token = await auth0.getTokenSilently();
```

<Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+Tokens">Refresh Tokens</Tooltip> will also need to be [configured for your tenant](/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation) before they can be used in your SPA.

Une fois configuré, la trousse SDK demandera la permission `offline_access` pendant l’étape d’autorisation. En outre, `getTokenSilently` appellera alors le point de terminaison `/oauth/token` directement pour échanger des jetons d’actualisation contre des jetons d’accès.
Le SDK respectera la configuration de stockage lors du stockage des jetons d’actualisation. Si le SDK a été configuré en utilisant le mécanisme de stockage en mémoire par défaut, les jetons d’actualisation seront perdus lors de l’actualisation de la page.

## Utilisation

Vous trouverez ci-dessous des exemples d’utilisation des différentes méthodes de la trousse SDK. Notez que jQuery est utilisé dans ces exemples.

### Connexion avec redirection

Redirect to the `/authorize` endpoint at Auth0, starting the [Universal Login](/docs/authenticate/login/auth0-universal-login) flow:

```jsx lines
$('#loginRedirect').click(async () => {
  await auth0.loginWithRedirect({
    authorizationParams: {
      redirect_uri: 'http://localhost:3000/'
    }
  });
});
```

### Connexion avec fenêtre contextuelle

Use a popup window to log in using the <Tooltip tip="Universal Login: Your application redirects to Universal Login, hosted on Auth0's Authorization Server, to verify a user's identity." cta="View Glossary" href="/docs/glossary?term=Universal+Login">Universal Login</Tooltip> page:

```jsx lines
$('#loginPopup').click(async () => {
  await auth0.loginWithPopup();
});
```

Si l’utilisateur prend plus de temps que le délai par défaut de 60 secondes pour compléter le flux d’authentification, l’authentification sera interrompue et vous devrez gérer l’erreur dans votre code :

Suggérez à l’utilisateur de réessayer et de fermer la fenêtre contextuelle manuellement en utilisant `error.popup.close` :

```jsx lines
$('#loginPopup').click(async () => {
  try {
    await auth0.loginWithPopup();
  } catch {error}
  if (error instanceof auth0.PopupTimeoutError) {
    // custom logic to inform user to retry
    error.popup.close();
  }
});
```

Ou créez une option `popup` personnalisée dans l’objet `options` :

```jsx lines
$('#loginPopup').click(async () => {
  const popup = window.open(
    '',
    'auth0:authorize:popup',
    'left=100,top=100,width=400,height=600,resizable'
  );
  try {
    await auth0.loginWithPopup({ popup });
  } catch {error}
  if (error instanceof auth0.PopupTimeoutError) {
    // custom logic to inform user to retry
    error.popup.close();
  }
});
```

### Connexion avec rappel de redirection

Lorsque le navigateur est redirigé d’Auth0 vers votre application monopage, `handleRedirectCallback` doit être appelé afin de compléter le flux de connexion :

```jsx lines
$('#loginRedirectCallback').click(async () => {
  await auth0.handleRedirectCallback();
});
```

### Obtenir un jeton d’accès sans interaction

Obtenir un nouveau jeton d’accès silencieusement en utilisant une iframe cachée et `prompt=none`, ou en utilisant un jeton d’actualisation rotatif. Les jetons d’actualisation sont utilisés lorsque `useRefreshTokens` est défini sur `true` lors de la configuration de la trousse SDK.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Getting an Access Token silently without using Refresh Tokens will not work in browsers that block third-party cookies, such as Safari and Brave. To learn more about the custom domain workaround, read [Troubleshoot Renew Tokens When Using Safari](/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari).

</Callout>

Si le stockage en mémoire (par défaut) et les jetons d’actualisation sont utilisés, les nouveaux jetons sont récupérés à l’aide d’un agent web sur les navigateurs pris en charge :

```jsx lines
$('#getToken').click(async () => {
  const token = await auth0.getTokenSilently();
});
```

The `getTokenSilently()` method requires you to have **Allow Skipping User Consent** enabled in your [API Settings in the Dashboard](https://manage.auth0.com/#/apis). Additionally, user consent [cannot be skipped on 'localhost'](/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications).

### Obtenir un jeton d’accès avec une fenêtre contextuelle

Les jetons d’accès peuvent également être récupérés à l’aide d’une fenêtre contextuelle. Contrairement à `getTokenSilently`, cette méthode de récupération d’un jeton d’accès fonctionnera dans les navigateurs dont les témoins tiers sont bloqués par défaut :

```jsx lines
$('#getTokenPopup').click(async () => {
  const token = await auth0.getTokenWithPopup({
    authorizationParams: {
      audience: 'https://mydomain/api/',
      scope: 'read:rules'
    }
  });
});
```

### Obtenir un jeton d’accès pour une audience différente

Options may be passed to `getTokenSilently` that get an Access Token with a different <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> and scope of that which was requested at user authentication time.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

This only works when not using Refresh Tokens (`useRefreshTokens: false`), as a Refresh Token is bound to the particular audience and scope that was requested at user authentication time.

</Callout>

```jsx lines
$('#getToken_audience').click(async () => {
  const differentAudienceOptions = {
    authorizationParams: {
      audience: 'https://mydomain/another-api/',
      scope: 'read:rules',
      redirect_uri: 'http://localhost:3000/callback.html'
    }
  };
  const token = await auth0.getTokenSilently(differentAudienceOptions);
});
```

### Obtenir l’utilisateur

Vous pouvez obtenir les données de profil de l’utilisateur authentifié en appelant la méthode `getUser` :

```jsx lines
$('#getUser').click(async () => {
  const user = await auth0.getUser();
});
```

### Obtenir des demandes de jetons d’ID

You can get the claims of the authenticated user's <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+Token">ID Token</Tooltip> by calling the `getIdTokenClaims` method:

```jsx lines
$('#getIdTokenClaims').click(async () => {
  const claims = await auth0.getIdTokenClaims();
  // if you need the raw id_token, you can access it
  // using the __raw property
  const id_token = claims.__raw;
});
```

### Déconnexion (par défaut)

Vous pouvez lancer une action de déconnexion en appelant la méthode `logout` :

```jsx lines
$('#logout').click(async () => {
  auth0.logout({
    logoutParams: {
      returnTo: 'http://localhost:3000/'
    }
  });
});
```

### Déconnexion sans ID client

You can initiate a logout action with no <Tooltip tip="Client ID: Identification value given to your registered resource from Auth0." cta="View Glossary" href="/docs/glossary?term=Client+ID">Client ID</Tooltip> specified by calling the `logout` method and including `clientId: null`:

```jsx lines
$('#logoutNoClientId').click(async () => {
  auth0.logout({
    clientId: null,
    logoutParams: {
      returnTo: 'http://localhost:3000/'
    }
  });
});
```

## Learn more

* [Validate Access Tokens](/docs/secure/tokens/access-tokens/validate-access-tokens)