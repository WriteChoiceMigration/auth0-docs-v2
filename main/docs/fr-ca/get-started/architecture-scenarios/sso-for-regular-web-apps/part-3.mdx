---
og:description: Regular web app scenario application implementation
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Mise en œuvre des applications (Applications Web + SSO)
og:url: https://auth0.com/docs/
permalink: part-3
title: Mise en œuvre des applications (Applications Web + SSO)
twitter:description: Regular web app scenario application implementation
twitter:title: Mise en œuvre des applications (Applications Web + SSO)
---

Let's walk through the implementation of our regular web application. We used ASP .NET Core for the implementation, you can find the code in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-webapp-oidc).

L’exemple contient une application qui utilise l’intégration Active Directory pour authentifier les employés de l’entreprise et une connexion à la base de données Auth0 pour les fournisseurs externes. L’autorisation est mise en œuvre à l’aide de règles et de demandes, comme nous le verrons en détail dans ce paragraphe.

## Connexion utilisateur

Auth0 provides a Lock widget which serves as a login component for your application, meaning that you do not have to implement your own login screen. The Lock widget seamlessly integrates with all of the connections you configure inside your <Tooltip tip="Auth0 Dashboard: Auth0's main product to configure your services." cta="View Glossary" href="/docs/glossary?term=Auth0+dashboard">Auth0 dashboard</Tooltip>, whether they be database, social or enterprise connections.

Il y a plusieurs façons d’implémenter un écran de connexion en utilisant une application Web et Auth0 :

* **Hosted Lock (Lock hébergé)** : Utilisez une instance du gadget logiciel Lock, hébergé dans l’infrastructure Auth0.
* **Embedded Lock (Lock intégré)** : Intégrez le gadget logiciel Lock au sein d’une page Web de votre application. Vous disposez de quelques options de personnalisation pour le gadget logiciel Lock proprement dit et d’un contrôle total sur le reste du code HTML de la page.
* **Custom UI**: Develop a completely custom web page for the login screen. The custom HTML form will post back to your server which will, in turn, authenticate the user using the Authentication API. For more information on when to use a Custom UI, refer to [Customize Classic Login Pages with Lock or SDK](/docs/customize/login-pages/classic-login/customize-with-lock-sdk).

### La meilleure pratique recommandée est d’utiliser Lock hébergé, car c’est l’option la plus sûre et la plus simple pour permettre aux utilisateurs de se connecter à votre application.

By default, Lock will display all the connections available for login. Selecting the appropriate <Tooltip tip="Identity Provider (IdP): Service that stores and manages digital identities." cta="View Glossary" href="/docs/glossary?term=Identity+Providers">Identity Providers</Tooltip> from multiple options is called Home Realm Discovery (HRD). In our case, the options are either authenticating with Active Directory (for company employees) or using email/password for our database connection (external contractors).

Par défaut, Lock affiche toutes les connexions proposées pour l’ouverture de session. La sélection des fournisseurs d’identité appropriés parmi plusieurs options s’appelle Home Realm Discovery (HRD) (Détection du domaine d’accueil). Dans notre cas, les options sont soit l’authentification avec Active Directory (pour les employés de l’entreprise), soit l’utilisation de l’adresse courriel/mot de passe pour la connexion à la base de données (pour les fournisseurs externes).

* Toutefois, vous pouvez souhaiter éviter cette première étape, au cours de laquelle l’utilisateur doit choisir le fournisseur d’identité (IdP), et faire en sorte que le système l’identifie au lieu de le lui poser la question à chaque fois. Lock vous offre les options suivantes :

  + There are multiple practical ways of getting the `connection` value. One of them is to use **vanity URLs**: for example, company employees will use `https://internal.yoursite.com`, while external contractors will use `https://external.yoursite.com`.
* Il existe plusieurs façons pratiques d’obtenir la valeur `connection` . L’une d’entre elles consiste à utiliser des **URL de redirection vers un microsite** : des employés de l’entreprise utiliseront par exemple ` alors que les fournisseurs externes utiliseront `

For additional information on this topic refer to [Select from Multiple Connection Options](/docs/libraries/lock/selecting-from-multiple-connection-options).

## Pour en savoir plus, consultez [Sélectionner parmi plusieurs options de connexion](/libraries/lock/selecting-from-multiple-connection-options).

Gestion des sessions

* En ce qui concerne la gestion des sessions, il y a généralement trois couches de sessions à prendre en compte :
* **Application Session (Session de l’application)** : Cette première couche correspond à la session au sein de l’application. Même si votre application utilise Auth0 pour authentifier les utilisateurs, vous devrez toujours garder une trace du fait que l’utilisateur s’est connecté à votre application. Dans une application Web normale, cela se fait en stockant des informations dans un témoin.
* **Auth0 session (Session Auth0)** : Ensuite, Auth0 conservera également une session et stockera les informations relatives à l’utilisateur dans un témoin. La prochaine fois qu’un utilisateur sera redirigé vers l’écran de verrouillage Auth0, les informations de l’utilisateur seront mémorisées.

**Identity Provider session (Session du fournisseur d’identité)** : Cette dernière couche est celle du fournisseur d’identité, par exemple Facebook ou Google. Si vous avez autorisé les utilisateurs à se connecter avec l’un de ces fournisseurs et qu’ils sont déjà connectés à ce fournisseur, ils n’ont pas besoin de se connecter. Il leur sera simplement demandé de donner l’autorisation de partager leurs informations avec Auth0 et, par conséquent, avec votre application.

<Info>
### How do I control the duration of the user's local application session? Can I drive that from Auth0?

The web app has full control over the user's local application session. How this is done usually depends on the web stack being used (for example, ASP.NET). Regardless, all approaches ultimately use one or more cookies to control the session. The developer can choose to use the expiration of the JWT ID Token returned by Auth0 to control their session duration or ignore it completely. Some developers store the ID Token itself in session state and end the user's session when it has expired.

The reason why you would use the expiration of the token to determine the expiration of the local session is because it gives you centralized control of the duration of a user session from the Auth0 Dashboard.
</Info>

Lors du développement d’une application Web, vous devrez toujours garder à l’esprit que l’utilisateur s’est connecté à votre application Web. Pour ce faire, vous pouvez utiliser une session basée sur les témoins pour garder une trace du fait que l’utilisateur s’est connecté, et également stocker toutes les informations ou jetons liés à l’utilisateur.

<Frame>![undefined](/images/cdy7uua7fh8z/4bqozVk6fF4JrWRP1BJK7Y/1403eb1c0efb12552307358a26c6e7f7/login-flow.png)</Frame>

1. **Initiate OIDC Authentication Flow**: The user's browser will send a request to Auth0 to initiate the OIDC flow.
2. **Set SSO Cookie**: Auth0 will set a cookie to store the user's information.
3. **Code exchange and return ID Token**: Auth0 will make a request back to the web server and return the code. The web server will exchange the code for an ID Token.
4. **Set auth cookie and send response**: The web server will send a response back to the browser and set the application authentication cookie to store the user's session information.
5. **Auth cookie sent with every subsequent request**: The application authentication cookie will be sent on every subsequent request as proof that the user is authenticated.

<Info>
### How does Auth0's SSO session impact the application's session?

Auth0 manages its own single-sign-on session. Applications can choose to honor or ignore that SSO session when it comes to maintaining their own local session. The Lock widget even has a special feature where it can detect if an Auth0 SSO session exists and ask the user if they wish to log in again as that same user.

<Frame>![Lock Widget SSO](https://cdn2.auth0.com/docs/1.14516.0/media/articles/architecture-scenarios/web-app-sso/sso-login.png)</Frame>

If they do so, they are signed in without having to re-enter their credentials with the actual IDP. Even though the user didn't authenticate, the application still performs an authentication flow with Auth0 and obtains a new ID Token, which can be used to then manage the new local application session.
</Info>

**See the implementation in** [**ASP.NET Core**](/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/implementation-aspnetcore#configure-the-cookie-and-oidc-middleware).

## **Voir la mise en œuvre dans **[**ASP.NET Core**](/architecture-scenarios/application/web-app-sso/implementation-aspnetcore#configure-the-cookie-and-oidc-middleware).

Déconnexion de l’utilisateur

* Lorsque vous déconnectez l’utilisateur, vous devez à nouveau réfléchir aux trois couches de sessions dont nous avons parlé précédemment :
* **Auth0 session**: You need to log out the user from Auth0. To do this you redirect the user to `https://{yourDomain}/v2/logout`. Redirecting the user to this URL clears all <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=single+sign-on">single sign-on</Tooltip> cookies set by Auth0 for the user.
* **Identity Provider session**: Although this is not common practice, you can force the user to log out from the Identity Provider used, for example Facebook or Google. To do this add a `federated` query string parameter to the logout URL: `https://{yourDomain}/v2/logout?federated`.

To redirect a user after logout, add a `returnTo` query string parameter with the target URL as the value: `https://{yourDomain}/v2/logout?returnTo=http://www.example.com`. Note, that you will need to add the `returnTo` URL as an **Allowed Logout URLs**. For more information on how to implement this refer to: [Logout](/docs/authenticate/login/logout).

Pour rediriger un utilisateur après la déconnexion, ajoutez un paramètre de chaîne de requête `returnTo` avec l’URL cible comme valeur : ` Notez que vous devrez ajouter la valeur `returnTo` URL en tant qu’**URL de déconnexion autorisées**. Pour en savoir plus sur cette mise en œuvre, consultez : [Déconnexion](/logout).

<Frame>![undefined](/images/cdy7uua7fh8z/5t5iXTeGMUzyKHhqOAGRmp/d51797c6513686ea758f0613d01b55d4/logout-flow.png)</Frame>

1. **Initiate Logout Flow**: The logout flow will be initiated from the browser, for example by the user clicking a **Logout** link. A request will be made to the web server.
2. **Clear user’s local session**: The user's Application Session / Cookie will be cleared.
3. **Redirect browser to Auth0 Logout**: The user's browser will be redirected to the Auth0 Logout URL.
4. **Clear SSO Cookie**: Auth0 will clear the user's SSO Cookie.
5. **Redirect to post-logout URL**: Auth0 will return a redirect response and redirect the user's browser to the `returnTo` query string parameter.

**See the implementation in** [**ASP.NET Core**](/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/implementation-aspnetcore#implement-the-logout).

## **Voir la mise en œuvre dans **[**ASP.NET Core**](/architecture-scenarios/application/web-app-sso/implementation-aspnetcore#implement-the-logout).

Contrôle d’accès

You can either implement authorization directly inside your application, independently of Auth0, or use one of the available ways to retrieve the user authorization levels, put them as authorization claims inside the <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+Token">ID Token</Tooltip> and validate these claims inside your application, once you retrieve the token, to control access.

Vous pouvez implémenter l’autorisation directement dans votre application, indépendamment d’Auth0, ou utiliser l’un des moyens proposés pour récupérer les niveaux d’autorisation de l’utilisateur. Vous pouvez ensuite les placer en tant que demandes d’autorisation à l’intérieur du jeton d’ID et les valider dans votre application, une fois que vous avez récupéré le jeton, pour contrôler l’accès.

* By configuring and using the [Auth0 Authorization Extension](/docs/customize/extensions/authorization-extension).
* En configurant et en utilisant [Auth0 Authorization Extension](/extensions/authorization-extension).
* Add metadata to the user's profile by making use of [rules](/docs/customize/rules).
* Ajouter des métadonnées au profil de l’utilisateur en utilisant des [règles](/rules).

En appelant un service externe à partir d’une règle.

<Card title="Authorization extension">

At this point in time the authorization extension is primarily designed to enforce coarse-grained authorization, for example to control access to an application based on a user's group membership. It is not necessarily designed to control fine-grained access (such as whether a user can perform a specific action inside the application), even though this is how we are utilizing it in this instance.

</Card>

Étant donné que dans notre cas, l’entreprise a déjà mis en place Active Directory, nous appliquerons le contrôle d’accès à l’aide de Authorization Extension en combinaison avec les groupes Active Directory.

Tous les utilisateurs seront implicitement des utilisateurs normaux, mais les administrateurs de feuilles de temps seront affectés à un groupe `Admin` qui leur permettra d’approuver les feuilles de temps. Authorization Extension permet d’associer des groupes à des membres de groupes existants.

Tous les administrateurs de feuilles de temps seront affectés au groupe `Timesheet Administrators` sur Active Directory, qui sera automatiquement mappé au groupe `Admin` à l’intérieur de l’application Feuilles de temps.

1. Determine the user's group membership.
2. Store the user's group membership info as part of the `app_metadata`.
3. Add the user's group membership to the outgoing token.
4. Verify that the user has been granted access to the current application.

### Lorsque vous installez Authorization Extension, elle crée une règle en arrière-plan, qui fait ce qui suit :

To install the Authorization extension navigate to the [Extensions](https://manage.auth0.com/#/extensions) view of your Auth0 Dashboard, and select and install the Auth0 Authorization extension.

Pour installer Authorization Extension, naviguez vers la vue [Extensions](%24%7Bmanage_url%7D/#/extensions)  de votre Auth0 Dashboard, puis sélectionnez l’extension Auth0 Authorization.

Une fois installée, vous verrez l’application listée sous Extensions installées.

Lorsque vous cliquez sur le lien pour ouvrir l’extension pour la première fois, vous serez invité à donner l’autorisation à l’extension d’accéder à votre compte Auth0. Si vous le faites, vous serez redirigé vers le tableau de bord d’autorisation.

<Frame>![undefined](/images/cdy7uua7fh8z/6zOF0mCrLV2rwdpxn9JD1e/5d6e227c4a96260856afd8f94c4212d9/create-admin-group.png)</Frame>

Dans le tableau de bord d’autorisation, naviguez vers Groupes dans le menu de navigation, et créez un nouveau groupe appelé Admin.

<Frame>![undefined](/images/cdy7uua7fh8z/RaMHHJ1G9LoO5xoz3BJnN/b01c93948b1a54b599f1eb106bd8ef26/add-group-mapping.png)</Frame>

Une fois le groupe ajouté, vous pouvez cliquer sur le nouveau groupe pour accéder à la section de gestion des groupes. Allez dans l’onglet Mappages de groupe et ajoutez un nouveau mappage de groupe qui mappera tous les utilisateurs d’Active Directory dans les groupes `Timesheet Admins` au groupe `Admin` que vous venez de créer.

<Frame>![undefined](/images/cdy7uua7fh8z/1whRHGlsRhGhA6vcrsElsv/093716ca939c843729c3022c810ee6a7/view-group-mapping.png)</Frame>

Cliquez sur **Save (Enregistrer)** : le nouveau mappage est listé.

For more information refer to the [Authorization Extension documentation](/docs/customize/extensions/authorization-extension).

### Pour en savoir plus, consultez la [documentation relative à Authorization Extension](/extensions/authorization-extension).

Faire appliquer les autorisations dans votre application

```json lines
{
  "sub": "1234567890",
  "name": "John Doe",
  "authorization": {
    "groups": ["Admin"]
  }
}
```






Lorsque vous avez installé Authorization Extension, une règle Auth0 a été créée, qui ajoutera une demande d’`authorization` avec tous les paramètres liés à l’autorisation pour un utilisateur particulier. Les groupes d’un utilisateur seront ajoutés en tant que sous-demande de la demande `authorization` appelée `groups` et tous les groupes auxquels un utilisateur appartient seront ajoutés en tant que tableau à cette demande. Voici un exemple de ce à quoi peut ressembler la charge utile JSON d’un jeton d’ID avec les groupes énumérés :

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

See the implementation in [ASP.NET Core](/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/implementation-aspnetcore#implement-admin-permissions).

</Callout>