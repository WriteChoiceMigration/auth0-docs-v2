---
og:description: Learn how to authenticate users with the Client-Initiated Backchannel
  Authentication Flow.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Authentification des utilisateurs avec CIBA
og:url: https://auth0.com/docs/
permalink: user-authentication-with-ciba
title: Authentification des utilisateurs avec CIBA
twitter:description: Learn how to authenticate users with the Client-Initiated Backchannel
  Authentication Flow.
twitter:title: Authentification des utilisateurs avec CIBA
---

Client-Initiated Backchannel Authentication (CIBA) does not rely on a client application redirecting the user via the browser to perform the login/authentication process. Instead, the client application directly calls the <Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=OpenID">OpenID</Tooltip> Provider via a backchannel request to initiate the authentication flow.

Le schéma de séquences suivant illustre une mise en œuvre du flux CIBA :

<Frame>![](/images/cdy7uua7fh8z/2Q0CVn6C9pjoxx9pG10Kqi/9333a725fafbb4b5a5d27b0e73451ab3/Screenshot_2025-01-16_at_10.11.19_AM.png)</Frame>

Deux éléments sont définis : un utilisateur autorisant et un utilisateur initiant. L’utilisateur autorisant et l’utilisateur initiant peuvent être deux personnes différentes, par exemple un utilisateur qui appelle un centre d’appel et un agent d’un centre d’appel. Dans d’autres cas d’utilisation, il peut s’agir de la même personne, par exemple un utilisateur qui s’authentifie auprès d’un kiosque de vente au détail ou d’un autre appareil connecté.

Les sections suivantes expliquent étape par étape comment fonctionne l’authentification de l’utilisateur avec le flux CIBA :

* [Conditions préalables](#prerequisites)
* [Étape 1 - L’application client initie une demande CIBA](#step-1-client-application-initiates-a-ciba-request)
* [Étape 2 - Le locataire Auth0 accuse réception de la demande CIBA](#step-2-auth0-tenant-acknowledges-the-ciba-request)
* [Étape 3 - L’application client demande une réponse](#step-3-client-application-polls-for-a-response)
* [Étape 4 - L’application mobile reçoit la notification poussée](#step-4-mobile-application-receives-the-push-notification)
* [Étape 5 - L’application mobile récupère les détails du consentement](#step-5-mobile-application-retrieves-the-consent-details)
* [Étape 6 - L’application mobile présente les détails du consentement à l’utilisateur](#step-6-mobile-application-presents-the-consent-details-to-the-user)
* [Étape 7 - L’application mobile envoie la réponse de l’utilisateur à Auth0](#step-7-mobile-application-sends-the-user-response-back-to-auth0)
* [Étape 8 - Auth0 reçoit la réponse de l’utilisateur une fois le flux terminé](#step-8-auth0-receives-user-response-after-the-flow-completes)
* Conditions préalables

## Pour initier une requête CIBA poussée, l’utilisateur autorisant doit être inscrit à la MFA en utilisant les notifications poussées. Pour vérifier dans Auth0 Dashboard, naviguez vers **User Management (Gestion des utilisateurs) > Users (Utilisateurs)** et cliquez sur l’utilisateur :

Si vous avez défini l’authentification multifacteur (MFA) comme obligatoire pour votre locataire, les utilisateurs sont invités à s’inscrire à la MFA lors de leur prochaine connexion. Vous pouvez également utiliser des [Actions]() pour demander l’inscription à la MFA.

* Integrate your custom mobile application with the [Guardian SDK](/docs/secure/multi-factor-authentication/auth0-guardian#enroll-in-push-notifications). To learn more, read [Configure Client-Initiated Backchannel Authentication](/docs/get-started/applications/configure-client-initiated-backchannel-authentication).
* [Enroll the authorizing user in MFA using push notifications via the Guardian SDK](/docs/secure/multi-factor-authentication/auth0-guardian#enroll-in-push-notifications). To verify in the <Tooltip tip="Auth0 Dashboard: Auth0's main product to configure your services." cta="View Glossary" href="/docs/glossary?term=Auth0+Dashboard">Auth0 Dashboard</Tooltip>, navigate to **User Management > Users** and click on the user:

<Frame>![](/images/cdy7uua7fh8z/21qtk4F1cOQHMpbXxXYu75/51ba9c5fd1457ffee3f73893acf3c97f/Screenshot_2025-01-13_at_4.13.44_PM.png)</Frame>

If you have set <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=Multi-factor+Authentication">Multi-factor Authentication</Tooltip> as always required for your tenant, users are prompted to enroll for MFA at their next login. You can also use [Actions](https://auth0.com/blog/using-actions-to-customize-your-mfa-factors/) to prompt for MFA enrollment.

* [Configure Client-Initiated Backchannel Authentication](/docs/get-started/applications/configure-client-initiated-backchannel-authentication) for your tenant and application.

## Étape 2 - Le locataire Auth0 accuse réception de la demande CIBA

Use the [User Search APIs](/docs/manage-users/user-search) to find the authorizing user for whom you’d like to initiate a CIBA request and obtain their user ID.

Once you have a user ID for the authorizing user, use the Authentication API or our [SDKs](/docs/libraries) to send a CIBA request to the `/bc-authorize` endpoint:

<Tabs><Tab title="cURL">

```bash lines
curl --location 'https://$tenant.auth0.com/bc-authorize' \
  --header 'Content-Type: application/x-www-form-urlencoded' \
  --data-urlencode 'client_id=$client_id' \
  --data-urlencode 'client_secret=$client_secret' \
  --data-urlencode 'login_hint={ "format": "iss_sub", "iss": "https://$tenant.auth0.com/", "sub": "$user_id" }' \
  --data-urlencode 'scope=$scope' \
  --data-urlencode 'binding_message=$binding_message'
```






</Tab><Tab title="C#">

```csharp lines
var response = await authenticationApiClient.ClientInitiatedBackchannelAuthorization(
            new ClientInitiatedBackchannelAuthorizationRequest()
            {
                ClientId = "your-client-id",
                Scope = "openid",
                ClientSecret = "your-client-secret",
                BindingMessage = "your-binding-message",
                LoginHint = new LoginHint()
                {
                    Format = "iss_sub",
                    Issuer = "your-issuer-domain",
                    Subject = "auth0|user-id-here"
                }
            }
        );
```






</Tab><Tab title="Go">

```go lines
resp, err := authAPI.CIBA.Initiate(context.Background(), ciba.Request{
		ClientID:     mgmtClientID,
		ClientSecret: mgmtClientSecret,
		Scope:        "openid",
		LoginHint: map[string]string{
			"format": "iss_sub",
			"iss":    "your-issuer-domain",
			"sub":    "auth0|user-id-here",
		},
		BindingMessage: "TEST-BINDING-MESSAGE",
	})
```






</Tab><Tab title="Java">

```java lines
//Creating AuthClient Instance
AuthAPI auth = AuthAPI.newBuilder(domain, clientId, clientSecret).build();

//Authorize
Map<String, Object> loginHint = new HashMap<>();
        loginHint.put("format", "iss_sub");
        loginHint.put("iss", "your-issuer-domain");
        loginHint.put("sub", "auth0|user-id-here");

Request<BackChannelAuthorizeResponse> request = auth.authorizeBackChannel("openid", "your-binding-message", loginHint);

BackChannelAuthorizeResponse resp = request.execute().getBody();
```






</Tab></Tabs>

<table class="table"><thead>
<tr>
<th><strong>Parameters</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tenant</code></td>
<td>Tenant name. It can also be a custom domain.</td>
</tr>
<tr>
<td><code>client_id</code></td>
<td>Client application identifier.</td>
</tr>
<tr>
<td><code>client_secret</code></td>
<td>Client authentication method used for user authentication with CIBA, such as Client Secret, Private Key JWT, or mTLS Authentication. If you're using Private Key JWT or mTLS, you don't need to include the client secret.</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>Must include <code>openid</code>.<br/><br/>The scope can optionally include <code>offline_access</code> to request a refresh token. However, for one-time authorization of a transaction with the CIBA Flow, a refresh token is not needed and does not have any meaning in this context.<br/></td>
</tr>
<tr>
<td><code>user_id</code></td>
<td>User ID for the authorizing user that is passed within the <code>login_hint</code> structure. If <code>iss_sub</code> format is used, then the user ID is passed within the <code>sub</code> claim.<br/><br/>The user ID for a federated connection may have a different format.<br/></td>
</tr>
<tr>
<td><code>request_expiry</code></td>
<td>The CIBA flow's requested expiry is between 1 and 300 seconds, and it defaults to 300 seconds. Include the <code>request_expiry</code> parameter to set a custom expiry for the CIBA flow.</td>
</tr>
<tr>
<td><code>binding_message</code></td>
<td>Human-readable message used to bind the CIBA flow across the authentication and consumption devices. The binding message is required and up to 64 characters. Use only alphanumeric and <code>+-_.,:#</code> characters.</td>
</tr>
</tbody>
</table>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

There is a user-specific rate limit where the authorizing user will not be sent more than 5 requests per minute.

</Callout>

## Étape 3 - L’application client demande une réponse

Utilisez l’Authentication API ou nos [trousses SDK](/libraries) pour appeler le point de terminaison `/token` en utilisant le type d’autorisation `urn:openid:params:grant-type:ciba` et le `auth_req_id` que vous avez reçu du point de terminaison `/bc-authorize` :

```json lines
{
    "auth_req_id": "eyJh...",
    "expires_in": 300,
    "interval": 5
}
```






Jusqu’à ce que l’utilisateur autorisant la transaction l’approuve, vous devriez recevoir la réponse suivante :

## L’intervalle d’attente pour la demande est d’environ cinq secondes. Si vous interrogez trop fréquemment, vous recevrez la réponse suivante, dont la description varie en fonction de l’intervalle d’attente :

Use the Authentication API or our [SDKs](/docs/libraries) to call the `/token` endpoint using the `urn:openid:params:grant-type:ciba` grant type and the `auth_req_id` you received from the `/bc-authorize` endpoint:

<Tabs><Tab title="cURL">

```bash lines
curl --location 'https://$tenant.auth0.com/oauth/token' \
  --header 'Content-Type: application/x-www-form-urlencoded' \
  --data-urlencode 'client_id=$client_id' \
  --data-urlencode 'client_secret=$client_secret' \
  --data-urlencode 'auth_req_id=$auth_req_id' \
  --data-urlencode 'grant_type=urn:openid:params:grant-type:ciba'
```






</Tab><Tab title="C#">

```csharp lines
var token = await authenticationApiClient.GetTokenAsync(
            new ClientInitiatedBackchannelAuthorizationTokenRequest()
            {
                AuthRequestId = response.AuthRequestId,
                ClientId = "your-client-id",
                ClientSecret = "your-client-secret"
            }
        );
```






</Tab><Tab title="Go">

```go lines
token, err := authAPI.OAuth.LoginWithGrant(context.Background(),
			"urn:openid:params:grant-type:ciba",
			url.Values{
				"auth_req_id":   []string{resp.AuthReqID},
				"client_id":     []string{clientID},
				"client_secret": []string{clientSecret},
			},
			oauth.IDTokenValidationOptions{})
```






</Tab><Tab title="Java">

```java lines
Request<BackChannelTokenResponse> tokenRequest = auth.getBackChannelLoginStatus(authReqId, "grant-type");

BackChannelTokenResponse tokenResponse = tokenRequest.execute().getBody();
```






</Tab></Tabs>

Étape 4 - L’application mobile reçoit la notification poussée

```json lines
{
    "error": "authorization_pending",
    "error_description": "The end-user authorization is pending"
}
```






There is approximately a five-second wait interval for polling. If you poll too frequently, you will receive the following response, where the description varies depending on the backoff interval:

```json lines
{
"error": "slow_down",
"error_description": "You are polling faster than allowed. Try again in 10 seconds."
"interval": 10
}
```






To resolve the error, wait until the next interval (in seconds) to poll the `/token` endpoint.

## Étape 5 - L’application mobile récupère les détails du consentement

Auth0 sends a push notification to the user's registered mobile app or device. The [Guardian SDK](/docs/secure/multi-factor-authentication/auth0-guardian) provides methods to parse the data received from the push notification and return a ready-to-use `Notification` instance. The `Notification` instance includes a transaction linking ID, or `txlinkid`, that the mobile application uses to retrieve the consent details from Auth0.

Les exemples de code suivants sont des exemples d’implémentations iOS et Android qui récupèrent les données depuis Auth0 Consent API :

<Tabs><Tab title="iOS">

```swift lines
//implementing UNUserNotificationCenterDelegate
func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: (UNNotificationPresentationOptions) -> Void) {
    let userInfo = notification.request.content.userInfo
    if let notification = Guardian.notification(from: userInfo) {
         // Implement this function to display the prompt and handle user's consent/rejection.
         handleGuardianNotification(notification: notification)
    }
}
```






</Tab><Tab title="Android">

```kotlin lines
// at the FCM listener you receive a RemoteMessage
@Override
public void onMessageReceived(RemoteMessage message) {
    Notification notification = Guardian.parseNotification(message.getData());
    if (notification != null) {
        // you received a Guardian notification, handle it
        handleGuardianNotification(notification);
        return;
    }
    /* handle other push notifications you might be using ... */
}
```






</Tab></Tabs>

## Étape 6 - L’application mobile présente les détails du consentement à l’utilisateur

L’Auth0 Consent API envoie à l’application mobile une réponse contenant le `binding_message` ou les détails du consentement. L’application mobile présente la demande d’authentification et/ou les détails du consentement à l’utilisateur.

L’exemple de code suivant est un exemple de réponse de l’Auth0 Consent API :

<Tabs><Tab title="iOS">

```swift lines
let device: AuthenticationDevice = // the object you obtained during the initial Guardian SDK enrollment process and stored locally
if let consentId = notification.transactionLinkingId {
    Guardian
        .consent(forDomain: {yourTenantDomain}, device: device)
        .fetch(consentId: consentId, notificationToken: notification.transactionToken)
        .start{result in
            switch result {
            case .success(let payload):
                // present consent details to the user
            case .failure(let cause):
                // something went wrong
        }
    }
}
```






</Tab><Tab title="Android">

```kotlin lines
Enrollment enrollment = // the object you obtained during the initial Guardian SDK enrollment process and stored locally
if (notification.getTransactionLinkingId() != null) {
    guardian
      .fetchConsent(notification, enrollment)
      .start(new Callback<Enrollment> {
        @Override
        void onSuccess(RichConsent consentDetails) {
            // present consent details to the user 
        }
        @Override
        void onFailure(Throwable exception) {
            // something went wrong 
        }
      });
}
```






</Tab></Tabs>

## L’utilisateur peut accepter ou refuser la demande d’authentification à ce stade.

The Auth0 Consent API responds to the mobile application with the consent details, including the `binding_message`, `scope`, and `audience`. The scopes returned to the mobile application are filtered according to your RBAC policy. To learn more, read [Role-Based Access Control](/docs/manage-users/access-control/rbac).

Selon que l’utilisateur accepte ou rejette la demande d’authentification, l’application mobile renvoie la réponse de l’utilisateur à Auth0.

Les exemples de code suivants sont des implémentations iOS et Android qui traitent la réponse de l’utilisateur :

```json lines
{
  "id": "cns_abc123",
  "requested_details": {
    "audience": "https://$tenant.auth0.com/userinfo",
    "scope": ["openid"],
    "binding_message": "21-49-38"
  },
  "created_at": 1746693720
  "expires_at": 1746693750
}
```






L’utilisateur accepte la demande d’authentification

## L’utilisateur rejette la demande d’authentification

Étape 8 - Auth0 reçoit la réponse de l’utilisateur une fois le flux terminé

L’application client termine l’interrogation après avoir reçu une réponse du point de terminaison `/token`. Un flux CIBA nécessite toujours une réponse, soit une approbation, soit un refus, de la part de l’utilisateur qui a donné l’autorisation, et les autorisations existantes ne sont pas vérifiées.

### Si l’utilisateur rejette la requête poussée, vous devriez recevoir la réponse suivante :

<Tabs><Tab title="iOS">

```swift lines
Guardian
    .authentication(forDomain: "{yourTenantDomain}", device: device)
    .allow(notification: notification)
    // or reject(notification: notification, withReason: "hacked")
    .start { result in
        switch result {
        case .success:
            // the auth request was successfully rejected
        case .failure(let cause):
            // something failed, check cause to see what went wrong
        }
    }
```






</Tab><Tab title="Android">

```kotlin lines
guardian
    .allow(notification, enrollment)
    .execute(); // or start(new Callback<> ...)
```






</Tab></Tabs>

### Si l’utilisateur approuve la requête poussée, vous devriez recevoir la réponse suivante :

<Tabs><Tab title="iOS">

```swift lines
Guardian
        .authentication(forDomain: "{yourTenantDomain}", device: device)
        .reject(notification: notification)
        // or reject(notification: notification, withReason: "hacked")
        .start { result in
            switch result {
            case .success:
                // the auth request was successfully rejected
            case .failure(let cause):
                // something failed, check cause to see what went wrong
            }
        }
```






</Tab><Tab title="Android">

```kotlin lines
guardian
    .reject(notification, enrollment) // or reject(notification, enrollment, reason)
    .execute(); // or start(new Callback<> ...)
```






</Tab></Tabs>

## Step 8: Auth0 receives user response after the flow completes

The client application completes the polling upon receiving a response from the `/token` endpoint. A CIBA flow always requires a response, either an approval or decline, from the authorizing user, and existing grants are not checked.

## Step 9: Auth0 returns access token to client application

 If the user rejects the push request, Auth0 returns an error response like the following to the client application:

```json lines
{
    "error": "access_denied",
    "error_description": "The end-user denied the authorization request or it has been expired"
}
```






If the user approves the push request, Auth0 returns an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> like the following to the client application:

```json lines
{
    "access_token": "eyJh...",
    "id_token": "eyJh...",
    "expires_in": 86400,
    "scope": "openid",
    "token_type": "Bearer"
}
```






**Note:** The `id_token` will only be present if the `openid` scope was included in the initial `/bc-authorize` request.

## Learn more

* [Client-Initiated Backchannel Authentication Flow](/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow)
* [Configure Client-Initiated Backchannel Authentication](/docs/get-started/applications/configure-client-initiated-backchannel-authentication)