---
og:description: Keeping your user logged in with Auth0.Android
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Enregistrement Auth0.Android et renouvellement des jetons
og:url: https://auth0.com/docs/
permalink: auth0-android-save-and-renew-tokens
title: Enregistrement Auth0.Android et renouvellement des jetons
twitter:description: Keeping your user logged in with Auth0.Android
twitter:title: Enregistrement Auth0.Android et renouvellement des jetons
---

When an authentication is performed with the `offline_access` scope included, it returns a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=refresh+token">refresh token</Tooltip> that can be used to request a new user token, without forcing the user to perform authentication again.

## Gestionnaire des identifiants

[Auth0.Android](https://github.com/auth0/Auth0.Android) provides a utility class to streamline the process of storing and renewing credentials. You can access the `accessToken` or `idToken` properties from the [Credentials](https://github.com/auth0/Auth0.Android/blob/master/auth0/src/main/java/com/auth0/android/result/Credentials.java) instance. This is the preferred method to manage user credentials.

Credential Managers are included as part of the Auth0.Android SDK. If this is not yet part of your dependencies, follow the instructions in [Auth0.Android](/docs/libraries/auth0-android).

Il existe deux classes que vous pouvez utiliser pour gérer les identifiants :

* `CredentialsManager` stocke les données en texte clair.
* `SecureCredentialsManager` encrypts the data before storing it, using a combination of RSA and AES algorithms along with [Android KeyStore](https://developer.android.com/reference/java/security/KeyStore.html).

## Utilisation de la classe CredentialsManager

### Configurer le gestionnaire d’identifiants

Créer une nouvelle instance en fournissant une `AuthenticationAPIClient` et une implémentation `Storage`.

```kotlin lines
val auth0 = Auth0(this)
val apiClient = AuthenticationAPIClient(auth0)
val manager = CredentialsManager(apiClient, SharedPreferencesStorage(this))
```






### État actuel de l’authentification

Les identifiants stockés sont considérés comme valides s’ils n’ont pas expiré ou s’ils peuvent être actualisés. Vérifier si un utilisateur s’est déjà connecté.

```kotlin lines
val loggedIn = manager.hasValidCredentials()
```






Pour déconnecter l’utilisateur de votre application, supprimez les identifiants stockés et renvoyez-le à l’écran de connexion.

```kotlin lines
manager.clearCredentials()
```






### Récupération des identifiants

Étant donné que les identifiants peuvent devoir être actualisés par rapport aux serveurs Auth0, cette méthode est asynchrone. Fournissez une implémentation de rappel à l’endroit où vous voulez recevoir les identifiants. Les identifiants renvoyés par cette méthode en cas de succès sont toujours valides.

```kotlin lines
manager.getCredentials(object: Callback<Credentials, CredentialsManagerException>() {
    override fun onSuccess(credentials: Credentials) {
        // Use credentials
    }

    override fun onFailure(error: CredentialsManagerException) {
        // No credentials were previously saved or they couldn't be refreshed
    }
})
```






Si l’`accessToken` a expiré, le gestionnaire utilise automatiquement le `refreshToken` et renouvelle les identifiants pour vous. Les nouveaux identifiants seront stockés pour un accès ultérieur.

### Enregistrement des nouveaux identifiants

Vous pouvez enregistrer les identifiants obtenus lors de l’authentification dans le gestionnaire.

```text lines
manager.saveCredentials(credentials)
```






## Utilisation de la classe SecureCredentialsManager

### Configurer SecureCredentialsManager

Créer une nouvelle instance en fournissant un `Context` Android valide, une `AuthenticationAPIClient` et une implémentation de `Storage`.

```kotlin lines
val auth0 = Auth0(this)
val apiClient = AuthenticationAPIClient(auth0)
val manager = SecureCredentialsManager(this, apiClient, SharedPreferencesStorage(this))
```






Les méthodes pour obtenir, enregistrer, vérifier l’existence et effacer les identifiants sont les mêmes que celles décrites dans la section ci-dessus.

### Pré-authentification de l’utilisateur

Cette classe fournit une fonctionnalité optionnelle pour une authentification supplémentaire à l’aide de l’écran de verrouillage configuré de l’appareil.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If Lock Screen Security is set to something different than PIN, Pattern, Password or Fingerprint, this feature isn't available.

</Callout>

Appelez la méthode ci-dessous pour activer l’authentification. Fournit un contexte d’`Activity` valide, un code de demande et deux chaînes facultatives à utiliser comme titre et description de l’écran de verrouillage.

Définissez également une constante de code de demande afin que le code de demande provenant du résultat de l’activité puisse être mis en correspondance.

```kotlin lines
companion object {
  const val RC_UNLOCK_AUTHENTICATION = 123
}

// Called from an Activity
val available = manager.requireAuthentication(this, RC_UNLOCK_AUTHENTICATION, getString(R.string.unlock_authentication_title), getString(R.string.unlock_authentication_description))
```






Si la fonctionnalité est activée, le gestionnaire invitera l’utilisateur à s’authentifier à l’aide de l’écran de verrouillage configuré. Le résultat de cet appel sera obtenu dans la méthode `onActivityResult` de l’activité fournie en premier paramètre. Si la fonctionnalité n’a pas été activée, l’authentification de l’écran de verrouillage sera ignorée.

Après avoir vérifié que le code de demande reçu correspond à celui utilisé dans l’étape de configuration, rediriger les paramètres reçus vers le gestionnaire pour terminer l’authentification. Les identifiants seront envoyés à la fonction de rappel d’origine.

```kotlin lines
override fun onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == RC_UNLOCK_AUTHENTICATION && manager.checkAuthenticationResult(requestCode, resultCode)) {
        return
    }

    super.onActivityResult(requestCode, resultCode, data)
}
```






<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

The `onActivityResult` method was deprecated on 2021 in favor of the new [Activity Result APIs](https://developer.android.com/training/basics/intents/result). However, the Auth0.Android SDK is not compatible with these contracts. You can continue to use the deprecated methods safely.

</Callout>

### Traitement des exceptions d’utilisation

Si un événement inattendu se produit lors de l’enregistrement ou de la récupération des identifiants, une exception `CredentialsManagerException` est levée. Voici quelques-uns des scénarios d’échec auxquels vous pouvez vous attendre :

* Les identifiants à stocker ne sont pas valides (par ex., certains des champs suivants ne sont pas définis : `access_token`, `id_token` ou `expires_at`).
* Les identifiants stockés ont expiré mais il n’y a pas de jeton d’actualisation prévu pour les renouveler automatiquement.
* Les paramètres de sécurité de l’écran de verrouillage de l’appareil ont été modifiés (par ex. le NIP de sécurité a été modifié). Même si `hasCredentials` renvoie un résultat positif, les clés de chiffrement seront considérées comme non valides. Jusqu’à ce que `saveCredentials` soit appelé à nouveau, il ne sera pas possible de décrypter un contenu existant précédemment, car les clés utilisées précédemment ne sont pas les mêmes que les nouvelles.
* L’appareil n’est pas compatible avec certains algorithmes de cryptographie requis par la classe `SecureCredentialsManager`. Cette situation est considérée comme un événement catastrophique et c’est la seule exception qui vous empêchera d’utiliser cette implémentation. Ce scénario se produit lorsque le fabricant d’équipement d’origine a modifié la mémoire morte Android de l’appareil, en supprimant certains des algorithmes officiellement inclus dans chaque distribution Android. Néanmoins, vous pouvez vérifier si c’est le cas dans l’instance d’exception elle-même en appelant la méthode `isDeviceIncompatible`. Ce faisant, vous pouvez décider de l’implémentation de remplacement pour le stockage des identifiants, par exemple en utilisant la classe `CredentialsManager` habituelle.