---
description: Error conditions returned from API calls must be handled and processed
  in an appropriate manner. Failure to do so can lead to unhandled exception situations,
  resulting in premature termination of pipeline execution and ultimately in an authentication
  error being returned.
og:description: Learn about best practices for error handling.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Meilleures pratiques de la gestion des erreurs
og:url: https://auth0.com/docs/
title: Meilleures pratiques de la gestion des erreurs
twitter:description: Learn about best practices for error handling.
twitter:title: Meilleures pratiques de la gestion des erreurs
---

## Envoyer les journaux d’erreurs à un service externe

We recommend sending error event logs to an external service to provide better visibility and diagnosis of anomalous operation. To retain and analyze your log events past the log retention period offered for your subscription plan, [use Auth0 log streaming](/docs/customize/log-streams). You can use services like DataDog and AWS EventBridge. We also offer the ability to send logs to an external service in our [Log Streaming](https://marketplace.auth0.com/features/log-streaming) section in Auth0 Marketplace.

## Utiliser des objets d’erreur dans les règles

There are time constraints regarding how much time a rule has to execute. To learn more, read [Custom Database Action Script Execution Best Practices](/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution). If recovery from an error condition is not possible (or probable) within this time period, then an error condition should be explicitly returned; this is as simple as completing rule execution by returning an instance of a Node `Error` object, as in:

`return callback(new Error('some description'));`

To learn more, read [Class: Error on nodejs.org](https://nodejs.org/api/errors.html#errors_class_error).

Alternativement, une instance spécifique à Auth0 `UnauthorizedError` peut être retournée. Cela déclenchera une condition d’erreur `unauthorized` avec la description de l’erreur fournie, laquelle sera renvoyée à l’application ayant initié l’authentification, c’est-à-dire celle à l’origine de la redirection vers le point de terminaison `/authorize` Cela permet à une application d’offrir une capacité de nouvelle tentative conditionnelle et vous permet d’implémenter des règles pour refuser l’accès en fonction de certaines conditions :

`return callback(new UnauthorizedError('some description'), user, context);`

## Utilisez des descriptions de codes d’erreur significatives

L’objet `UnauthorizedError` renvoie uniquement la description fournie. Pour utiliser un traitement spécifique pour les conditions d’erreur non autorisées, nous vous recommandons de formater vos descriptions pour inclure des informations de code d’erreur facilement accessibles, par exemple :

`'[00043] - my specific error description'`)

## Gestion des exceptions

Les conditions d’erreur inattendues, telles que les exceptions JavaScript non détectées peuvent entraîner l’arrêt prématuré de l’exécution du pipeline, ce qui entraînera finalement le renvoi d’une erreur d’authentification.

For situations involving asynchronous operations, you must use a `catch` handler when using `Promise` object processing. `Promise` object processing can also be effective for error handling during non-asynchronous operations. As illustrated below, a `Promise` object can be used to wrap, say, a synchronous function call, making it easier to implement cascaded error handling via use of promise chaining and the like. To learn more about the Promise object, read [Promise in MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). To learn more about promise chaining, read [Error Handling with Promises on javascript.info](https://javascript.info/promise-error-handling).

```js lines
return new Promise(function(resolve, reject) {
    jwt.verify(
      token,
      secret,{
      clockTolerance: 5},
      function(err, decoded) {
        if (err) {
          reject(err);
        } else {
          resolve(decoded);
      }
    });
  });
```
Alternatively, you can use `try...catch` processing to handle JavaScript exceptions that occur during synchronous operation. To learn more, read [`try...catch` in MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch).Setting up this type of exception handling can often incur performance costs, so use it sparingly; rule performance should be as optimal as possible. A more pragmatic approach is to implement processing that prevents exceptions from occurring rather than handling them once they have occurred. To learn more about best practices, see [Performance Best Practices](/docs/troubleshoot/performance-best-practices).

## Éviter les objets non initialisés dans les règles

Si vous utilisez des objets non initialisés, cela peut provoquer des exceptions. Nous vous recommandons d’inclure l’initialisation dans toute déclaration où l’existence d’un objet est en question. Par exemple :

`user.user_metadata = user.user_metadata || {}`)

Dans une règle, prendre des mesures pour empêcher qu’une exception ne se produise est une bonne pratique et est généralement moins coûteuse en termes de performances et d’utilisation des ressources que la mise en œuvre de la gestion des exceptions.