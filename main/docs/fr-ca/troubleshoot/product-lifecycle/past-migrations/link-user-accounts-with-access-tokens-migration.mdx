---
og:description: Describes how to migrate from using ID tokens to access tokens when
  linking user accounts.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Migrate to Access Tokens for Account Linking (Migrer vers des jetons d’accès
  pour associer les comptes)
og:url: https://auth0.com/docs/
permalink: link-user-accounts-with-access-tokens-migration
title: Migrate to Access Tokens for Account Linking (Migrer vers des jetons d’accès
  pour associer les comptes)
twitter:description: Describes how to migrate from using ID tokens to access tokens
  when linking user accounts.
twitter:title: Migrate to Access Tokens for Account Linking (Migrer vers des jetons
  d’accès pour associer les comptes)
---

Previously you could use <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+tokens">ID tokens</Tooltip> to link and unlink user accounts for some use cases. Auth0 is deprecating this functionality. You will now need to use <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip> in all cases.

<Warning>

This deprecation is in response to a potential security vulnerability. Auth0 strongly recommends that you update your code as soon as possible.

</Warning>

## Fonctionnalités affectées

Les modifications dans l’association des comptes sont :

* Vous ne pouvez plus utiliser de jeton d’ID dans l’en-tête `Authorization`, un jeton d’accès doit être utilisé à la place.
* Si vous utilisez un jeton d’accès dans l’en-tête `Authorization`, avec `update:users` comme permission accordée, vous pouvez envoyer comme le corps de la requête soit le `user_id`, soit le jeton d’ID du compte secondaire.
* Si vous utilisez un jeton d’accès dans l’en-tête `Authorization`, avec `update:current_user_metadata` comme permission accordée, vous ne pouvez envoyer que le jeton d’ID du compte secondaire dans le corps de la requête.
* Si vous envoyez le jeton d’ID du compte secondaire dans le corps de la requête (cas d’utilisation décrits dans les deux points précédents), les conditions suivantes doivent s’appliquer :

  + Le jeton d’ID doit être signé à l’aide de `RS256` (vous pouvez définir cette valeur dans **Dashboard > Clients > Réglages client > Réglages avancés > OAuth**.
  + La demande `aud` du jeton d’ID doit identifier le client et avoir la même valeur que la demande `azp` du jeton d’accès.
* Pour dissocier les comptes, vous ne pouvez plus utiliser de jeton d’ID à l’entête `Authorization`. Vous devez utiliser un jeton d’accès à la place.

Il existe plusieurs façons de lier et de dissocier des comptes. Dans la liste suivante, vous pouvez voir les cas d’utilisation et la façon dont les changements les affectent.

<table class="table"><thead>
<tr>
<th>Use Case</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Use the Management API <code>POST /api/v2/users/{id}/identities</code> endpoint and send the primary account's ID token in the <code>Authorization</code> header.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the Management API <code>POST /api/v2/users/{id}/identities</code> endpoint and send an access token (with scope <code>update:users</code>) in the <code>authorization</code> header, and the secondary account's <code>user_id</code> in the payload.</td>
<td>Not affected</td>
</tr>
<tr>
<td>Use the Management API <code>POST /api/v2/users/{id}/identities</code> endpoint and send an access token (with scope <code>update:current_user_identities</code>) in the <code>Authorization</code> header, and the secondary account's <code>user_id</code> in the payload.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the Management API <code>POST /api/v2/users/{id}/identities</code> endpoint and send an access token in the <code>Authorization</code> header and the secondary account's ID token in the payload.</td>
<td>New use case</td>
</tr>
<tr>
<td>Use the auth0.js library and the primary account's ID token to instantiate <code>auth0.Management</code>.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the auth0.js library and an access token (with scope <code>update:users</code>) to instantiate <code>auth0.Management</code>.</td>
<td>Not affected</td>
</tr>
<tr>
<td>Use the auth0.js library and an access token (with scope <code>update:current_user_identities</code>) to instantiate <code>auth0.Management</code>.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the Management API <code>DELETE	/api/v2/users/{id}/identities/{provider}/{user_id}</code> endpoint and send the primary account's ID token in the <code>Authorization</code> header.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the Management API <code>DELETE	/api/v2/users/{id}/identities/{provider}/{user_id}</code> endpoint and send an access token in the <code>Authorization</code> header.</td>
<td>Not affected</td>
</tr>
</tbody>
</table>

## Actions

Review all your calls to the account linking [Identities endpoint](https://auth0.com/docs/api/management/v2/#!/Users/post_identities) and update those that make use of the vulnerable flow described above. You can update your calls to either of the following:

* **Client-side / user-initiated linking scenarios:** For client-side linking scenarios, make the call to the Identities endpoint using an access token with the `update:current_user_identities` scope, and provide the ID token of the secondary account in the payload (`link_with`). This ID token must be obtained through an <Tooltip tip="OAuth 2.0: Authorization framework that defines authorization protocols and workflows." cta="View Glossary" href="/docs/glossary?term=OAuth">OAuth</Tooltip>/OIDC-conformant flow.
* **Server-side linking scenarios**:For server-side linking scenarios, make the call to Identities endpoint using an access token with the `update:users` scope and provide the `user_id` of the secondary account in the payload.

See [Link User Accounts](/docs/manage-users/user-accounts/user-account-linking/link-user-accounts) for details.

### Associer des comptes d’utilisateurs

To link user accounts you can either call the [Link a User Account endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_identities) of the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> or use the [Auth0.js library](/docs/libraries/auth0js).

#### Associer des comptes d’utilisateurs actuels avec le Management API

Un cas d’utilisation courant consiste à permettre à l’utilisateur connecté d’associer ses comptes à l’aide de votre application.

Prior to the deprecation you could use the primary user's ID token or access token (which contained the `update:current_user_identities` scope) to authenticate with the Management API and use the [Link a User Account endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_identities).

Désormais, vous devez obtenir un jeton d’accès (contenant la permission `update:current_user_identities`) et l’utiliser pour vous authentifier auprès de l’API et utiliser le point de terminaison Associer un compte utilisateur. Les données utiles doivent être le jeton d’ID de l’utilisateur secondaire.

1. Get an access token with the `update:current_user_identities` scope as shown in the following example. The example uses the [implicit flow](/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post), however, you can [get access tokens](/docs/secure/tokens/access-tokens/get-access-tokens) for any application type.
2. Using the previous method using an ID token, your code would look similar to this:

   ```http lines
   https://{yourDomain}/authorize?
         scope=openid
         &response_type=id_token
         &client_id={yourClientId}
         &redirect_uri=https://{yourApp}/callback
         &nonce=NONCE
         &state=OPAQUE_VALUE
   ```


   

   

   En utilisant la nouvelle méthode avec un jeton d’accès, votre code ressemblera à ceci :

   ```http lines
   https://{yourDomain}/authorize?
         audience=https://{yourDomain}/api/v2/
         &scope=update:current_user_identities
         &response_type=token%20id_token
         &client_id={yourClientId}
         &redirect_uri=https://{yourApp}/callback
         &nonce={nonce}
         &state={opaqueValue}
   ```


   

   
3. To get an access token that can access the Management API:

   1. Set the `audience` to `https://{yourDomain}/api/v2/`.
   2. Ask for the `scope` `${scope}`.
   3. Set the `response_type` to `id_token token` so Auth0 will send both an ID token and an access token.
      Si nous décodons le jeton d’accès et examinons son contenu, nous constatons ce qui suit :

      ```json lines
      {
         "iss": "https://{yourDomain}/",
         "sub": "auth0|5a620d29a840170a9ef43672",
         "aud": "https://{yourDomain}/api/v2/",
         "iat": 1521031317,
         "exp": 1521038517,
         "azp": "{yourClientId}",
         "scope": "${scope}"
      }
      ```

      

      

      Remarquez que `aud` est défini sur l’URI de l’API de votre locataire, `scope` sur `${scope}`, et `sub` sur l’identifiant de l’utilisateur connecté.
4. Les conditions suivantes doivent être remplies :

   1. The secondary account's ID Token must be signed with `RS256.`
   2. La demande `aud` dans le jeton d’ID du compte secondaire doit identifier le client et avoir la même valeur que la demande `azp` du jeton d’accès utilisé pour effectuer la demande.
5. Once you have the access token, you can use it to link user accounts. This part remains the same, nothing else changes in the request except for the value you use as `Bearer` token. The response also remains the same.

   ```json lines
   {
      "method": "POST",
      "url": "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities",
      "httpVersion": "HTTP/1.1",
      "headers": [
         {
            "name": "Authorization",
            "value": "Bearer ACCESS_TOKEN"
         },
         {
            "name": "content-type",
            "value": "application/json"
         }
      ],
      "postData" : {
         "mimeType": "application/json",
         "text": "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}"
      }
   }
   ```


   

   

#### Associer les comptes utilisateurs actuels avec auth0.js

If you use [auth0.js library](/docs/libraries/auth0js) to access the Management API and link accounts, then you probably use the ID token of the user's primary identity to instantiate `auth0.Management` and use it to link accounts.

1. Get an access token with the `update:current_user_identities` scope, then use this token to instantiate `auth0.Management`. The final call to `linkUser` remains the same.
2. Using the previous method using an ID token, your code would look similar to this:


   ```javascript lines
   // get an ID Token
       var webAuth = new auth0.WebAuth({
         clientID: '{yourClientId}',
         domain: '{yourDomain}',
         redirectUri: 'https://{yourApp}/callback',
         scope: 'openid',
         responseType: 'id_token'
       });
       // create a new instance
       var auth0Manage = new auth0.Management({
         domain: '{yourDomain}',
         token: '{yourIdToken}'
       });
   ```


   En utilisant la nouvelle méthode avec un jeton d’accès, votre code ressemblera à ceci :


   ```javascript lines
   // get an Access Token
       var webAuth = new auth0.WebAuth({
         clientID: '{yourClientId}',
         domain: '{yourDomain}',
         redirectUri: 'https://{yourApp}/callback',
         audience: 'https://{yourDomain}/api/v2/',
         scope: 'update:current_user_identities',
         responseType: 'token id_token'
       });
       // create a new instance
       var auth0Manage = new auth0.Management({
         domain: '{yourDomain}',
         token: '{yourMgmtApiAccessToken}'
       });
   ```


   

   

   1. Asks for both an Id token and an access token in response (`` responseType: `token id_token` ``).
   2. Sets the Management API as the intended audience of the token (`` audience: `https://YOUR_DOMAIN/api/v2/` ``).
   3. Asks for the required permission (`` scope: `update:current_user_identities` ``).
   4. Authenticates with the Management API using the access token.

#### Associer n’importe quel compte d’utilisateur à Management API

Si vous obtenez un jeton d’accès pour l’association de comptes qui contient la permission `update:users`, et que vous envoyez le `user_id` et le `provider` du compte secondaire dans la requête, vous n’avez pas besoin d’effectuer de modifications.

Toutefois, cette nouvelle méthode offre une alternative. Vous utiliserez toujours un jeton d’accès contenant la permission `update:users` pour vous authentifier auprès de l’API, mais dans la charge utile de la demande, vous pouvez envoyer le jeton d’ID du compte secondaire (au lieu du `user_id` et du `provider`).

<CodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities' \
  --header 'authorization: Bearer ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities"

	payload := strings.NewReader("{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer ACCESS_TOKEN")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")
  .header("authorization", "Bearer ACCESS_TOKEN")
  .header("content-type", "application/json")
  .body("{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities',
  headers: {authorization: 'Bearer ACCESS_TOKEN', 'content-type': 'application/json'},
  data: {link_with: 'SECONDARY_ACCOUNT_ID_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer ACCESS_TOKEN",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"link_with": @"SECONDARY_ACCOUNT_ID_TOKEN" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}"

headers = {
    'authorization': "Bearer ACCESS_TOKEN",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer ACCESS_TOKEN",
  "content-type": "application/json"
]
let parameters = ["link_with": "SECONDARY_ACCOUNT_ID_TOKEN"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Les conditions suivantes doivent être remplies :

* Le jeton d’ID du compte secondaire doit être signé avec `RS256`.
* La demande `aud` dans le jeton d’ID du compte secondaire doit identifier le client et avoir la même valeur que la demande `azp` du jeton d’accès utilisé pour effectuer la demande.

### Désassocier des comptes d’utilisateurs

Si vous utilisez des jetons d’ID pour dissocier des comptes, vous devez mettre à jour votre code pour utiliser des jetons d’accès.

1. First, you must get an access token with the `update:current_user_identities` scope.
2. Using the previous method using an ID token, your code would look similar to this:


   ```http lines
   https://{yourDomain}/authorize?
         scope=openid
         &response_type=id_token
         &client_id={yourClientId}
         &redirect_uri=https://{yourApp}/callback
         &nonce={nonce}
         &state={opaqueValue}
   ```


   

   

   En utilisant la nouvelle méthode avec un jeton d’accès, votre code ressemblera à ceci :


   ```http lines
   https://{yourDomain}/authorize?
         audience=https://{yourDomain}/api/v2/
         &scope=update:current_user_identities
         &response_type=token%20id_token
         &client_id={yourClientId}
         &redirect_uri=https://{yourApp}/callback
         &nonce={nonce}
         &state={opaqueValue}
   ```


   

   
3. To get an access token that can access the Management API:

   1. Set the `audience` to `https://{yourDomain}/api/v2/`.
   2. Ask for the `scope` `${scope}`.
   3. Set the `response_type` to `id_token token` so Auth0 will send both an ID token and an access token.
      Si nous décodons le jeton d’accès et examinons son contenu, nous constatons ce qui suit :


      ```json lines
      {
         "iss": "https://{yourDomain}/",
         "sub": "auth0|5a620d29a840170a9ef43672",
         "aud": "https://{yourDomain}/api/v2/",
         "iat": 1521031317,
         "exp": 1521038517,
         "azp": "{yourClientId}",
         "scope": "update:current_user_identities"
      }
      ```

      

      

      Notice that the `aud` is set to your tenant's API URI, the `scope` to `update:current_user_identities`, and the `sub` to the user ID of the logged in user.
4. Once you have the access token, you can call the [Unlink a user identity endpoint](https://auth0.com/docs/api/management/v2#!/Users/delete_user_identity_by_user_id) of the Management API, using it in the `Authorization` header.
5. Using the previous method, your call would look similar to this:

   ```http lines
   DELETE https://YOUR_DOMAIN/api/v2/users/{primaryAccountUserId}/identities/{secondaryAccountProvider}/{secondaryAccountUserId}
       Authorization: 'Bearer {yourIdTokenOrMgmtApiAccessToken}'
   ```


   

   

   En utilisant la nouvelle méthode, votre requête ressemblera à ceci :

   ```http lines
   DELETE https://{yourDomain}/api/v2/users/{primaryAccountUserId}/identities/{secondaryAccountProvider}/{secondaryAccountUserId}
       Authorization: 'Bearer {yourMgmtApiAccessToken}'
   ```


   

   

## Considérations relatives à la sécurité

Nous avons identifié une faiblesse dans le flux de liaison d’un compte particulier qui pourrait permettre de l’utiliser à mauvais escient dans des circonstances spécifiques. Nous n’avons trouvé aucune preuve que cela ait été utilisé de manière malveillante, mais nous avons décidé de déprécier le flux pour éviter que cela ne se produise.

Par conséquent, Auth0 demande aux clients qui utilisent le flux de liaison de compte affecté de migrer vers une implémentation plus sécurisée avant le 19 octobre 2018. Le présent guide fournit des pistes de migration qui ne devraient pas entraîner de perte de fonctionnalité.

À partir du 19 octobre 2018, le flux de liaison des comptes concernés sera désactivé et des erreurs d’exécution se produiront.

You are impacted if you call the [Post Identities endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_identities) using a token (ID or access token) with the scope `update:current_user_identities` in the Authorization header and include the secondary account's `user_id` in the payload. No other use cases are impacted.

## Learn more

* [Migrate to Management API Endpoints with Access Tokens](/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-calling-api-with-access-tokens)