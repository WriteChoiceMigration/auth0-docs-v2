---
description: ''
og:description: Auth0 SDK for single page applications using Authorization Code Grant
  Flow with PKCE.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Auth0 Single-Page App SDK
og:url: https://auth0.com/docs/
permalink: auth0-single-page-app-sdk
title: Auth0 Single-Page App SDK
twitter:description: Auth0 SDK for single page applications using Authorization Code
  Grant Flow with PKCE.
twitter:title: Auth0 Single-Page App SDK
---

Auth0 Single-Page App SDKは新しいJavaScriptライブラリーで、シングルページアプリ（SPA）でAuth0を使って認証と認可を実装します。高水準のAPIを提供して、大量の詳細情報を処理しているため、作成するコードの量を低減しながら、SPAにベストプラクティスを実装することができます。

Auth0 SPA SDKは、付与とプロトコルの詳細、トークンの失効と更新、そして、トークンの保管とキャッシュをも処理します。内部では、[ユニバーサルログイン](/universal-login)と[PKCEを用いた認可コード付与フロー](/login/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)を実装しています。

[ライブラリ](https://github.com/auth0/auth0-spa-js)と[APIドキュメント](https://auth0.github.io/auth0-spa-js/)はGitHubでホストされます。

新しいJavaScript SDKを使用中に問題やエラーが発生した場合は、[FAQ（よくある質問）をお読みになられて](https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md)、問題が提示されているか確認してください。

## インストール

プロジェクトでAuth0 SPA SDKを使用するには、いくつかのオプションがあります。

* CDNから：`<script src="https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js"></script>`。詳細については、「[FAQ](https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#how-to-use-from-a-cdn)」をお読みください。
* [npm](https://npmjs.org)を使用する場合：`npm install @auth0/auth0-spa-js`
* [yarn](https://yarnpkg.com)を使用する場合：`yarn add @auth0/auth0-spa-js`

## はじめに

### クライアントを作成する

まず、`Auth0Client`クライアントプロジェクトの新しいインスタンスを作成する必要があります。`Auth0Client`インスタンスを作成してから、アプリケーションのレンダリングまたは初期化を行います。これを行うには、async/awaitメソッドまたはpromiseを使用します。クライアントには必ずインスタンスを1つだけ作成します。

`createAuth0Client`を使用すると、いくつかの処理が自動的に行われます。

* `Auth0Client`のインスタンスを作成する。
* `getTokenSilently`を呼び出し、ユーザーセッションを更新する。
* `getTokenSilently`からのエラーをすべて抑止する（`login_required`を除く）。

#### async/awaitを使用する



#### promiseを使用する



`Auth0Client`コンストラクターを使って、クライアントを直接作成することもできます。これは、以下の場合に便利です。

* 初期化時に`getTokenSilently`への呼び出しをバイパスする
* カスタムエラー処理を行う
* SDKを同期的に初期化する



### ログインしてユーザー情報を取得する

次に、ユーザーがクリックしてログインを始めるボタンを作成します。

`<button id="login">クリックしてログイン</button>`

作成したボタンのクリックイベントを待ち合わせます。イベントが発生した際には、適切なログインメソッドを実行してユーザーを認証します（この例では`loginWithRedirect()`）。ユーザーが認証されたら、`getUser()`メソッドでユーザープロファイルを取得できます。

#### async/awaitを使用する



#### promiseを使用する



### APIを呼び出す

APIを呼び出すには、ユーザーのアクセストークンを取得することから始めます。それから、要求にアクセストークンを使用します。この例では、`getTokenSilently`メソッドを使ってアクセストークンを取得します。

`<button id="callApi">APIを呼び出す</button>`

#### async/awaitを使用する



#### promiseを使用する



### ログアウト

ユーザーがログアウトするのにクリックするボタンを追加します。

`<button id="logout">ログアウト</button>`



### ストレージオプションを変更する

Auth0 SPA SDKはデフォルトでトークンをメモリーに保管します。ところが、ページの更新やブラウザーのタブでは永続性が途絶えてしまします。代わりに、SDKの初期化時に`cacheLocation`プロパティを`localstorage`に設定することで、トークンをローカルストレージに保存するよう選択できます。これは、Auth0のセッションCookieがアクセストークンを長期保管するのに対して、ブラウザーのプライバシー保護技術がそのアクセスを妨げる弊害を低減するのに役立ちます。



### リフレッシュトークンのローテーションを使用する

[リフレッシュトークンをローテーション](/security/tokens/refresh-tokens/refresh-token-rotation)させて、サイレントモードで新しいアクセストークンを取得するように、Auth0 SPA SDKを構成できます。これによって、サイレント認証時にAuth0のセッションCookieへのアクセスを妨げるブラウザーのプライバシー保護技術を迂回するだけでなく、再利用の検出を組み込むこともできます。

このためには、初期化時に`useRefreshTokens`を`true`に設定してSDKを構成します。



リフレッシュトークンは、SPAで使用する前に[テナント用に構成される](/security/tokens/refresh-tokens/configure-refresh-token-rotation)必要もあります。

構成を終えると、SDKは認可ステップ中に`offline_access`スコープを要求します。さらに、`getTokenSilently`は`/oauth/token`エンドポイントを呼び出し、フレッシュトークンをアクセストークンに直接交換します。SDKはリフレッシュトークンの保管について、ストレージ設定に従います。SDKがデフォルトのメモリー内ストレージに構成されている場合、リフレッシュトークンはページが更新されると失われます。

## 使用状況

以下は、SDKでさまざまなメソッドを使った例です。3つの例でjQueryが使用されていることに注意してください。

### リダイレクトでログインする

Auth0で`/authorize`エンドポイントにリダイレクトし、[ユニバーサルログイン](/universal-login)フローを開始します。



### ポップアップでログインする

ユニバーサルログインのページでポップアップ画面を使用してログインします。



ユーザーが認証フローを完了するのに、デフォルトの60秒のタイムアウトよりも長くかかった場合には、認証が中断されます。この際には、コードでエラーをキャッチして、以下のいずれかを行う必要があります。

再試行し、`error.popup.close`を使ってポップアップを手動で閉じることをユーザーに求めます。



または、`options`オブジェクトでカスタム`popup`オプションを作成します。



### リダイレクトのコールバックでログインする

ブラウザーがAuth0からSPAにリダイレクトされると、ログインフローを完了するために`handleRedirectCallback`を呼び出す必要があります。



### ユーザーの関与なくアクセストークンを取得する

非表示のiframe と`prompt=none`を使用するか、またはリフレッシュトークンをローテーションさせることで、サイレントモードで新しいアクセストークンを取得します。リフレッシュトークンは、SDKの構成時に`useRefreshTokens`が`true`に設定されている場合に使用されます。



メモリー内ストレージ（デフォルト）の設定でリフレッシュトークンが使用されると、新しいトークンは対応しているブラウザーのウェブワーカー（Web Worker）を使って取得されます。



`getTokenSilently()`メソッドを使用する場合は、**［Allow Skipping User Consent（ユーザー同意をスキップさせる）］**が[DashboardのAPI設定](%24%7Bmanage_url%7D/#/apis)で有効になっている必要があります。さらに、ユーザー同意を['localhost'でスキップすることはできません](/applications/confidential-and-public-applications/user-consent-and-third-party-applications)。

### ポップアップでアクセストークンを取得する

アクセストークンはポップアップでも取得することができます。`getTokenSilently`とは違って、サードパーティのCookieがデフォルトで阻止されているブラウザーでも動作します。



### 異なるオーディエンスにアクセストークンを取得する

オプションは、ユーザー認証時に要求された、異なるオーディエンスとそのスコープを持つアクセストークンを取得する`getTokenSilently`に渡すこともできます。





### ユーザーを取得する

認証されたユーザーのプロファイルデータを取得するには、`getUser`メソッドを呼び出します。



### IDトークンのクレームを取得する

認証されたユーザーのIDトークンにあるクレームを取得するには、`getIdTokenClaims`メソッドを呼び出します。



### ログアウト（デフォルト）

ログアウトのアクションを開始するには、`logout`メソッドを呼び出します。



### クライアントIDなしでログアウトする

クライアントIDが指定されていないログアウトのアクションを開始するには、`logout`メソッドを呼び出し、`clientId: null`を含めます。