---
description: ''
og:description: Using Auth0's Authentication API with your PHP applications.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: PHP：Auth0-PHPでAuthentication APIを使用する
og:url: https://auth0.com/docs/
permalink: using-the-authentication-api-with-auth0-php
title: PHP：Auth0-PHPでAuthentication APIを使用する
twitter:description: Using Auth0's Authentication API with your PHP applications.
twitter:title: PHP：Auth0-PHPでAuthentication APIを使用する
---

Auth0 PHP SDKには`Auth0\SDK\API\Authentication`クラスが用意されています。このクラスには、[Authentication API](https://auth0.com/docs/api/authentication)に直接アクセスするのに使用できるメソッドが提供kされています。このインターフェイスはより高度なアプリケーションを対象としており、一般的にユーザーセッションを追跡する手段を提供するものではないことにご注意ください。ほとんどのユースケースでは、[Auth0の基本クラス](/libraries/auth0-php/auth0-php-basic-use)の使用をお勧めします。

以下では、一般的な認証についての例を説明します。

## 前提条件

以下の説明では、[インストールと使用の開始](/libraries/auth0-php)にある手順が完了していることを前提に、手順で提供されたコードを使用します。

## 認可コードフロー

[認可コードフロー](/login/flows/authorization-code-flow)は、ユーザーにアプリケーションへのアクセスを付与する基本的な方法です。このフローは、[Auth0-PHP Basic Use（Auth0-PHPの基本使用）](/libraries/auth0-php/auth0-php-basic-use)ページで使用されているものと同じです。ログインやコールバックのプロセスにより細かい制御が必要な場合は、このセクションにAuthentication APIを直接使用する方法が記載されています。

ユーザーはAuth0で認証を行い、認可コードを生成する必要があります。これは、テナントドメインの/authorizeエンドポイントにリダイレクトすることで行われます。認証が必要なページには、以下のコードが表示されます。



上記のプロセスでは、以下を行います。

1. 認証されたユーザーの状態がカスタムセッションハンドラーに保管されているかを確認します。使用しているアプリケーションによっては、ユーザーセッションの扱いが異なるかもしれません。
2. セッションがない場合は、ユーザーをユニバーサルログインページにリダイレクトして、ユーザーをログインさせる必要があります。
3. ログイン要求に状態値を設定し、Callback URLでコードが返されたときにその値を検証します。これをPHPセッションのstateキーに保管します。
4. `getLoginLink()`の呼び出しは、`/authorize`リンクを構築します。このリンクには、正しい応答タイプ（この場合は`code`）、リダイレクトURI（下記で説明するように、応答を処理するアプリケーションの場所）、状態（上記）が含まれます。
5. その後、このURLにリダイレクトし、ユーザーがリダイレクトで戻されるのを待機します。

認証後、ユーザーがCallback URLでアプリケーションにリダイレクトされ、以下の処理を行います。



このプロセスを詳しく説明します。

1. 要求クエリ内で`code`パラメーターを探します。見つからない場合には、認証を中止します。
2. `state`値の存在を確認し、生成した値と一致しているかを確認します。[これはCSRF攻撃を回避するために重要です。](/attack-protection)
3. コードの交換を試みます。Auth0から認証中のユーザーが戻されたときに、アプリケーションに提供された`code`を`codeExchange()`に渡して呼び出します。
4. これが成功すれば、交換が成功したことがわかり、IDトークンやアクセストークンを含めて、他にも潜在的な値を取得しています。
5. IDトークンを検証し、クレームをユーザーのIDとして使用します。
6. この最後の手順が成功したら、ユーザーを保管し、機密データにリダイレクトで戻します。

## クライアントの資格情報フロー

[クライアントの資格情報フロー](/login/flows/client-credentials-flow)は、ダッシュボードで設定されたスコープに基づいて、アプリケーションが特定のAPIにアクセスできるようにします。これにより、アプリケーションはManagement APIの呼び出しなどを行うことができます。認証が成功すると、要求されたAPIにアクセストークンが発行されます。

まず、**［Client Credentials（クライアントの資格情報）］**の付与を有効にします。これの設定は、アプリケーションの設定ページの**［Advanced settings（高度な設定）］>［Grant Types（付与タイプ）］**タブにあります。

次に、APIの**［Settings（設定）］**ページにある**［Machine to Machine Applications（マシンツーマシンアプリケーション）］**タブで、使用しているAPIにアプリケーションを認可します。必要な（ただし必要以上ではない）すべてのスコープが選択されていることを確認してから、**更新**します。**［Settings（設定）］**タブに戻って、**［Identifier（識別子）］**の値をコピーします。これを、`.env`ファイルで`AUTH0_MANAGEMENT_AUDIENCE`キーに追加する必要があります。

以下の例を参考に、APIのアクセストークンを要求します。



付与が成功すると、以下が表示されるはずです。



このアクセストークンの使い方については、「[Auth0-PHPでManagement APIを使用する](/libraries/auth0-php/using-the-management-api-with-auth0-php)」を参照してください。

## シングルサインオンからのログアウト

`session_destroy()`を使ってローカルセッションを破棄するだけでも、アプリケーションからユーザーを認証解除するには十分ですが、Auth0でもエンドユーザーのセッションを閉じるべきです。こうすることで、次回にAuth0のログインフォームが表示されたときに、ユーザーがログインするには、必ず資格情報の提供が必要になります。まず、ログアウトの完了後、ユーザーがどこに行くのかを決定します。これをAuth0のアプリケーション設定のAllowed Logout URLs（許可されているログアウトURL）フィールドに保存します。また、このURLを値とした`AUTH0_LOGOUT_RETURN_URL`キーを`.env`ファイルに追加します。アプリケーションのログアウトコードに、以下を追加します。