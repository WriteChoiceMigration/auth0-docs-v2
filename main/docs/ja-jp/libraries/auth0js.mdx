---
description: ''
og:description: How to install, initialize and use auth0.js v9
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Auth0.js v9の参考情報
og:url: https://auth0.com/docs/
permalink: auth0js
title: Auth0.js v9の参考情報
twitter:description: How to install, initialize and use auth0.js v9
twitter:title: Auth0.js v9の参考情報
---

Auth0.jsは、Auth0クライアント側ライブラリーです。[ユニバーサルログイン](/universal-login)と一緒に使用することをお勧めします（ユニバーサルログインは、可能な限り使用してください）。SPAでauth0.jsを使用すると、Auth0での認証・認可が簡単になります。

ライブラリーの完全なAPIドキュメントは[こちら](https://auth0.github.io/auth0.js/index.html)です。



## そのまま使えるサンプル

auth0.jsライブラリーの[サンプルディレクトリ](https://github.com/auth0/auth0.js/tree/master/example)は、そのまま使えるアプリで、auth0.jsを手軽に試してみたいときに役立ちます。実行するには、以下の簡単な手順に従います。

1. [node](http://nodejs.org/)がインストールされていない場合は、ここでインストールします。
2. このプロジェクトのルートディレクトリで`npm install`を実行して、依存関係をダウンロードします。
3. 最後に、このプロジェクトのルートから`npm start`を実行し、ノードサーバー（通常は`http://localhost:3000/example`）で実行中のアプリに移動します。

## セットアップと初期化

それでは、プロジェクトにauth0.jsを統合しましょう。ここでは、[インストールの方法](#installation-options)、[auth0.jsの初期化](#initialization)、[サインアップ](#signup)、[ログイン](#login)、[ログアウト](#logout)などについて説明します。



### インストールオプション

プロジェクトでauth0.jsを使用するには、いくつかのオプションがあります。ニーズに合わせて以下のいずれかを選択します。

[npm](https://npmjs.org)または[yarn](https://yarnpkg.com)を使用してインストールする：



`auth0-js`モジュールをインストールしたら、それをすべての依存関係と一緒にバンドルするか、以下を使用してインポートする必要があります。



別の方法として、CDNを介してスクリプトをインクルードすることもできます。



### 初期化

Auth0アプリケーションの新しいインスタンスを次のように初期化します。



#### 使用可能なパラメーター

`webAuth`をインスタンス化する際に、`options`オブジェクトで渡さなければならない必須のパラメーターが2つあります。さらにオプションで渡せるパラメーターもあります。



クロックスキューの問題により、時折「`The token was issued in the future`（トークンが未来に発行された）」というエラーが発生することがあります。`leeway`パラメーターを使用して、IDトークンの有効期限までに数秒の余裕を持たせ、これを防ぎます。

##### Scope（スコープ）

auth0.js v9でのデフォルトの`スコープ`値は、`openid profile email`です。



## ログイン

ログインのメソッドは、アプリケーションで必要なauthの種類に従って選ぶことができます。

### webAuth.authorize()

`authorize()`メソッドは、ユニバーサルログイン経由でユーザーをログインさせる場合や、以下の例に示すようにソーシャル接続経由でログインさせる場合に使用できます。このメソッドは、Authentication APIの`/authorize`エンドポイントを呼び出し、`options`オブジェクト経由でさまざまなパラメーターを取ることができます。



ホスト型のログインでは、`/authorize()`メソッドを呼び出す必要があります。

`webAuth.authorize({
  //Any additional options can go here
});`

ソーシャルログインの場合、`connection`パラメーターを指定する必要があります。

`webAuth.authorize({
  connection: 'twitter'
});`

### webAuth.popup.authorize()

ポップアップ認証の場合は、`popup.authorize`メソッドを使用できます。ホスト型のログインページでは、ポップアップ認証は使用できません。通常、ポップアップ認証は、ページ全体のリダイレクト時に現在のステータスが失われないようにするために、シングルページアプリで使用します。

ポップアップを使ったデフォルト認可（ユーザーにAuth0のユニバーサルログインが表示されます）：



ポップアップを使用したソーシャルログインの場合は、`authorize`を使用します。



#### ポップアップ認証の結果の処理

ポップアップ認証を使用する場合、`redirectUri`を指定する必要があります。ここでは、宛先のページが`webAuth.popup.callback`メソッドを使用して認可の結果をコールバックに知らせます。簡単な実装は、以下のようになります：



このような最小限の機能性のみを備えた（この応答を処理するためだけにアプリケーション全体を再読み込みしない）ハンドラーが理想的です。
Dashboardのアプリケーション構成ページで、`redirectUri`をアプリケーションの**［Allowed Callback URLs（許可されているコールバックURL）］**リストに追加する必要があります。

### webAuth.login()



`login`メソッドでは、`/co/authenticate`を使用して、データベース接続の[クロスオリジン認証](/login/cross-origin-authentication)を行うことができます。



### webAuth.crossOriginVerification()

`crossOriginVerification()`メソッドは、ブラウザーでサードパーティのクッキーが無効になっている顧客にクロスオリジン認証を提供するために使用できます。この用途の詳細については、[クロスオリジン認証](/login/cross-origin-authentication)のドキュメントをお読みください。

### buildAuthorizeUrl(options)

`buildAuthorizeUrl`メソッドを使用して`/authorize` URLを構築し、新しいトランザクションを初期化することができます。ブラウザーベースの（パッシブ）認証を実装したいときは、このメソッドを使用します。



`state`パラメーターは、Auth0が返す不透明な値です。このメソッドは、CSRF攻撃を防ぐのに有効なため、`webAuth.authorize()`を呼び出す代わりに自分でURLにリダイレクトを行う場合には指定する必要があります。詳細については、「[Stateパラメーター](/attack-protection/state-parameters)」を参照してください。



## パスワードレスログイン

パスワードレス認証は、ユーザーがメールやテキストメッセージでワンタイムパスワードを受信することにより、ログインできるようにします。それには、パスワードレス処理を開始し、コード（またはリンク内のコード）を生成してユーザーに送信し、検証方法を介してユーザーの資格情報を承認する必要があります。このプロセスは、ログイン画面の形で実行し、ユーザーにメールアドレス（または電話番号）とそこに送信したばかりのコードの入力を求めます。コードではなく、パスワードレスのリンクを送信することもできます。ユーザーは、メールやテキストに含まれているリンクをクリックするだけでエンドポイントに到達し、このデータが同じ検証方法を使って自動的に検証されます（ユーザーが手動でコードを入力しない点のみが異なります）。

パスワードレスを使用するには、auth0.jsを`redirectUri`で初期化し、`responseType: 'token'`をに設定します。



### パスワードレス認証を開始する

auth0.jsを使用したパスワードレス認証の最初のステップは`passwordlessStart`メソッドです。このメソッドにはいくつかのパラメーターがあり、その`options`オブジェクト内で渡すことができます。



パスワードレスのトランザクションを開始するには、オプションの`phoneNumber`と`email`パラメーターのうち、必ず1つを送信する必要があることにご注意ください。



### パスワードレス認証を完了する

コードを送信する場合は、ユーザーにコードの入力を求める必要があります。コードを処理してユーザーを認証するには、`passwordlessLogin`メソッドを使用します。このメソッドには、その`options`オブジェクト内で送信できるパラメーターがいくつかあります。



`passwordlessStart`と同様に、パスワードレスのトランザクションを確認するためには、オプションの`phoneNumber`と`email`パラメーターのうち、必ず1つを送信する必要があります。

`passwordlessLogin`を使用するには、最初にWebAuthを初期化する際に、`redirectUri`と`responseType`のオプションを指定する必要があります。



## authResultを抽出してユーザー情報を取得する

認証が行われたら、`parseHash`メソッドを使用して、ユーザーがアプリケーションにリダイレクトされた際にURLのハッシュフラグメントを解析し、Auth0の認証応答の結果を抽出することができます。これは、状況に合わせて、（メインアプリケーションにリダイレクトする）コールバックページで、またはページ内で処理できます。

`parseHash`メソッドは、以下のパラメーターを含む`options`オブジェクトを受け付けます。



`parseHash`が返すauthResultオブジェクトの内容は、どの認証パラメーターが使われたかによって異なります。次のようなものが含まれます。





上に示すように、`client.userInfo`メソッドは、返された`accessToken`を渡して呼び出すことができます。その場合、`/userinfo`エンドポイントに要求が送られ、以下の例と同様の形式で、ユーザー情報が入った`user`オブジェクトが返されます。



この情報を使って、アプリケーションのニーズに合わせ、何らかの処理を行うことができます。1つの例として、Management APIを使ってユーザーの全プロファイル情報を取得する方法をご紹介します。

## nonceの使用

デフォルトでは（および`responseType`に`id_token`が含まれている場合）、`auth0.js`は`webAuth.authorize`を呼び出す時にランダムな`nonce`を生成し、これをローカルストレージに保存し、それを`webAuth.parseHash`で取り出します。このデフォルトの動作はほとんどのケースに適していますが、場合によっては開発者が`nonce`を管理しなければならないこともあります。
開発者が生成した`nonce`を使用する場合、`webAuth.authorize`と`webAuth.parseHash`の両方にオプションとしてこれを提供する必要があります。

`webAuth.authorize({nonce:'1234', responseType:'token id_token'});
webAuth.parseHash({nonce:'1234'}, callback);`

`webAuth.authorize`の代わりに`webAuth.checkSession`を呼び出す場合は、`checkSession`のオプションとしてカスタム`nonce`のみを指定する必要があります。



`webAuth.checkSession`メソッドは、返されたIDトークンの`nonce`クレームがそのオプションと同じであることを自動的に確認します。

## エラーコードと説明

Auth0.jsが埋め込みログインに使用される場合、`/co/authenticate`エンドポイントが使用されますが、以下のようなエラーが生じる可能性があります。



また、`error`または`error_description`プロパティがなくても、一般エラーの403が起きることもあります。応答のボディは、次のようになります：

`Origin https://test.app is not allowed.`（オリジンのhttps://test.appは許可されていません）

## ログアウト

ユーザーをログアウトさせるには、`logout()`メソッドを使用します。このメソッドは、次のようなパラメータを含むoptionsオブジェクトを受け取ります。

`clientID`パラメーターが含まれている場合、提供された`returnTo` URLは、[Auth0 Dashboard](%24%7Bmanage_url%7D)のアプリケーションの**［Allowed Logout URLs（許可されているログアウトURL）］**に記載されている必要があります。ただし、`clientID`パラメーターが含まれていない場合は、`returnTo`URLは[Auth0 dashboard](%24%7Bmanage_url%7D)のアカウントレベルの**［Allowed Logout URLs（許可されているログアウトURL）］**に記載されている必要があります。



## サインアップ

ユーザーのサインアップには、`signup`メソッドを使用します。このメソッドは、次のようなパラメータを含むoptionsオブジェクトを受け取ります。



サインアップはデータベース接続用です。`signup`メソッドの例とフォームのサンプルコードをこちらに示します。



## checkSessionを使った新しいトークンの取得

`checkSession`メソッドを使用すると、すでにドメインに対するAuth0認証が済んでいるユーザーに対して、新しいトークンを取得することができます。このメソッドは、通常であれば、`authorize`に送信される有効なOAuth2パラメーターをすべて受け入れます。省略した場合は、Auth0の初期化時に指定されたパラメーターが使用されます。

`checkSession`への呼び出しは、`webAuth`が初期化された際にオーディエンスとして指定されたAPIの新しいトークンを取得するために使用することができます。



`authResult`の形式については、「[authResultを抽出してユーザー情報を取得する](#extract-the-authresult-and-get-user-info)」を参照してください。

また、`audience`と`scope`を指定することによって、`webAuth`の初期化の際に使用されたAPIとは異なるAPIのトークンを取得することもできます。



`checkSession()`では、設定した[ルール](/rules)がすべてトリガーされるため、使用する前に[Dashboard](%24%7Bmanage_url%7D/#/rules)でルールを確認してください。

`/authorize`への実際のリダイレクトはiframe内で起こるため、アプリケーションの再読み込みやアプリケーションからのリダイレクトは行われません。

ただし、ブラウザーではサードパーティのクッキーが有効になっている**必要があります**。有効になっていなければ、**checkSession()**は現在のユーザーのセッションにアクセスできません（ユーザーに何も表示せずに新しいトークンを取得することが不可能になります）。ユーザーが[SafariのITPを有効](/troubleshoot/troubleshoot-authentication/renew-tokens-when-using-safari)にしている場合にも同様のことが起こります。

[Dashboard](%24%7Bmanage_url%7D)のアプリケーションの**［Settings（設定）］**の下にあるAuth0アプリケーションの**［Allowed Web Origins（許可されたWebオリジン）］**リストに、認可要求の送信元となるURLを追加することを忘れないでください。



### checkSession()でのポーリング



## パスワードのリセット要求

パスワードリセット機能を設定しようとする場合は、`changePassword`メソッドを使用し、optionsオブジェクトを渡します。このオブジェクトには、connectionパラメーターとemailパラメーターを含めます。



すると、ユーザーに、パスワードリセット用のリンクを含んだメールが届きます。

## ユーザー管理

Management APIの機能を使うと、異なるプロバイダーからの個別のユーザーアカウントをリンクしたり、リンクを解除したりして、1つのプロファイルにまとめることができます（詳細については「[ユーザーアカウントのリンク](/users/user-account-linking)」を参照してください）。また、ユーザーメタデータを更新することもできます。

まず、Management APIの呼び出しに使用可能なアクセストークンを取得する必要があります。auth0.jsを初期化する際に`https://${account.namespace}/api/v2/`を指定することで、認証フローの一部としてアクセストークンを取得することができます。

[カスタムドメイン](/custom-domains)を使用している場合、Management API呼び出しで使用するために、`webAuth`の新しいインスタンスを作成する必要があります。この場合、カスタムドメインではなく、Auth0のドメインを使用する必要があります。これはManagement API呼び出しがAuth0のドメインでのみ動作するためです。



また、`checkSession()`を使用してこれを行うこともできます。



必要なスコープを指定しなければなりません。以下のスコープを要求することができます。

* `read:current_user`
* `update:current_user_identities`
* `create:current_user_metadata`
* `update:current_user_metadata`
* `delete:current_user_metadata`
* `create:current_user_device_credentials`
* `delete:current_user_device_credentials`

アクセストークンを取得したら、そのアカウントのAuth0ドメインとアクセストークンを渡して新しい`auth0.Management`インスタンスを作成することができます。



### ユーザープロファイルの取得

ユーザープロファイルデータを取得するには、`getUser()`メソッドを使用します。このメソッドには、`userId`とコールバックをパラメーターとして渡します。メソッドはユーザープロファイルを返します。ここで必要とされる`userID`は、`client.userInfo`メソッドから取得したものと同じであることにご注意ください。

`auth0Manage.getUser(userId, cb);`

### ユーザープロファイルの更新

ユーザーメタデータを更新する際は、まず`userMetadata`オブジェクトを作成し、その後`patchUserMetadata`メソッドを呼び出して、作成した`userMetadata`オブジェクトとユーザーIDを渡す必要があります。このオブジェクトの値は、同じキーを持つ既存の値を上書きするか、ユーザーメタデータに値がない場合は新しい値を追加します。ユーザーメタデータの詳細については、[メタデータ](/users/metadata)のドキュメントを参照してください。

`auth0Manage.patchUserMetadata(userId, userMetadata, cb);`

### ユーザーのリンク

ユーザーアカウントをリンクすると、ユーザーがどのアカウントからでも認証できるようになり、どのアカウントを使用してログインしても同じプロファイルが引き出されます。Auth0では、デフォルトですべてのアカウントが個別のプロファイルとして扱われるため、ユーザーのアカウントをリンクしたい場合は以下の手順が必要です。

`linkUser`メソッドは、2つのパラメーターを受け取ります。1つはプライマリーアカウントの`userId`、もう1つはセカンダリーアカウントのIDトークン（このIDでログイン後に取得したトークン）です。このユーザーIDは、プライマリーユーザーアカウントの一意の識別子です。このメソッドを使用する際は、IDにプロバイダーのプレフィックスを付けて渡す必要があります（例：`auth0|1234567890`や`facebook|1234567890`）。詳細については、「[ユーザーアカウントのリンク](/users/concepts/overview-user-account-linking)」を参照してください。

`auth0Manage.linkUser(userId, secondaryUserToken, cb);`

アカウントをリンクすると、セカンダリーアカウントは、ユーザーデータベースの中で別途のアカウントとして存在しなくなり、プライマリーアカウントの一部としてしかアクセスできなくなります。

アカウントがリンクされている場合、セカンダリ―アカウントのメタデータはプライマリーアカウントのメタデータと**統合されません**。また、リンクが解除されると、セカンダリーアカウントが再び独立した際にプライマリーアカウントのメタデータは保持されません。