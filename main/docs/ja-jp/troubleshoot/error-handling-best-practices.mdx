---
description: Error conditions returned from API calls must be handled and processed
  in an appropriate manner. Failure to do so can lead to unhandled exception situations,
  resulting in premature termination of pipeline execution and ultimately in an authentication
  error being returned.
og:description: Learn about best practices for error handling.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: エラー処理のベストプラクティス
og:url: https://auth0.com/docs/
title: エラー処理のベストプラクティス
twitter:description: Learn about best practices for error handling.
twitter:title: エラー処理のベストプラクティス
---

## エラーログを外部サービスに送信する

We recommend sending error event logs to an external service to provide better visibility and diagnosis of anomalous operation. To retain and analyze your log events past the log retention period offered for your subscription plan, [use Auth0 log streaming](/docs/customize/log-streams). You can use services like DataDog and AWS EventBridge. We also offer the ability to send logs to an external service in our [Log Streaming](https://marketplace.auth0.com/features/log-streaming) section in Auth0 Marketplace.

## ルールでエラーオブジェクトを使用する

There are time constraints regarding how much time a rule has to execute. To learn more, read [Custom Database Action Script Execution Best Practices](/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution). If recovery from an error condition is not possible (or probable) within this time period, then an error condition should be explicitly returned; this is as simple as completing rule execution by returning an instance of a Node `Error` object, as in:

`return callback(new Error('some description'));`

To learn more, read [Class: Error on nodejs.org](https://nodejs.org/api/errors.html#errors_class_error).

または、Auth0固有の`UnauthorizedError`のインスタンスを返すこともできます。これにより、認証を開始したアプリケーション（つまり、`/authorize`エンドポイントへのリダイレクトを開始したアプリケーション）に、指定されたエラーの説明を含む`不正な`エラー状態が返されます。これにより、アプリケーションは条件付き再試行機能を提供でき、特定の条件に基づいてアクセスを拒否するルールを実装できます。

`return callback(new UnauthorizedError('some description'), user, context);`

## 意味のあるエラーコードの説明を使用する

例外処理

`'[00043] - my specific error description'`)

## キャッチされないJavaScript例外などの予期しないエラー条件により、パイプラインの実行が途中で終了し、最終的に認証エラーが返される可能性があります。

非同期操作を伴う状況では、`Promise`オブジェクト処理を使用するときに`catch`ハンドラーを使用する必要があります。`Promise`オブジェクト処理は、非同期操作中のエラー処理にも効果的です。以下に示すように、`Promise`オブジェクトを使用して、たとえば同期関数呼び出しをラップすると、Promiseチェーンなどを使用してカスケード エラー処理を簡単に実装できます。Promiseオブジェクトの詳細については、[MDN Web DocsのPromise]()を参照してください。Promiseチェーンの詳細については、[Error Handling with Promises on javascript.infoのPromiseによるエラー処理]()をお読みください。

For situations involving asynchronous operations, you must use a `catch` handler when using `Promise` object processing. `Promise` object processing can also be effective for error handling during non-asynchronous operations. As illustrated below, a `Promise` object can be used to wrap, say, a synchronous function call, making it easier to implement cascaded error handling via use of promise chaining and the like. To learn more about the Promise object, read [Promise in MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). To learn more about promise chaining, read [Error Handling with Promises on javascript.info](https://javascript.info/promise-error-handling).

```js lines
return new Promise(function(resolve, reject) {
    jwt.verify(
      token,
      secret,{
      clockTolerance: 5},
      function(err, decoded) {
        if (err) {
          reject(err);
        } else {
          resolve(decoded);
      }
    });
  });
```
Alternatively, you can use `try...catch` processing to handle JavaScript exceptions that occur during synchronous operation. To learn more, read [`try...catch` in MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch).Setting up this type of exception handling can often incur performance costs, so use it sparingly; rule performance should be as optimal as possible. A more pragmatic approach is to implement processing that prevents exceptions from occurring rather than handling them once they have occurred. To learn more about best practices, see [Performance Best Practices](/docs/troubleshoot/performance-best-practices).

## 初期化されていないオブジェクトを使用すると、例外が発生する可能性があります。オブジェクトの存在が疑われる場合は、宣言の一部として初期化を含めることをお勧めします。例：

ルールでは、例外が発生しないようにするための手順を実行することがベストプラクティスであり、通常、例外処理を実装するよりもパフォーマンスとリソースの使用の点でコストが低くなります。

`user.user_metadata = user.user_metadata || {}`)

In a rule, taking steps to prevent an exception from occurring in the first place is a best practice and is typically less costly in terms of performance and resource usage than implementing exception handling.