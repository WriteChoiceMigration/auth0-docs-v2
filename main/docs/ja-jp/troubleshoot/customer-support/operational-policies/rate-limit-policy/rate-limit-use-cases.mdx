---
og:description: How to determine if you are being rate limited
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: レート制限のユースケース
og:url: https://auth0.com/docs/
permalink: rate-limit-use-cases
title: レート制限のユースケース
twitter:description: How to determine if you are being rate limited
twitter:title: レート制限のユースケース
---

## テナントへの要求がレート制限を受けていることを確認する

顧客の製品がAuth0のレート制限を受けているかを確認するには、いくつかの方法があります。可能性のあるレート制限の原因については、以下を参照してください。

### テナントログ

By subscribing to different tenant logs, you can track issues related to request volumes. To understand how tenant and operations event logs work in Auth0, read [Logs](/docs/deploy-monitor/logs).

#### api_limit

The `api_limit` event is triggered immediately after a rate limit is exceeded for the global rate limit bucket for the Authentication or <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip>. If the number of request tokens utilized remains above 80% after one minute for the same rate limit bucket, a second warning log is generated. If a rate limit is exceeded for a different rate limit bucket, a new `api_limit` event is generated. This helps customers identify which rate limit configuration their API calls are triggering, which is a critical first step in diagnosing the root cause.

#### appi（パブリックパフォーマンスバーストのみ）

API応答

#### Auth0のAPI応答は、[HTTP 429 (Too Many Requests)]()応答に超過したレート制限を含めて送信します。これによって、レート制限の適用をリアルタイムで観察することができます。ただし、これはカスタムで構築された顧客のアプリケーションがAuth0 APIと直接やり取りする場合にのみ役立ちます。

SDKエラーの処理

### SDKを使用している場合には、[Management APIのSDKライブラリー]()のエラーページを参照してください。

Auth0 SDKを使用している場合には、[Management APIのSDKライブラリー]()のエラーページを参照してください。 deliver [HTTP 429 (Too Many Requests)](http://tools.ietf.org/html/rfc6585#section-4) responses with the exceeded rate limit. This enables customers to observe rate limit enforcement in real time. However, this is only useful for custom-built customer applications interacting directly with the Auth0 API.

### エラーページ応答は、エンドユーザーにHTMLコンテンツを表示するエンドポイントに対して送信されます。テナントに（Auth0がホストする）汎用ページの使用が構成されている場合には、応答制限が超過すると、Auth0は予期されるページではなく、エラーページを表示します。  テナントに[カスタムのエラーページ](/brand-and-customize/custom-error-pages)の使用が構成されている場合には、クエリ文字列パラメーターの`error_description`に関連エラーを含めて、エラーページのURLにユーザーがリダイレクトされます。  詳細については、[影響を受けるエンドポイント](/troubleshoot/customer-support/operational-policies/rate-limit-policy/authentication-api-endpoint-rate-limits#affected-endpoints)と[JSONエラー](/troubleshoot/customer-support/operational-policies/rate-limit-policy/authentication-api-endpoint-rate-limits#json-error)の説明を参照してください。

If you are using an SDK, refer to the [Management API SDK libraries](/docs/libraries#mgmt) error pages.

### テナント要求がレート制限を受けていると思われ、その理由を知るのに手助けが必要な場合には、[サポートセンター]()を通してリクエストしてください。  リクエストには、問題を示している生のログを含めてください。

The error page response is sent for endpoints that render HTML content to the end user. If your tenant is configured to use generic (Auth0 hosted) pages, Auth0 renders the error page instead of the expected content when you exceed the response limit.  If your tenant is configured to use [custom error pages](/docs/customize/login-pages/custom-error-pages), the user is redirected to the custom error page URL with the relevant error in the `error_description` query string parameter.  For more information, see [Affected endpoints](/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/authentication-api-endpoint-rate-limits#affected-endpoints) and the [JSON Error](/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/authentication-api-endpoint-rate-limits#json-error) descriptions.

## Auth0は、レート制限ポリシーが構成されているエンドポイントからHTTP応答ヘッダーを使用して、レート制限の現在のステータスについて最新情報を報告します。このステータスでは以下が通知されます。

If you believe tenant requests are rate limited and need assistance to understand why, open a request via the [Support Center](http://support.auth0.com).  As part of your request, please include the full raw log where the issue was seen.

## `x-ratelimit-remaining`：バケットに要求数が補充されるまでの残りの要求数です。

`x-ratelimit-reset`：バケットに要求数が補充される予測時間を秒単位で表した[UNIXタイムスタンプ]()です。

* APIには以下のレート制限があります。
* バースト制限： `1000`
* `x-ratelimit-reset`: [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time), in seconds, of the expected time when additional requests will be added to the bucket.

この情報から以下が分かります。

持続的レート制限は固定ウィンドウで`100RPS`です。

* 固定ウィンドウのため、要求のバケットは毎秒補充されます。
* API応答では以下のXヘッダーを受け取ります。

テナントがそのAPIに対する要求数1000中の950をすでに使用し、要求数が補充されるまでに残っている要求数は50のみである

* 新しい要求数が`1675452600`秒後（2023年2月3日7:30:00 PM UTC）に補充される
* そのときに新たに1つの要求が追加される

以下のことが分かります。

* テナントがそのAPIに対する要求数1000中の950をすでに使用し、要求数が補充されるまでに残っている要求数は50のみである
* 新しい要求数が`1675452600`秒後（2023年2月3日7:30:00 PM UTC）に補充される
* そのときに新たに1つの要求が追加される

このため、上記よりも速いレートで要求を行っていると、レート制限を受けることになります。  どのくらい早い時期にレート制限を受けるのかは、持続制限をどのくらい超過しているのかとバースト制限に依存します。

* レート制限を受ける仕組みの例
* RPSの例
* Auth0が`/ratelimitexample`という新しいAPIの提供を開始し、以下のレート制限があるとします。

Therefore, if you are making requests at a rate greater than what is described above, then a rate limitation is expected.  How soon you will be rate limited depends on the burst limit and to what extent you are exceeding the sustained limit.

## 持続的レート制限：10RPS。

### APIは5つの要求トークンから始まり、それが上限で、これはバースト制限と同じです。

固定ウィンドウを使用して、10個のトークンを保持したバケットが1秒ごとに補充されます。 新しいトークンがバケットに追加され、各秒の「頭」でバケットを補充します。

* レート制限のシナリオ例
* このシナリオでは以下が起きます。

T0 - T+1分：  エンドユーザーが最初の1分で6つの要求を行います。 バースト制限と同等の5つの要求は`200`応答を受信します。  6つ目の要求は、要求トークンが残っていないため`429`エラーを受信します。

* T1秒 - T2秒：  固定ウィンドウのアルゴリズムにより要求トークンのバケットが満たされます。その結果、7つ目から11つ目の要求は成功し、12つ目の要求でバケットが空になり、`429`エラーとなります。
* T2秒 - T3秒：  再びトークンバケットが補充されて、次の要求（13）で`200`応答を受信します。

 その他のシナリオ

<Frame>![](/images/cdy7uua7fh8z/30m5xST81Db6mROVGCV5Bj/34d9638eb7467f02c2d0ecbe87ff0fd8/Examples_of_how_rate_limits_are_enforced_-_Page_1.png)</Frame>

Auth0は時には1つのAPIに2つのレート制限を割り当てることがあります。  これは、サービスの需要に合わせて、バースト制限と持続的レート制限の構成をさらにカスタマイズするためです。  その結果、最初のレート制限が実施されるバースト制限になり、2番目のレート制限が実施される持続的レート制限になります。  このシナリオでは、Auth0は実際のバースト制限と持続的レート制限ではなく、実施されるバースト制限と持続的レート制限のみを公開します。

* Auth0が`/ratelimitexample2`という新しいAPIの提供を開始し、以下のレート制限があるとします。
* バースト制限：  5件の要求
* 持続的レート制限：  6RPM。

### APIは5つの要求トークンから始まり、バースト制限と同じです。

固定ウィンドウを使用して、6個のトークンを保持したバケットが1分ごとに補充されます。 新しいトークンがバケットに追加され、毎分の「頭」でバケットを補充します。

* レート制限のシナリオ例
* このシナリオでは以下が起きます。

T0 - T+1分：  エンドユーザーが最初の1分で6つの要求を行います。 バースト制限と同等の5つの要求は`200`応答を受信します。  6つ目の要求は、要求トークンが残っていないため`429`エラーを受信します。

* T+1分 - T+2分：  固定ウィンドウのアルゴリズムにより要求トークンのバケットが満たされます。その結果、7つ目から11つ目の要求は成功し、12つ目の要求でバケットが空になり`429`エラーとなります。
* T+2分：再びトークンバケットが補充されて、次の要求（13）で`200`応答を受信します。

その他のシナリオ

<Frame>![](/images/cdy7uua7fh8z/PhtwGBwS9PfEpNQbPeA1o/dc2b05c72ef960a19958dbafa0295e70/Examples_of_how_rate_limits_are_enforced_-_Page_1__1_.png)</Frame>

Auth0は時には1つのAPIに2つのレート制限を割り当てることがあります。  これは、サービスの需要に合わせて、バースト制限と持続的レート制限の構成をさらにカスタマイズするためです。  その結果、最初のレート制限が実施されるバースト制限になり、2番目のレート制限が実施される持続的レート制限になります。  このシナリオでは、Auth0は実際のバースト制限と持続的レート制限ではなく、実施されるバースト制限と持続的レート制限のみを公開します。

* エンドユーザーのログインとサインアップAPIの使用
* 認証フローには、ログイン、サインアップ、パスワード変更などいくつかがあります。このうち最も一般的なものがログインで、その次がサインアップです。
* エンドユーザーがログインすると、Authentication APIエンドポイントへの複数のAPI呼び出しが始まります。これによって、エンドユーザーに認可トークンの受信が許可されているかを判断し、要求したアプリケーションにアクセスします。

### API呼び出しを行う正確な数は、以下のいくつかの構成に応じて異なります。

認証エクスペリエンス（新しいユニバーサルログイン、クラシックログインなど）

## 認証フロー（ログイン、サインアップ、パスワード変更など）

認証フロータイプ（ユーザー名/パスワードを介したログイン、ソーシャルログインを介したログイン、既存の認証トークンがすでに存在するときのログインなど）

以下に、よくある顧客の構成とAPIの使用に対する影響についていくつか説明します。

ユニバーサルログイン

* Authentication Experience (e.g., New <Tooltip tip="Universal Login: Your application redirects to Universal Login, hosted on Auth0's Authorization Server, to verify a user's identity." cta="View Glossary" href="/docs/glossary?term=Universal+Login">Universal Login</Tooltip> or Classic Login)
* Authentication Flow (e.g., Login, Signup, or Change Password)
* Authentication Flow Type (e.g., Login via Username / Password; Login via Social Login; Login when an existing Authentication Token already exists)

Below, we describe some common customer configurations, and their impact on API Usage.

### Universal Login

[Auth0 Universal Login](/docs/authenticate/login/auth0-universal-login) provides the essential feature of an <Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/docs/glossary?term=authorization+server">authorization server</Tooltip>: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process.

<table class="table"><thead>
<tr>
<th>Authentication flow</th>
<th>Flow type</th>
<th>Requests to Authentication API endpoints</th>
</tr>
</thead>
<tbody>
<tr>
<td>Login</td>
<td>Username/Password Challenge*</td>
<td>5</td>
</tr>
<tr>
<td>Login</td>
<td>3rd Party Identity Provider – e.g., Social or Work Login</td>
<td>6</td>
</tr>
<tr>
<td>Login</td>
<td>Auth0 Authentication Session Exists</td>
<td>1</td>
</tr>
<tr>
<td>Signup</td>
<td>via Username/Password</td>
<td>6</td>
</tr>
</tbody>
</table>

#### Modifiers

Certain authentication configurations modify the base request count. These adjustments depend on additional security measures or authentication flows:

<table class="table"><thead>
<tr>
<th><strong>Modifier</strong></th>
<th><strong>Description</strong></th>
<th><strong>Additional Requests</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ID First</strong></td>
<td>Identifies the user before requesting credentials.</td>
<td>+2</td>
</tr>
<tr>
<td><strong>MFA</strong></td>
<td>Adds Multi-Factor Authentication.</td>
<td>+2 per factor</td>
</tr>
<tr>
<td><strong>OTP</strong></td>
<td>One-time password for Authentication</td>
<td>+2</td>
</tr>
<tr>
<td><strong>Enterprise Login</strong></td>
<td>Authentication through an enterprise connection (e.g., SAML, OIDC, LDAP).</td>
<td>+1</td>
</tr>
<tr>
<td><strong>Client Credentials</strong></td>
<td>Used for machine-to-machine authentication. Applies universally, even if actions are used.</td>
<td>+1</td>
</tr>
</tbody>
</table>

\*Anything used in combination adds to the overall requests.

### Classic login

[Classic Login](/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience) is an Auth0-hosted login experience that relies on JavaScript for customization. Implementing Classic Login is less complex than embedding the authentication process directly in your app, and can help prevent the dangers of cross-origin authentication.

<table class="table"><thead>
<tr>
<th>Authentication flow</th>
<th>Flow type</th>
<th>Requests</th>
</tr>
</thead>
<tbody>
<tr>
<td>Login</td>
<td>Username/password challenge</td>
<td>8</td>
</tr>
<tr>
<td>Login</td>
<td>3rd Party Identity Provider – e.g., Social or Work Login</td>
<td>8</td>
</tr>
<tr>
<td>Login</td>
<td>Auth0 authentication session exists</td>
<td>2</td>
</tr>
<tr>
<td>Signup</td>
<td>Username/password</td>
<td>8</td>
</tr>
</tbody>
</table>

<Warning>

Customers configuring Custom Databases should add two (2) additional authentication API calls to each authentication flow described above. For more details, see [Custom Database Connections](/docs/authenticate/database-connections/custom-db).

</Warning>

#### Modifiers

The following factors increase request counts for Classic Login:

<table class="table"><thead>
<tr>
<th><strong>Modifier</strong></th>
<th><strong>Description</strong></th>
<th><strong>Additional Requests</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SMS Authentication Only</strong></td>
<td>When using SMS as the primary authentication method.</td>
<td>+7</td>
</tr>
<tr>
<td><strong>Native Social Login</strong></td>
<td>Login using a native social provider (e.g., Google, Facebook).</td>
<td>+1</td>
</tr>
<tr>
<td><strong>Redirects</strong></td>
<td>Additional redirects during authentication increase request count.</td>
<td>+1</td>
</tr>
</tbody>
</table>