---
og:description: Describes how to migrate from legacy authentication flows.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: レガシー認証フローからの移行
og:url: https://auth0.com/docs/
permalink: migrate-from-legacy-auth-flows
title: レガシー認証フローからの移行
twitter:description: Describes how to migrate from legacy authentication flows.
twitter:title: レガシー認証フローからの移行
---

バージョン11より前のLock、およびバージョン9より前のAuth0.jsを使用しているときは、廃止されるレガシー認証フローを使用できました。Auth0は、古いバージョンのAuth0.jsおよびLockからコードを新しいOIDC準拠のAPIに移行することをお勧めしています。

## トークンを更新する

Legacy applications used <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+Tokens">Refresh Tokens</Tooltip> and the `refreshToken()` function as a way to get new tokens upon expiration (an example of this is below).

In auth0.js v9 and Lock 11 you need to use [Silent Authentication](/docs/authenticate/login/configure-silent-authentication) and `checkSession()`(an example of this is below).

## APIを呼び出す

Legacy applications used an <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+token">ID token</Tooltip> to invoke APIs. This is a bad practice, and we recommend that you only use <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip>.

APIを呼び出すには、auth0.jsまたはLockを初期化するときに、`audience`パラメーターとしてAPI識別子を指定する必要があります。

If you specify an <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip>, then the OIDC flow will be triggered and the user profile data returned by Auth0 in ID tokens or from `/userinfo` will be OIDC conformant. If your application is using any non-standard claim from the user profile, it will break.

SPAからAPIの呼び出し方法の詳細については、SPA Quickstartsの「**APIを呼び出す**」のセクションをご覧ください。また、アクセストークンを使用するために、バックエンドAPI実装を移行する必要があります。方法については、API Quickstartsをご覧ください。

## ユーザープロファイル

IDトークンおよび`/userinfo`エンドポイントが完全なユーザープロファイルを含めることを可能にするレガシーアプリケーションフローは、廃止されます。新しいOIDC準拠のAPIへの移行を完了した後、`Legacy User Profile`トグルがオフになっていることを確認してください。

レガシー認証フローを使用する場合、以下に示すように、ユーザープロファイル全体がIDトークンで、または`/userinfo`から返されます。

The new user profile conforms to the OIDC specification, which allows for certain [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) to be available in the response.

コンテンツは、要求されるスコープによって異なります。Auth0.jsまたはLockを構成するときに、要求するスコープを調整する必要があります。そうすることで、必要なクレームすべてがアプリケーションで利用可能になります。カスタムクレームを追加して、必要なデータを返すことができます（例：ユーザーメタデータ）。

Another approach to get the full user profile is to use the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> (instead of getting the profile through the authentication flow) as described in the next section.

## Management APIを使用したユーザープロファイル

レガシーフローで、Management APIは、IDトークンでの認証をサポートしていました。この方法は廃止されているため、アクセストークンで呼び出す必要があります。

To get an Access Token, you need to ask Auth0 for one using the `https://{yourDomain}/api/v2/` audience. Auth0 does not currently support specifying two audiences when authenticating, so you will need to still use your application's API audience when initializing Lock or auth0.js. Once the user is authenticated, you can use `checkSession` to retrieve a Management API `access_token`, and then call the `getUser()` endpoint.

以下のスコープを要求することができます。

* `read:current_user`
* `update:current_user_identities`
* `create:current_user_metadata`
* `update:current_user_metadata`
* `delete:current_user_metadata`
* `create:current_user_device_credentials`
* `delete:current_user_device_credentials`

You could get a `consent_required` error when calling `checkSession()`. If you do, make sure you have **Allow Skipping User Consent** enabled for the Management API and that you are not running from localhost.