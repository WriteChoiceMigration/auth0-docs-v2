---
og:description: Describes how to migrate from using ID tokens to access tokens when
  linking user accounts.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: アカウントリンクに向けてアクセストークンに移行する
og:url: https://auth0.com/docs/
permalink: link-user-accounts-with-access-tokens-migration
title: アカウントリンクに向けてアクセストークンに移行する
twitter:description: Describes how to migrate from using ID tokens to access tokens
  when linking user accounts.
twitter:title: アカウントリンクに向けてアクセストークンに移行する
---

以前は、一部のケースで、IDトークンを使ってユーザーアカウントのリンクやリンク解除ができました。この機能は、廃止されます。今後は、すべてのケースでアクセストークンを使う必要があります。



## 影響のある機能

アカウントリンクにおける変更点は以下のとおりです：

* `Authorization`ヘッダーでIDトークンを使用できなくなりました。代わりにアクセストークンを使用する必要があります。
* `Authorization`ヘッダーでアクセストークンを使用し、付与されたアクセス許可が`update:users`の場合、要求のボディにはセカンダリアカウントの`user_id`またはIDトークンのいずれかを送信できます。
* `Authorization`ヘッダーでアクセストークンを使用し、付与されたアクセス許可が`update:current_user_metadata`の場合、要求のボディにはセカンダリアカウントのIDトークンのみ送信できます。
* 要求の本文でセカンダリアカウントのIDトークンを送信する場合（上記2つのポイントで紹介したユースケース）、以下のような条件があります。

* IDトークンは`RS256`を使用して署名される必要があります（この値は、**［Dashboard］>［Clients（クライアント）］>［Client Settings（クライアントの設定）］>［Advanced Settings（高度な設定）］>［OAuth］**から設定できます。
* IDトークンの`aud`クレームは、クライアントを特定し、アクセストークンの`azp`クレームと同じ値でなければいけません。
* `Authorization`ヘッダーでアカウントのリンクを解除する目的です。代わりにアクセストークンを使用しなければなりません。

アカウントをリンクする方法、リンクを解除する方法はいくつかあります。次のリストで、ユースケースと変更が及ぼす影響を確認してください。



## アクション

[IDエンドポイント](/api/management/v2/#!/Users/post_identities)にリンクするアカウントへのすべての呼び出しを確認し、上記の脆弱なフローを利用する呼び出しを更新します。呼び出しを更新する方法には、次のようなものがあります。

* **クライアント側/ユーザー開始のリンクシナリオ:** クライアント側のリンク シナリオの場合、`update:current_user_identities`スコープのアクセス トークンを使用してIdentitiesエンドポイントへの呼び出しを行い、ペイロード（`link_with`）でセカンダリ アカウントの ID トークンを提供します。IDトークンは、OAuth/OIDC準拠のフローを通じて取得しなければなりません。
* **サーバー側リンクシナリオ**:** **サーバー側リンクシナリオの場合は、`update:users`スコープのアクセス トークンを使用してIdentitiesエンドポイントへの呼び出しを行い、ペイロードでセカンダリ アカウントの`user_id`を指定します。

詳細については、[ユーザーアカウントのリンク](/users/user-account-linking/link-user-accounts)を参照してください。

### ユーザーアカウントをリンクする

ユーザーアカウントをリンクするには、Management APIの[ユーザーアカウントのリンクエンドポイント](https://auth0.com/docs//api/management/v2#!/Users/post_identities)を呼び出すか、[Auth0.jsライブラリ](/libraries/auth0js)を使用します。

#### Management APIで現在のユーザーアカウントをリンクする

一般的なユースケースは、ログインしたユーザーに、アプリを使ってのアカウントのリンクを許可する、というものです。

非推奨になる前は、プライマリユーザーのIDトークンまたはアクセストークン（`update:current_user_identities`スコープを含む) を使用してManagement APIで認証し、[ユーザーアカウントのリンクエンドポイント](https://auth0.com/docs/api/management/v2#!/Users/post_identities)を使用できました。

次に、アクセストークン（`update:current_user_identities`スコープを含む）を取得し、それを使用してAPIで認証し、ユーザーアカウントのリンクエンドポイントを使用する必要があります。ペイロードは、セカンダリユーザーのIDトークンでなければなりません。

1. 次の例に示すように、`update:current_user_identities`スコープでアクセストークンを取得します。この例では[暗黙的フロー](/login/flows/implicit-flow-with-form-post)を使用していますが、任意の種類のアプリケーションの[アクセストークンを取得](/security/tokens/access-tokens/get-access-tokens)できます。
2. 以前の、IDトークンを使う方法では、コードは次のようになります： 
アクセストークンを使う新しい方法だと、コードは次のようになります：
3. Management APIにアクセスできるアクセストークンを取得するには以下を行います。

1. `audience`を`https://${account.namespace}/api/v2/`に設定する
2. `スコープ``${scope}`を要求する
3. `response_type`を`id_token token`に設定し、Auth0がIDトークンとアクセストークンの両方を送るようにするアクセストークンをデコードすると、次のような内容になります：`aud`はテナントのAPI URI、`スコープ`は`${scope}`、`sub`はログインユーザーのユーザーIDに設定されています。
4. 次のような条件があります。

1. セカンダリアカウントのIDトークンは`RS256`で署名されている必要があります。
2. セカンダリアカウントのIDトークンの`aud`クレームはクライアントを識別し、要求の作成に使用されたアクセス トークンの`azp`クレームと同じ値を保持する必要があります。
5. アクセストークンを取得したら、それを使ってユーザーアカウントをリンクします。この部分は同じで、要求のうち、`Bearer`トークンとして使用する値を除き変更はありません。応答も同じです。

#### auth0.jsを使って現在のユーザーアカウントをリンクする

[auth0.jsライブラリ](/libraries/auth0js)を使用してManagement APIにアクセスし、アカウントをリンクする場合は、おそらくユーザーのプライマリ ID の ID トークンを使用して`auth0.Management`をインスタンス化し、それを使用してアカウントをリンクします。

1. `update:current_user_identities`スコープのアクセス トークンを取得し、このトークンを使用して `auth0.Management`をインスタンス化します。`linkUser`への最後の呼び出しは変わりません。
2. 以前の、IDトークンを使う方法では、コードは次のようになります： 
アクセストークンを使う新しい方法だと、コードは次のようになります：

1. 応答でIDトークンとアクセストークンの両方を求めます（`responseType: `token id_token``）。
2. Management APIを意図したトークンのオーディエンスとして設定します（`audience: `https://{yourDomain}/api/v2/``）。
3. 必要な許可を要求します（`scope: `update:current_user_identities``）。
4. アクセストークンを使ってManagement APIで認証します。

#### Management APIで任意のユーザーアカウントをリンクする

`update:users`スコープを含むアカウント リンク用のアクセス トークンを取得し、要求でセカンダリーアカウントの `user_id`と`プロバイダー`を送信する場合は、何も変更する必要はありません。

ただ、ここで紹介している新しいメソッドはその代わりになります。APIでの認証には引き続き`update:users`スコープを含むアクセストークンを使用しますが、要求のペイロードでセカンダリのアカウントIDトークンを（`user_id`および`プロバイダー`の代わりに）送信できます。



次のような条件があります。

* セカンダリアカウントのIDトークンは`RS256`で署名されている必要があります。
* セカンダリアカウントのIDトークンの`aud`クレームはクライアントを識別し、要求の作成に使用されたアクセス トークンの`azp`クレームと同じ値を保持する必要があります。

### ユーザーアカウントのリンクを解除する

IDトークンを使ってアカウントのリンクを解除するには、アクセストークンを使うようコードを更新しなければなりません。

1. まず、`update:current_user_identities`スコープのアクセストークンを取得する必要があります。
2. 以前の、IDトークンを使う方法では、コードは次のようになります： 
アクセストークンを使う新しい方法だと、コードは次のようになります：
3. Management APIにアクセスできるアクセストークンを取得するには以下を行います。

1. `audience`を`https://${account.namespace}/api/v2/`に設定する
2. `スコープ``${scope}`を要求する
3. `response_type`を`id_token token`に設定し、Auth0がIDトークンとアクセストークンの両方を送るようにするアクセストークンをデコードすると、次のような内容になります：`aud`はテナントのAPI URI、`スコープ`は`update:current_user_identities`、`sub`はログインユーザーのユーザーIDに設定されています。` `` `
4. アクセストークンを取得したら、`Authorization`ヘッダーでそれを使用して、Management API の[ユーザーIDエンドポイントのリンク解除](https://auth0.com/docs/api/management/v2#!/Users/delete_user_identity_by_user_id)を呼び出すことができます。
5. 以前の方法では、呼び出しは次のようになります：
新しい方法では、呼び出しは次のようになります：

## セキュリティに関する考慮事項

ある特定のアカウントリンクフローに、特殊な状況において悪用される可能性のある弱点が見つかりました。実際に悪用された証拠はありませんが、予防策としてこのフローを廃止することが決まりましたので、

当該のアカウントリンクフローを使用している方は、2018年10月19日までに安全な実装へと移行するようお願いしています。このガイドでご紹介している移行パスをご利用いただけば、どの機能も失われません。

2018年10月19日以降、当該のアカウントリンクフローは無効になり、ランタイムエラーが生じます。

Authorizationヘッダーにスコープ`update:current_user_identities`を含むトークン（IDまたはアクセストークン）を使用して[Post Identitiesエンドポイント](https://auth0.com/docs/api/management/v2#!/Users/post_identities)を呼び出し、ペイロードにセカンダリアカウントの`user_id`を含めると、影響を受けます。その他のユースケースは影響を受けません。