---
og:description: Describes how to migrate from using ID tokens to access tokens when
  linking user accounts.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: アカウントリンクに向けてアクセストークンに移行する
og:url: https://auth0.com/docs/
permalink: link-user-accounts-with-access-tokens-migration
title: アカウントリンクに向けてアクセストークンに移行する
twitter:description: Describes how to migrate from using ID tokens to access tokens
  when linking user accounts.
twitter:title: アカウントリンクに向けてアクセストークンに移行する
---

Previously you could use <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+tokens">ID tokens</Tooltip> to link and unlink user accounts for some use cases. Auth0 is deprecating this functionality. You will now need to use <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip> in all cases.

<Warning>

This deprecation is in response to a potential security vulnerability. Auth0 strongly recommends that you update your code as soon as possible.

</Warning>

## 影響のある機能

アカウントリンクにおける変更点は以下のとおりです：

* `Authorization`ヘッダーでIDトークンを使用できなくなりました。代わりにアクセストークンを使用する必要があります。
* `Authorization`ヘッダーでアクセストークンを使用し、付与されたアクセス許可が`update:users`の場合、要求のボディにはセカンダリアカウントの`user_id`またはIDトークンのいずれかを送信できます。
* `Authorization`ヘッダーでアクセストークンを使用し、付与されたアクセス許可が`update:current_user_metadata`の場合、要求のボディにはセカンダリアカウントのIDトークンのみ送信できます。
* 要求の本文でセカンダリアカウントのIDトークンを送信する場合（上記2つのポイントで紹介したユースケース）、以下のような条件があります。

  + IDトークンは`RS256`を使用して署名される必要があります（この値は、**［Dashboard］>［Clients（クライアント）］>［Client Settings（クライアントの設定）］>［Advanced Settings（高度な設定）］>［OAuth］**から設定できます。
  + IDトークンの`aud`クレームは、クライアントを特定し、アクセストークンの`azp`クレームと同じ値でなければいけません。
* `Authorization`ヘッダーでアカウントのリンクを解除する目的です。代わりにアクセストークンを使用しなければなりません。

アカウントをリンクする方法、リンクを解除する方法はいくつかあります。次のリストで、ユースケースと変更が及ぼす影響を確認してください。

<table class="table"><thead>
<tr>
<th>Use Case</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Use the Management API <code>POST /api/v2/users/{id}/identities</code> endpoint and send the primary account's ID token in the <code>Authorization</code> header.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the Management API <code>POST /api/v2/users/{id}/identities</code> endpoint and send an access token (with scope <code>update:users</code>) in the <code>authorization</code> header, and the secondary account's <code>user_id</code> in the payload.</td>
<td>Not affected</td>
</tr>
<tr>
<td>Use the Management API <code>POST /api/v2/users/{id}/identities</code> endpoint and send an access token (with scope <code>update:current_user_identities</code>) in the <code>Authorization</code> header, and the secondary account's <code>user_id</code> in the payload.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the Management API <code>POST /api/v2/users/{id}/identities</code> endpoint and send an access token in the <code>Authorization</code> header and the secondary account's ID token in the payload.</td>
<td>New use case</td>
</tr>
<tr>
<td>Use the auth0.js library and the primary account's ID token to instantiate <code>auth0.Management</code>.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the auth0.js library and an access token (with scope <code>update:users</code>) to instantiate <code>auth0.Management</code>.</td>
<td>Not affected</td>
</tr>
<tr>
<td>Use the auth0.js library and an access token (with scope <code>update:current_user_identities</code>) to instantiate <code>auth0.Management</code>.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the Management API <code>DELETE	/api/v2/users/{id}/identities/{provider}/{user_id}</code> endpoint and send the primary account's ID token in the <code>Authorization</code> header.</td>
<td>Affected</td>
</tr>
<tr>
<td>Use the Management API <code>DELETE	/api/v2/users/{id}/identities/{provider}/{user_id}</code> endpoint and send an access token in the <code>Authorization</code> header.</td>
<td>Not affected</td>
</tr>
</tbody>
</table>

## アクション

Review all your calls to the account linking [Identities endpoint](https://auth0.com/docs/api/management/v2/#!/Users/post_identities) and update those that make use of the vulnerable flow described above. You can update your calls to either of the following:

* **Client-side / user-initiated linking scenarios:** For client-side linking scenarios, make the call to the Identities endpoint using an access token with the `update:current_user_identities` scope, and provide the ID token of the secondary account in the payload (`link_with`). This ID token must be obtained through an <Tooltip tip="OAuth 2.0: Authorization framework that defines authorization protocols and workflows." cta="View Glossary" href="/docs/glossary?term=OAuth">OAuth</Tooltip>/OIDC-conformant flow.
* **Server-side linking scenarios**:For server-side linking scenarios, make the call to Identities endpoint using an access token with the `update:users` scope and provide the `user_id` of the secondary account in the payload.

See [Link User Accounts](/docs/manage-users/user-accounts/user-account-linking/link-user-accounts) for details.

### ユーザーアカウントをリンクするには、Management APIの[ユーザーアカウントのリンクエンドポイント]()を呼び出すか、[Auth0.jsライブラリ](/libraries/auth0js)を使用します。

To link user accounts you can either call the [Link a User Account endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_identities) of the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> or use the [Auth0.js library](/docs/libraries/auth0js).

#### 一般的なユースケースは、ログインしたユーザーに、アプリを使ってのアカウントのリンクを許可する、というものです。

非推奨になる前は、プライマリユーザーのIDトークンまたはアクセストークン（`update:current_user_identities`スコープを含む) を使用してManagement APIで認証し、[ユーザーアカウントのリンクエンドポイント]()を使用できました。

Prior to the deprecation you could use the primary user's ID token or access token (which contained the `update:current_user_identities` scope) to authenticate with the Management API and use the [Link a User Account endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_identities).

アクセストークンを使う新しい方法だと、コードは次のようになります：

1. Get an access token with the `update:current_user_identities` scope as shown in the following example. The example uses the [implicit flow](/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post), however, you can [get access tokens](/docs/secure/tokens/access-tokens/get-access-tokens) for any application type.
2. Using the previous method using an ID token, your code would look similar to this:

   ```http lines
   https://{yourDomain}/authorize?
         scope=openid
         &response_type=id_token
         &client_id={yourClientId}
         &redirect_uri=https://{yourApp}/callback
         &nonce=NONCE
         &state=OPAQUE_VALUE
   ```


   

   

   Authorizationヘッダーにスコープ`update:current_user_identities`を含むトークン（IDまたはアクセストークン）を使用して[Post Identitiesエンドポイント]()を呼び出し、ペイロードにセカンダリアカウントの`user_id`を含めると、影響を受けます。その他のユースケースは影響を受けません。

   ```http lines
   https://{yourDomain}/authorize?
         audience=https://{yourDomain}/api/v2/
         &scope=update:current_user_identities
         &response_type=token%20id_token
         &client_id={yourClientId}
         &redirect_uri=https://{yourApp}/callback
         &nonce={nonce}
         &state={opaqueValue}
   ```


   

   
3. To get an access token that can access the Management API:

   1. Set the `audience` to `https://{yourDomain}/api/v2/`.
   2. Ask for the `scope` `${scope}`.
   3. Set the `response_type` to `id_token token` so Auth0 will send both an ID token and an access token.
      アクセストークンを使う新しい方法だと、コードは次のようになります：

      ```json lines
      {
         "iss": "https://{yourDomain}/",
         "sub": "auth0|5a620d29a840170a9ef43672",
         "aud": "https://{yourDomain}/api/v2/",
         "iat": 1521031317,
         "exp": 1521038517,
         "azp": "{yourClientId}",
         "scope": "${scope}"
      }
      ```

      

      

      Management APIで任意のユーザーアカウントをリンクする
4. アクセストークンを使う新しい方法だと、コードは次のようになります：

   1. The secondary account's ID Token must be signed with `RS256.`
   2. セキュリティに関する考慮事項
5. Once you have the access token, you can use it to link user accounts. This part remains the same, nothing else changes in the request except for the value you use as `Bearer` token. The response also remains the same.

   ```json lines
   {
      "method": "POST",
      "url": "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities",
      "httpVersion": "HTTP/1.1",
      "headers": [
         {
            "name": "Authorization",
            "value": "Bearer ACCESS_TOKEN"
         },
         {
            "name": "content-type",
            "value": "application/json"
         }
      ],
      "postData" : {
         "mimeType": "application/json",
         "text": "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}"
      }
   }
   ```


   

   

#### ただ、ここで紹介している新しいメソッドはその代わりになります。APIでの認証には引き続き`update:users`スコープを含むアクセストークンを使用しますが、要求のペイロードでセカンダリのアカウントIDトークンを（`user_id`および`プロバイダー`の代わりに）送信できます。

If you use [auth0.js library](/docs/libraries/auth0js) to access the Management API and link accounts, then you probably use the ID token of the user's primary identity to instantiate `auth0.Management` and use it to link accounts.

1. Get an access token with the `update:current_user_identities` scope, then use this token to instantiate `auth0.Management`. The final call to `linkUser` remains the same.
2. Using the previous method using an ID token, your code would look similar to this:


   ```javascript lines
   // get an ID Token
       var webAuth = new auth0.WebAuth({
         clientID: '{yourClientId}',
         domain: '{yourDomain}',
         redirectUri: 'https://{yourApp}/callback',
         scope: 'openid',
         responseType: 'id_token'
       });
       // create a new instance
       var auth0Manage = new auth0.Management({
         domain: '{yourDomain}',
         token: '{yourIdToken}'
       });
   ```


   Authorizationヘッダーにスコープ`update:current_user_identities`を含むトークン（IDまたはアクセストークン）を使用して[Post Identitiesエンドポイント]()を呼び出し、ペイロードにセカンダリアカウントの`user_id`を含めると、影響を受けます。その他のユースケースは影響を受けません。


   ```javascript lines
   // get an Access Token
       var webAuth = new auth0.WebAuth({
         clientID: '{yourClientId}',
         domain: '{yourDomain}',
         redirectUri: 'https://{yourApp}/callback',
         audience: 'https://{yourDomain}/api/v2/',
         scope: 'update:current_user_identities',
         responseType: 'token id_token'
       });
       // create a new instance
       var auth0Manage = new auth0.Management({
         domain: '{yourDomain}',
         token: '{yourMgmtApiAccessToken}'
       });
   ```


   

   

   1. Asks for both an Id token and an access token in response (`` responseType: `token id_token` ``).
   2. Sets the Management API as the intended audience of the token (`` audience: `https://YOUR_DOMAIN/api/v2/` ``).
   3. Asks for the required permission (`` scope: `update:current_user_identities` ``).
   4. Authenticates with the Management API using the access token.

#### セカンダリアカウントのIDトークンの`aud`クレームはクライアントを識別し、要求の作成に使用されたアクセス トークンの`azp`クレームと同じ値を保持する必要があります。

ユーザーアカウントのリンクを解除する

IDトークンを使ってアカウントのリンクを解除するには、アクセストークンを使うようコードを更新しなければなりません。

<CodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities' \
  --header 'authorization: Bearer ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities"

	payload := strings.NewReader("{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer ACCESS_TOKEN")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")
  .header("authorization", "Bearer ACCESS_TOKEN")
  .header("content-type", "application/json")
  .body("{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities',
  headers: {authorization: 'Bearer ACCESS_TOKEN', 'content-type': 'application/json'},
  data: {link_with: 'SECONDARY_ACCOUNT_ID_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer ACCESS_TOKEN",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"link_with": @"SECONDARY_ACCOUNT_ID_TOKEN" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}"

headers = {
    'authorization': "Bearer ACCESS_TOKEN",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer ACCESS_TOKEN",
  "content-type": "application/json"
]
let parameters = ["link_with": "SECONDARY_ACCOUNT_ID_TOKEN"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

アクセストークンを使う新しい方法だと、コードは次のようになります：

* 新しい方法では、呼び出しは次のようになります：
* セキュリティに関する考慮事項

### ある特定のアカウントリンクフローに、特殊な状況において悪用される可能性のある弱点が見つかりました。実際に悪用された証拠はありませんが、予防策としてこのフローを廃止することが決まりましたので、

当該のアカウントリンクフローを使用している方は、2018年10月19日までに安全な実装へと移行するようお願いしています。このガイドでご紹介している移行パスをご利用いただけば、どの機能も失われません。

1. First, you must get an access token with the `update:current_user_identities` scope.
2. Using the previous method using an ID token, your code would look similar to this:


   ```http lines
   https://{yourDomain}/authorize?
         scope=openid
         &response_type=id_token
         &client_id={yourClientId}
         &redirect_uri=https://{yourApp}/callback
         &nonce={nonce}
         &state={opaqueValue}
   ```


   

   

   Authorizationヘッダーにスコープ`update:current_user_identities`を含むトークン（IDまたはアクセストークン）を使用して[Post Identitiesエンドポイント]()を呼び出し、ペイロードにセカンダリアカウントの`user_id`を含めると、影響を受けます。その他のユースケースは影響を受けません。


   ```http lines
   https://{yourDomain}/authorize?
         audience=https://{yourDomain}/api/v2/
         &scope=update:current_user_identities
         &response_type=token%20id_token
         &client_id={yourClientId}
         &redirect_uri=https://{yourApp}/callback
         &nonce={nonce}
         &state={opaqueValue}
   ```


   

   
3. To get an access token that can access the Management API:

   1. Set the `audience` to `https://{yourDomain}/api/v2/`.
   2. Ask for the `scope` `${scope}`.
   3. Set the `response_type` to `id_token token` so Auth0 will send both an ID token and an access token.
      アクセストークンを使う新しい方法だと、コードは次のようになります：


      ```json lines
      {
         "iss": "https://{yourDomain}/",
         "sub": "auth0|5a620d29a840170a9ef43672",
         "aud": "https://{yourDomain}/api/v2/",
         "iat": 1521031317,
         "exp": 1521038517,
         "azp": "{yourClientId}",
         "scope": "update:current_user_identities"
      }
      ```

      

      

      Notice that the `aud` is set to your tenant's API URI, the `scope` to `update:current_user_identities`, and the `sub` to the user ID of the logged in user.
4. Once you have the access token, you can call the [Unlink a user identity endpoint](https://auth0.com/docs/api/management/v2#!/Users/delete_user_identity_by_user_id) of the Management API, using it in the `Authorization` header.
5. Using the previous method, your call would look similar to this:

   ```http lines
   DELETE https://YOUR_DOMAIN/api/v2/users/{primaryAccountUserId}/identities/{secondaryAccountProvider}/{secondaryAccountUserId}
       Authorization: 'Bearer {yourIdTokenOrMgmtApiAccessToken}'
   ```


   

   

   Using the new method, you call will look similar to this:

   ```http lines
   DELETE https://{yourDomain}/api/v2/users/{primaryAccountUserId}/identities/{secondaryAccountProvider}/{secondaryAccountUserId}
       Authorization: 'Bearer {yourMgmtApiAccessToken}'
   ```


   

   

## Security considerations

We have identified a weakness in a particular account linking flow that could allow it to be misused in specific circumstances. We have found no evidence that this has been used maliciously but have decided to deprecate the flow to prevent that ever happening.

Therefore, Auth0 requires customers using the affected account linking flow to migrate to a more secure implementation before 19 October 2018. Migration paths are provided in this guide, which should not result in any lost functionality.

On or after 19 October 2018 the affected account linking flow will be disabled and you will experience run-time errors.

You are impacted if you call the [Post Identities endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_identities) using a token (ID or access token) with the scope `update:current_user_identities` in the Authorization header and include the secondary account's `user_id` in the payload. No other use cases are impacted.

## Learn more

* [Migrate to Management API Endpoints with Access Tokens](/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-calling-api-with-access-tokens)