---
og:description: Describes the deprecation of using ID tokens as credentials for the
  Management API and how to migrate your configuration to use access tokens.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: アクセストークンを使用するManagement APIエンドポイントに移行する
og:url: https://auth0.com/docs/
permalink: migrate-to-calling-api-with-access-tokens
title: アクセストークンを使用するManagement APIエンドポイントに移行する
twitter:description: Describes the deprecation of using ID tokens as credentials for
  the Management API and how to migrate your configuration to use access tokens.
twitter:title: アクセストークンを使用するManagement APIエンドポイントに移行する
---

Using <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+tokens">ID tokens</Tooltip> to call <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> endpoints is being deprecated. You must use <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip>. The grace period for this migration started on **March 31, 2018**.

アクセストークンへの移行が完了したら、Dashboardで**［Allow ID Tokens for Management API v2 Authentication（Management API v2認証にIDトークンを許可する）］**を無効にします。

以下のいずれかのエンドポイントを呼び出すためにIDトークンを使用する場合、この移行による影響を受けます。これらのエンドポイントは、通常のアクセストークンを受け入れられるようになりました。エンドポイントの動作にその他の変更はありません。要求と応答のスキーマは同じままで、認可に使用するトークンの更新だけが必要です。

## 影響を受けるエンドポイント

<table class="table"><thead>
<tr>
<th>Endpoint</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET /api/v2/users/{id}</td>
<td>Retrieve a user's information</td>
</tr>
<tr>
<td>GET /api/v2/users/{id}/enrollments</td>
<td>Retrieve all Guardian MFA enrollments for a user</td>
</tr>
<tr>
<td>PATCH /api/v2/users/{id}</td>
<td>Update a user's information</td>
</tr>
<tr>
<td>DELETE /api/v2/users/{id}/multifactor/{provider}</td>
<td>Delete the MFA provider settings for a user</td>
</tr>
<tr>
<td>POST /api/v2/device-credentials</td>
<td>Create a public key for a device</td>
</tr>
<tr>
<td>DELETE /api/v2/device-credentials/{id}</td>
<td>Delete a device credential</td>
</tr>
<tr>
<td>POST/api/v2/users/{id}/identities</td>
<td>Link user accounts from various identity providers</td>
</tr>
<tr>
<td>DELETE /api/v2/users/{id}/identities/{provider}/{user_id}</td>
<td>Unlink user accounts</td>
</tr>
</tbody>
</table>

## アクション

### スコープの変更

Management APIで実行できるアクションは、アクセストークンに含まれるスコープに依存します。この移行により、ログインしているユーザーのデータのみを更新できる制限付きアクセストークン、または任意のユーザーのデータを更新できるアクセストークンを取得できます。以下の表で、トークンに必要なスコープをケースとエンドポイントごとに確認してください。

For example, if you get an access token that contains the scope `read:users`, you can retrieve the data of any user using the `GET /api/v2/users/{id}` endpoint. However, if your token contains the scope `read:current_user`, you can only retrieve the information of the currently logged-in user (the one that the token was issued for).

<table class="table"><thead>
<tr>
<th>Endpoint</th>
<th>Scope for current user</th>
<th>Scope for any user</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET /api/v2/users/{id}</td>
<td><code>read:current_user</code></td>
<td><code>read:users</code></td>
</tr>
<tr>
<td>GET /api/v2/users/{id}/enrollments</td>
<td><code>read:current_user</code></td>
<td><code>read:users</code></td>
</tr>
<tr>
<td>POST/api/v2/users/{id}/identities</td>
<td><code>update:current_user_identities</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>DELETE /api/v2/users/{id}/identities/{provider}/{user_id}</td>
<td><code>update:current_user_identities</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>PATCH /api/v2/users/{id}</td>
<td><code>update:current_user_metadata</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>PATCH /api/v2/users/{id}</td>
<td><code>create:current_user_metadata</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>DELETE /api/v2/users/{id}/multifactor/{provider}</td>
<td><code>delete:current_user_metadata</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>POST /api/v2/device-credentials</td>
<td><code>create:current_user_device_credentials</code></td>
<td><code>create:device_credentials</code></td>
</tr>
<tr>
<td>DELETE /api/v2/device-credentials/{id}</td>
<td><code>delete:current_user_device_credentials</code></td>
<td><code>delete:device_credentials</code></td>
</tr>
</tbody>
</table>

### アクセストークンの取得

Auth0 has changed how you get a token for the previously mentioned endpoints. There are several variations on how you authenticate a user and get tokens, depending on the technology and the <Tooltip tip="OAuth 2.0: Authorization framework that defines authorization protocols and workflows." cta="View Glossary" href="/docs/glossary?term=OAuth+2.0">OAuth 2.0</Tooltip> flow you use to authenticate:

* **ブラウザーで動作するSPA**：認可エンドポイントを使用する。
* **Web app running on a server, a mobile app, a server process, or a highly trusted app**: Use the <Tooltip tip="Token Endpoint: Endpoint on the Authorization Server that is used to programmatically request tokens." cta="View Glossary" href="/docs/glossary?term=Token+endpoint">Token endpoint</Tooltip>.
* **クロス認証**：異なるドメインから要求が来る場合、ユーザー認証には埋め込みのロックまたはauth0.jsを使用する。

#### 認可エンドポイント

このセクションでは、認可エンドポイントでトークンを取得する方法の違いについて例を用いて説明します。どのエンドポイントを移行したいかに関わらず変更点は同じで、唯一異なる点は要求で指定するスコープです。

以下の例では、`GET User by ID`エンドポイントを使用して、ログインユーザーの完全なプロファイル情報を取得します。そのために、まず、暗黙的付与を使用してユーザーを認証し、トークンを取得します。以下は、IDトークンを取得し、それを使用してエンドポイントを呼び出す、以前の方法の実装例です。

```http lines
https://{yourDomain}/authorize?
      scope=openid
      &response_type=id_token
      &client_id={yourClientId}
      &redirect_uri=https://{yourApp}/callback
      &nonce={nonce}
      &state={opaqueValue}
```






以下は、アクセストークンを取得する新しい方法の例です。


```http lines
https://{yourDomain}/authorize?
      audience=https://{yourDomain}/api/v2/
      &scope=read:current_user
      &response_type=token%20id_token
      &client_id={yourClientId}
      &redirect_uri=https://{yourApp}/callback
      &nonce={nonce}
      &state={opaqueValue}
```






Management APIにアクセスできるアクセストークンを取得するには以下を行います。

* Set the `audience` to `https://{yourDomain}/api/v2/`
* スコープ`${scope}`を要求する
* `response_type`を`id_token token`に設定し、Auth0がIDトークンとアクセストークンの両方を送るようにする

受け取ったアクセストークンをデコードして確認すると、次のような内容になります。

```json lines
{
      "iss": "https://{yourDomain}/",
      "sub": "auth0|5a620d29a840170a9ef43672",
      "aud": "https://{yourDomain}/api/v2/",
      "iat": 1521031317,
      "exp": 1521038517,
      "azp": "{yourClientId}",
      "scope": "${scope}"
    }
```






アクセストークンを取得したら、それを使ってエンドポイントを呼び出します。この部分は同じで、要求のうち、`Bearer`トークンとして使用する値を除き変更はありません。応答も同じです。

埋め込みのロックまたはauth0.js

#### このセクションでは、トークンエンドポイントでトークンを取得する方法の違いについて例を用いて説明します。どのエンドポイントを移行したいかに関わらず変更点は同じで、唯一異なる点は要求で指定するスコープです。

以下の例では、`GET User by ID`エンドポイントを使用して、ログインユーザーの完全なプロファイル情報を取得します。まず、パスワード交換の付与タイプを使ってユーザーを認証してから、トークンを取得します。以下は、IDトークンを取得する（そして、それを使用してエンドポイントを呼び出す）以前の方法の実装例です。

以下は、アクセストークンを取得する新しい方法の例です。


```json lines
POST https://{yourDomain}/oauth/token
    Content-Type: application/x-www-form-urlencoded
    {
      "grant_type": "password",
      "username": "{yourUsername}",
      "password": "{yourPassword}",
      "scope": "openid",
      "client_id": "{yourClientId}",
      "client_secret": "{yourClientSecret}",
    }
```






Management APIにアクセスできるアクセストークンを取得するには以下を行います。

```json lines
POST https://{yourDomain}/oauth/token
    Content-Type: application/x-www-form-urlencoded
    {
      "grant_type": "password",
      "username": "{yourUsername}",
      "password": "{yourPassword}",
      "audience": "https://{yourDomain}/api/v2/",
      "scope": "read:current_user",
      "client_id": "{yourClientId}",
      "client_secret": "{yourClientSecret}",
    }
```






`aud`を`

* Set the `aud` to `https://{yourDomain}/api/v2/`
* アクセストークンを取得したら、それを使ってエンドポイントを呼び出します。この部分は同じで、要求のうち、`Bearer`トークンとして使用する値を除き変更はありません。応答も同じです。

埋め込みのロックまたはauth0.js

#### アプリケーションにロックまたはauth0.js v9を埋め込んだ場合、クロスオリジン認証を使用しています。これは、異なるドメインから要求が来る場合、ユーザーの認証に使用します。

Management APIへのアクセスとユーザーの管理にauth0.jsを使用する場合、スクリプトを更新する必要があります。

以下の例は、以前の方法です。

この例は、新しい方法です。

```javascript lines
// get an ID Token
    var webAuth = new auth0.WebAuth({
      clientID: '{yourClientId}',
      domain: '{yourDomain}',
      redirectUri: 'https://{yourApp}/callback',
      scope: 'openid',
      responseType: 'id_token'
    });
    // create a new instance
    var auth0Manage = new auth0.Management({
      domain: '{yourDomain}',
      token: '{yourIdToken}'
    });
```


応答でIDトークンとアクセストークンの両方を要求する

```javascript lines
// get an Access Token
    var webAuth = new auth0.WebAuth({
      clientID: '{yourClientId}',
      domain: '{yourDomain}',
      redirectUri: 'https://{yourApp}/callback',
      audience: 'https://{yourDomain}/api/v2/',
      scope: 'read:current_user',
      responseType: 'token id_token'
    });
    // create a new instance
    var auth0Manage = new auth0.Management({
      domain: '{yourDomain}',
      token: '{yourMgmtApiAccessToken}'
    });
```






* Management APIを意図したトークンのオーディエンスとして設定する

  `responseType: 'token id_token'`
* Set the Management API as the intended <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> of the token

  `audience: 'https://YOUR_DOMAIN/api/v2/'`
* アクセストークンを使ってManagement APIで認証する

  `scope: 'read:current_user'`
* アカウントリンクの変更

### この機能性の変更点は以下の通りです。

`Authorization`ヘッダーにIDトークンを使用することはできなくなりました。

* `Authorization`ヘッダーでアクセストークンを使用し、付与されたアクセス許可が`update:users`の場合、要求のボディにはセカンダリアカウントの`user_id`またはIDトークンのいずれかを送信できます。
* `Authorization`ヘッダーでアクセストークンを使用し、付与されたアクセス許可が`update:current_user_metadata`の場合、要求のボディにはセカンダリアカウントのIDトークンのみ送信できます。次のような条件があります。
* IDトークンは`RS256`を使用して署名される必要があります（この値は、**［Dashboard］>［Applications（アプリケーション）］>［Application Settings（アプリケーションの設定）］>［Advanced Settings（高度な設定）］>［OAuth］**から設定できます）

  + IDトークンの`aud`クレームは、アプリケーションを特定し、アクセストークンの`azp`クレームと同じ値でなければいけません。
  + 制限

## Management APIにアクセスするために使用されるアクセストークンは、`aud`クレームの値が1つのみである必要があります。トークンに複数の値がある場合、Management APIへの要求はエラーになります。

The access tokens used to access the Management API must only hold one value at the `aud` claim. If your token contains more than one value, then your request to the Management API will error out.

## Learn more

* [Migrate to Access Tokens for Account Linking](/docs/troubleshoot/product-lifecycle/past-migrations/link-user-accounts-with-access-tokens-migration)