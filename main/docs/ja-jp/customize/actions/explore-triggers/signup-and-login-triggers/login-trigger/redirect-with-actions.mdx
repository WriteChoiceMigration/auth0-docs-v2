---
og:description: Learn how to use post-login Actions to redirect users before an authentication
  transaction is complete.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: アクションを使用してダイレクトする
og:url: https://auth0.com/docs/
permalink: redirect-with-actions
title: アクションを使用してダイレクトする
twitter:description: Learn how to use post-login Actions to redirect users before
  an authentication transaction is complete.
twitter:title: アクションを使用してダイレクトする
---

認証トランザクションの前に、ログイン後のアクションを使ってユーザーをリダイレクトすることができます。カスタム認証フローを実装して、標準のログインフォームにはない追加のユーザー操作に対応できるようになります。

Redirects are commonly used to do custom [Multi-factor Authentication (MFA)](/docs/secure/multi-factor-authentication) in Auth0, but they can also be used to:

* カスタムのプライバシーポリシーへの同意、利用規約、データ開示のフォームを使用できるようにする
* 追加で必要なプロファイルデータを安全に一度だけ収集する
* Microsoft Entra IDのリモートユーザーがパスワードを変更できるようにする
* ユーザーが未知の場所からログインする際に、追加で検証を求める
* サインアップ時にユーザーが提供したよりも多くのユーザー情報を集める

## 概要

リダイレクトのアクションは通常、以下のように動作します。

1. An Action issues a redirect to a URL.
2. The Actions pipeline is suspended after that Action completes its execution.
3. The user is redirected to the URL along with a `state` parameter.
4. When the external flow has concluded, the external site redirects the user to a `/continue` endpoint along with the `state` parameter.
5. The Actions pipeline is resumed on the same Action that invoked the redirect.

## リダイレクトを開始する

以下のように`api.redirect.sendUserTo()`機能を呼び出します。

```javascript lines
/**
* @param {Event} event - Details about the user and the context in which they are logging in.
* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
*/
exports.onExecutePostLogin = async (event, api) => {
  api.redirect.sendUserTo("https://my-app.exampleco.com");
};
```






Actions will finish the execution of this Action, and then suspend the actions pipeline to send the user to the `https://my-app.exampleco.com`. In other words, any Actions that are bound to the post-login triggers that run after the Action invoking the redirect will not execute until the authentication flow has been resumed. If you are familiar with Redirect Rules, then note that this is a key difference between Redirect Actions and Redirect Rules.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Unlike Redirect Rules, Redirect Actions will suspend the Actions pipeline when a redirect is issued and will resume in the same Action that issued the redirect when the authentication flow is continued.

</Callout>

アクションの実行が完了すると、Auth0がユーザーを`api.redirect.sendUserTo()`関数でURL指定された場所にリダイレクトします。Auth0はそのURLに`state`パラメーターも渡します。例：

`https://my-app.exampleco.com/?state=abc123`

Your redirect URL will need to extract the `state` parameter and send it back to Auth0 to resume the authentication transaction. State is an opaque value used to prevent [Cross-Site Request Forgery (CSRF) attacks](/docs/secure/security-guidance/prevent-threats).

## 認証フローを再開する

リダイレクト後にユーザーを`/continue`エンドポイントにリダイレクトし、URLで受信した`state`パラメーターを含めることで認証を再開します。元の状態を`/continue`エンドポイントに送り返さないと、Auth0はログイントランザクションのコンテキストを失い、`invalid_request`エラーのためにユーザーがログインできなくなります。

この例では、`THE_ORIGINAL_STATE`はAuth0が生成し、リダイレクトURLに送信した値です。たとえば、アクションが`

`https://{yourAuth0Domain}/continue?state=THE_ORIGINAL_STATE`

In this example, `THE_ORIGINAL_STATE` is the value that Auth0 generated and sent to the redirect URL. For example, if your Action redirects to `https://my-app.exampleco.com/`, Auth0 would use a redirect URL similar to `https://my-app.exampleco.com/?state=abc123`, making `abc123` the `THE_ORIGINAL_STATE`. To resume the authentication transaction, you would redirect to:

`https://{yourAuth0Domain}/continue?state=abc123`

データを外部のサイトへ渡す

```javascript lines
/**
* @param {Event} event - Details about the user and the context in which they are logging in.
* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
*/
exports.onExecutePostLogin = async (event, api) => {
  api.redirect.sendUserTo("https://my-app.exampleco.com");
};

/**
* @param {Event} event - Details about the user and the context in which they are logging in.
* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
*/

exports.onContinuePostLogin = async (event, api) => {
}
```






## データを外部サイトに渡す場合は、そのデータを署名済みの[JWT](/security/tokens/json-web-tokens)でエンコードすることをお勧めします。そうすれば、アプリケーションは送信中にデータが改ざんされていないことを確信できます。Actionsでは`api.redirect.encodeToken`および`api.redirect.sendUserTo`関数を使用してこれを実行できます。

To pass data to the external site, we recommend encoding that data in a signed [JWT](/docs/secure/tokens/json-web-tokens) so that your application can be certain it was not tampered with during transit. With Actions, this can be done with the `api.redirect.encodeToken` and `api.redirect.sendUserTo` functions:

```javascript lines expandable
/**
* @param {Event} event - Details about the user and the context in which they are logging in.
* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
*/
exports.onExecutePostLogin = async (event, api) => {
  const YOUR_AUTH0_DOMAIN = event.secrets.YOUR_AUTH0_DOMAIN || event.request.hostname

  // Craft a signed session token
  const token = api.redirect.encodeToken({
    secret: event.secrets.MY_REDIRECT_SECRET,
    expiresInSeconds: 60, 
    payload: {
      // Custom claims to be added to the token
      email: event.user.email,
      externalUserId: 1234,
      continue_uri: `https://${YOUR_AUTH0_DOMAIN}/continue`
    },
  });

  // Send the user to https://my-app.exampleco.com along
  // with a `session_token` query string param including
  // the email.
  api.redirect.sendUserTo("https://my-app.exampleco.com", {
    query: { session_token: token }
  });
}
```






トークンが改ざんされていないことを確認する

<table class="table"><thead>
<tr>
<th>Token Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sub</code></td>
<td>Auth0 <code>user_id</code> of the user.</td>
</tr>
<tr>
<td><code>iss</code></td>
<td>Hostname of your Auth0 tenant domain (e.g., <code>example.auth0.com</code>).</td>
</tr>
<tr>
<td><code>exp</code></td>
<td>Expiration time (in seconds) specified with the <code>expiresInSeconds</code> parameter. Should be as short as possible to avoid re-use of the token. Defaults to 900 seconds (15 minutes).</td>
</tr>
<tr>
<td><code>ip</code></td>
<td>IP Address of the originating authentication request.</td>
</tr>
<tr>
<td><code>email</code></td>
<td>Custom claim with a value specified in the <code>payload.email</code> parameter.</td>
</tr>
<tr>
<td><code>externalUserId</code></td>
<td>Custom claim with a value specified in the <code>payload.externalUserId</code> parameter.</td>
</tr>
<tr>
<td><code>signature</code></td>
<td>Using the secret specified above, the token will be signed with HS256 algorithm.</td>
</tr>
</tbody>
</table>

### 外部のシステムは、このトークンが送信中に改ざんされていないことを検証しなければなりません。これを実現するために、リモートシステムはトークンの署名が有効であることを確認し、該当する場合は、外部システム内のセッションがトークンの`sub`クレームで渡される同じAuth0ユーザーに属していることを確認しなければなりません。

データをAuth0へ戻す

## ユーザーが外部サイトでカスタムフローを完了すると、`/continue`エンドポイントにリダイレクトされます。状況によっては、データをAuth0に戻して、そのユーザーの認証フローや認可フロー（たとえば、CAPTCHA認証やカスタムMFAなど）に影響を与える必要があるかもしれません。

After the user completes the custom flow in the external site, they should be redirected to the `/continue` endpoint. In some situations, you may want to pass data back to Auth0 to impact the authentication or <Tooltip tip="Authorization Flow: Authorization grant (or workflow) specified in the OAuth 2.0 framework." cta="View Glossary" href="/docs/glossary?term=authorization+flow">authorization flow</Tooltip> for that user (for example, if you are implementing CAPTCHA checks or custom <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=MFA">MFA</Tooltip>).

### 可能であれば、リモートシステムは[Auth0 Management API]()を使用して、カスタム情報をAuth0ユーザープロファイルのアプリケーションメタデータとして保管する必要があります。Auth0アクションフローが再開されると、この情報は`event.user.app_metadata`オブジェクトで利用できるようになります。この方法では、機密情報をフロントチャネルでAuth0に渡す必要がなくなります。

If possible, the remote system should use the [Auth0 Management API](https://auth0.com/docs/api/management/v2/) to store custom information as application metadata on the Auth0 user profile. When the Auth0 Action flow is resumed, this information will be available on the `event.user.app_metadata` object. This approach avoids passing sensitive information to Auth0 on the front channel.

### Auth0のプロファイルに保管するデータは多すぎないようにします。このデータは認証および認可の目的で使用されるものです。Auth0のメタデータや検索機能は、マーケティング調査などのように、頻繁に検索や更新されることを想定して設計されたものではありません。Auth0をそのような目的で使用すると、ほぼ確実にシステムの拡張性や性能に問題が生じます。

アプリケーションにかなりの量のユーザーデータが必要な場合には、データを外部システムに保管して、Auth0に外部キー（ユーザーID）を保管すると、バックエンドシステムが必要に応じてデータを取得できるようになります。

データをフロントチャネルに送信する

## 情報をフロントチャネルでやり取りすると、悪意のある行為者の攻撃対象になる領域を広げることになります。情報をフロントチャネルに送信しなければならない場合には、以下のガイダンスを考慮してください。

Passing information back and forth in the front channel opens up surface area for <Tooltip tip="Bad Actors: Entity (a person or group) that poses a threat to the business or environment with the intention to cause harm." cta="View Glossary" href="/docs/glossary?term=bad+actors">bad actors</Tooltip> to attack. If information must be sent on the front channel, then consider the following guidance:

### 機密情報をAuth0に送信して戻すには、必ず署名済みのセッショントークンを使用します。このトークンは、アクション内で以下のコードを使って手軽に検証することができます。

トークンは以下を確実にするために検証されます。

```javascript lines
/**
 * @param {Event} event - Details about the user and the context in which they are logging in.
 * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
 */
exports.onContinuePostLogin = async (event, api) => {
  const payload = api.redirect.validateToken({
    secret: event.secrets.PRECONFIGURED_SECRET,
    tokenParameterName: 'my_token',
  });

  // use the data encoded in the token, such as: 
  api.idToken.setCustomClaim('color', payload.favorite_color);
}
```






署名が有効である

* トークンの有効期限が切れていない
* トークン内の`state`クレームは、リダイレクトの一部として使用される`state`パラメーターと一致します。
* リプレイ攻撃を回避するには、`/continue`エンドポイントにPOST要求を行って、トークンをAuth0に送り返す必要があります。コード内の`tokenParameterName`オプションを使用すると、トークンを含むフィールドの名前を指定できます。

<table class="table"><thead>
<tr>
<th>Token Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sub</code></td>
<td>Auth0 <code>user_id</code> of the user.</td>
</tr>
<tr>
<td><code>iss</code></td>
<td>Application that is targeted for the redirect.</td>
</tr>
<tr>
<td><code>exp</code></td>
<td>Should be as short as possible to avoid reuse of the token.</td>
</tr>
<tr>
<td><code>state</code></td>
<td>state parameter sent to the remote site as part of the redirect. This must be included in the token to avoid replay attacks.</td>
</tr>
<tr>
<td><code>other</code></td>
<td>Any other custom claims will be exposed as the <code>payload</code> in the code above.</td>
</tr>
<tr>
<td><code>signature</code></td>
<td>Token should be signed with the HS256 algorithm.</td>
</tr>
</tbody>
</table>

カスタム認証方式

## ログインパイプラインでリダイレクトに成功したら、アクションはカスタム認証方法のイベントをユーザーセッションに記録することができます。`event.authentication.methods`配列には、ユーザーのブラウザーセッションが継続する間、カスタム認証方法のエントリが含まれます。この配列の各エントリーには、認証方法が記録された日時を示すタイムスタンプがあります。

必要なカスタム認証方法が`event.authentication.methods`配列にない場合、またはエントリが古すぎる場合には、カスタムアクションによってリダイレクトがトリガーされることがあります。

ワークフローで、ユーザーセッションの有効期間中にカスタム認証方法の定期的な再実行が必要になるかもしれません。たとえば、カスタムMFAの使用では、指定された時間が経過すると、ユーザーの再検証が必要になることがあります。

以下の例では、カスタム認証方法を返す契機を決めるために、既存のレコードのタイムスタンプを照合します。

制約と制限

リダイレクトのアクションは以下では動作しません。

[リソース所有者のエンドポイント]()

```javascript lines expandable
const CUSTOM_METHOD_URL = "https://path.to.prompt";
const PROMPT_TTL = 1000 * 60 * 60 * 24; // 24h

/**
 * Handler that will be called during the execution of a PostLogin flow.
 *
 * @param {Event} event - Details about the user and the context in which
 * they are logging in.
 * @param {PostLoginAPI} api - Interface whose methods can be used to
 * change the behavior of the login.
 */
exports.onExecutePostLogin = async (event, api) => {
  // Search authentication method records for an entry representing our
  // custom method.
  const methodRecord = event.authentication?.methods.find((record) =>
    validateCustomRecord(record, CUSTOM_METHOD_URL, PROMPT_TTL)
  );

  if (!methodRecord) {
    const sessionToken = api.redirect.encodeToken({
      payload: {
        user_id: event.user.user_id,
      },
      secret: event.secrets.SESSION_TOKEN_SECRET,
    });

    // We didn't find a valid record, so we send the user to the
    // URL that implements the custom method with the signed
    // data we encoded in `sessionToken`.
    api.redirect.sendUserTo(CUSTOM_METHOD_URL, {
      query: { session_token: sessionToken },
    });
  }
};

/**
 * Handler that will be invoked when this action is resuming after an
 * external redirect. If your onExecutePostLogin function does not perform
 * a redirect, this function can be safely ignored.
 *
 * @param {Event} event - Details about the user and the context in which
 * they are logging in.
 * @param {PostLoginAPI} api - Interface whose methods can be used to
 * change the behavior of the login.
 */
exports.onContinuePostLogin = async (event, api) => {
  const payload = api.redirect.validateToken({
    secret: event.secrets.SESSION_TOKEN_SECRET,
    tokenParameterName: "session_token",
  });

  if (!validateSessionToken(payload)) {
    return api.access.deny("Unauthorized");
  }

  // Record the completion of our custom authentication method.
  // THIS NEW API IS ONLY AVAILABLE IN `onContinuePostLogin`.
  api.authentication.recordMethod(CUSTOM_METHOD_URL);
};

function validateCustomRecord(record, url, ttl) {
  if (!record) {
    // No record means it isn't valid.
    return false;
  }

  if (record.url !== url) {
    // This isn't a record of our custom method.
    return false;
  }

  // Timestamps are rendered as ISO8601 strings.
  const timestamp = new Date(record.timestamp);

  // The record is valid if it was recorded recently enough.
  return timestamp.valueOf() >= Date.now() - ttl;
}

function validateSessionToken(payload) {
  // Custom validation logic for the data returned by the
  // custom method goes here.
  return true;
}
```






[パスワードの交換](/login/flows/resource-owner-password-flow)

## [リフレッシュトークンの交換](/security/tokens/refresh-tokens)

リソース所有者のエンドポイント

* [Resource Owner endpoint](https://auth0.com/docs/api/authentication/reference#resource-owner)
* [Password exchange](/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)
* [Refresh Token exchange](/docs/secure/tokens/refresh-tokens)

### リフレッシュトークン

It is impossible to use redirect Actions when you are calling the Authentication API [Get Token](https://auth0.com/docs/api/authentication#resource-owner-password) endpoint for the <Tooltip tip="Resource Owner: Entity (such as a user or application) capable of granting access to a protected resource." cta="View Glossary" href="/docs/glossary?term=Resource+Owner">Resource Owner</Tooltip> Password flow. Since the user is not in a redirect flow to begin with, you can not redirect the user in an Action.

### Flows where prompt=none

アクションで`api.redirect.sendUserTo()`が呼び出されるときに、`prompt=none`が渡された場合、`error=interaction_required`で認可が失敗しますが、アクションが失敗してもユーザーのセッションが作成されるため、ユーザーがリダイレクトチャレンジに合格したことを信頼できず、トークンを取得する方法として`prompt=none`を使用することはできません。

この特有なケースには、リフレッシュトークンの排他的な使用をお勧めします。リフレッシュトークンの生成にチャレンジが必要な場合に、ユーザーがチャレンジに成功したことを確認できるからです。

You cannot create a redirect flow that blocks token access and bypasses the redirect Action if `prompt=none` because after a failed attempt, a user can simply call again with `prompt=none` and get tokens because their authentication session has been created even though Actions failed the first time.

### Refresh tokens

Due to the fact that using a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=refresh+token">refresh token</Tooltip> requires a back-channel call to the Authentication API [Get Token](https://auth0.com/docs/api/authentication#refresh-token) endpoint, this will also fail if attempting to redirect.

It is difficult to securely verify that any restrictions on login were carried out. There is not a consistent session ID in the context that could be used to collect information associated with the session such as this user passed MFA challenges. Therefore, you cannot use `prompt=none` at all.

Any time `api.redirect.sendUserTo()` is called in an Action, if `prompt=none` was passed, then the authorization fails with `error=interaction_required`, but since the user's session is created even if Actions fail, we can't trust that a user passed redirect challenges and therefore can't use `prompt=none` as a way to get tokens.

In this specific case, we recommend that you use refresh tokens exclusively, because you can ensure that a user passed challenges if those challenges are required to generate a refresh token.

## Learn more

* [Manage User Metadata with the post-login Action Trigger](/docs/manage-users/user-accounts/metadata/manage-user-metadata)