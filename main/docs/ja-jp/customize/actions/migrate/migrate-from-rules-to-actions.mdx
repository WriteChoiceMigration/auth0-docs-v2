---
og:description: Learn how to migrate your existing Auth0 Rules code to Auth0 Actions
  code.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: RulesからActionsに移行する
og:url: https://auth0.com/docs/
permalink: migrate-from-rules-to-actions
title: RulesからActionsに移行する
twitter:description: Learn how to migrate your existing Auth0 Rules code to Auth0
  Actions code.
twitter:title: RulesからActionsに移行する
---

既存のルールをアクションに変換する場合は、新しいアクションをログインフローのログイン後(`post-login`)トリガーに関連付ける必要があります。以下の手順に従い、アクションを元のルールと同じ順序にしておくと、機能は同じになります。

## 移行を計画する

Post-Loginアクションは既存のルールの後に実行されるため、Dashboardでルールを一度に1つずつ変換することも、 Management APIを使用して一度にすべてを変換することもできます。

コードを変換してから、アクションをアクティブにし、ルールを非アクティブにする必要があります。アクションの有効化とルールの無効化は、連続してすばやく実行できますが、順序によっては、両方が実行されない、またはどちらも実行されない時間が短期間発生する場合があります。

このため、パイプラインを段階的に移行することをお勧めします。ルールコードの一部をアクションコードに変換し、ステージング環境でテストしてから、一度に1つずつライブに移行します。アクティブなルールはデプロイされたアクションの前に実行されるため、ルールパイプラインの最後から開始して逆方向に作業すると、アクションで他のロジックを構築およびテストするときに、一部のロジックをルールに保持したままにすることができます。



## 制限事項を理解する

アクションはルールでできることの大部分を処理できますが、移行を開始する前にいくつかの制限事項に注意する必要があります（注：フックとアクションはどちらも移行中に実行できます）。

* アクションには、ルールの場合のように、[Management APIのアクセストークン](/rules/use-management-api)や[グローバル`auth0`オブジェクト](/rules-best-practices/rules-environment-best-practices)へのアクセスは提供されません。Management API呼び出しを引き続き行う方法については、「[コードの変換](#convert-code)」セクションを参照してください。

すべての制限事項については、「[Actionsの制限事項](/actions/limitations)」を参照してください。

## コードを変換する

ルールをアクションに変換するには、ルール固有のコードをアクションコードに置き換える必要があります。このセクションでは、機能するルールを同等のアクションに変換するためのタスクについて説明します。



### ルールコードを新しいアクションにコピーする



1. 運用テナントにログインし、変換元となるルールのコードをコピーします。
2. 非運用テナントに切り替えて、[［Auth0 Dashboard］ > ［Actions（アクション）］ > ［Library（ライブラリ）］](%24%7Bmanage_url%7D/select-tenant?path=/actions/library)に移動します。
3. **［Build Custom（カスタムの構築）］**を選択した後、

* 変換するルールの名前と一致するアクションの**名前**を入力します。
* **トリガー**を見つけて、**ログイン/ログイン**後を選択します。
* **［Runtime（ランタイム）］**で、**［Node 22］**を選択します。
* **［Create（作成）］**を選択します。
4. アクションコードエディターのコードブロックで、エクスポートされた`onExecutePostLogin`関数の下に変換するルールコードを貼り付けます。
5. コードを関数に移動するときに、この記事で後述している変更を加えます。

### 関数宣言を変更する

ルールは、`ユーザー`、`コンテキス`ト、および`コールバック`パラメータを持つ単純な宣言済み関数を使用しますが、アクションは特定の名前にエクスポートされた関数を使用します。以下の変更を加えます。現在のところ、表示されるエラーは無視してください。

**変更前**



**変換後**



### ユーザーデータへのアクセス方法を変更する

ルールでは、ログインするユーザーに関するデータは[`user`オブジェクト](/rules/user-object-in-rules)に保存されます。アクションでは、このデータは[`event`オブジェクト](/signup-and-login-triggers/login-trigger/post-login-event-object)の`user`プロパティにあります。既存のプロパティの大部分は、この新しい場所でアクセスできます。



**変更前**



**変換後**



### コンテキストデータへのアクセス方法を変更する

ルールでは、現在のログインセッションに関するデータは[`context`オブジェクト](/rules/context-object)に保存されます。アクションの場合、このデータは再形成され、[`event`オブジェクト](/signup-and-login-triggers/login-trigger/post-login-event-object)に移動されました。プロパティの多くはそのまま移行されましたが、わかりやすくするために一部が結合されました。



**変更前**



**変換後**

********

### 依存関係を変換する

ルールには、`require`ステートメントにバージョン番号を含めることを要求する方法で依存関係が含まれます。アクションでは、より標準的なCommonJS構文が使用され、コードエディターの外部でバージョンを示す必要があります。

ルールでは、特定のパッケージの特定のバージョンのみが許可され、新しいパッケージとバージョンを追加するにはAuth0への要求が必要です。アクションでは、`npm`レジストリで利用可能な任意のパッケージを要求できます。



1. ルールコード内で`require`ステートメントを検索します。
2. バージョン番号を削除しますが、これらの番号はメモしておいてください。
3. 依存関係が[コアNodeJSモジュール](https://github.com/nodejs/node/tree/master/lib)でない場合は、「[初めてアクションを作成する](/actions/write-your-first-action)」の「依存関係を追加する」セクションの手順に従って依存関係を追加してください。依存関係がコアNodeJSモジュールである場合は、追加する必要はありません。
4. 見つかった`require`ステートメントを`function`宣言の外に移動します:

**変更前**



**変換後**



### コールバックを変換する

ルールの処理が完了したら、`callback()`関数を呼び出して、ログインに失敗した場合はエラーを渡す必要があります。逆に、アクションは成功時に返したり、ログインに失敗した場合はメッセージとともに`api`メソッドを呼び出したりできます。ルール内の`callback()`のすべてのインスタンスは削除するか、失敗した場合は`api.access.deny()`に置き換える必要があります。ルールとアクションの両方で、特定の条件で処理を停止する必要がある場合は、`return`ステートメントを使用します。

**変更前**



**変換後**



### シークレットの処理を変更する

ルールでは、構成値をグローバルに設定します。これは、すべてのルールがすべてのシークレット値にアクセスできることを意味します（詳細については、「[ルールの構成を保管する](/rules/configuration)」を参照してください）。アクションでは、個々のアクションごとに構成値を設定します。アクションのコンテキスト外からアクションのシークレット値にアクセスすることはできません。

シークレットをルールからアクションに変換するには：

1. 操作中の特定のアクションに必要な値を保存します。
2. アクション内からアクセスする必要がある値ごとにシークレットを追加します。方法については、「[初めてアクションを作成する](/actions/write-your-first-action)」の「**シークレットを追加する**」セクションをお読みください。
3. コードを変換します。

**変更前**

********

**変換後**

********

ルールの場合と同様に、Auth0は保管時のすべてのシークレット値を暗号化します。

### カスタムクレームをトークンに変換する

ルールとアクションでは共に、カスタムクレームをIDトークンおよびアクセストークンに追加できます。ルールでは、これは`context`オブジェクトのプロパティですが、アクションでは[`api`オブジェクト](/signup-and-login-triggers/login-trigger/post-login-api-object)のメソッドが使用されます。

**変更前**

********

**変換後**



### 多要素トリガーを変換する

ルールでは、[`context`オブジェクト](/rules/context-object)の`multifactor`プロパティを変更することで、多要素認証をトリガーできます。アクションでは、これは[`api`オブジェクトのメソッド](/signup-and-login-triggers/login-trigger/post-login-api-object)を使用して実行されます。

**変更前**



**変換後**



### ユーザーメタデータの更新を変換する

ルール内の`user_metadata`プロパティと`app_metadata`プロパティを更新するには、Management APIの呼び出しが必要であり、[レート制限](/support/policies/rate-limit-policy/management-api-endpoint-rate-limits)エラーが発生する可能性があります。ただし、アクションは複数のユーザーメタデータの変更を示す方法を提供しますが、Management APIを呼び出すのは1回だけです。

**変更前**



後続のルールでユーザーメタデータを更新する必要がある場合は、Management APIを個別に呼び出す必要があるため、[レート制限](/support/policies/rate-limit-policy/management-api-endpoint-rate-limits)に達する可能性が高くなります。

**変換後**



後続のアクションでユーザーメタデータを更新する必要がある場合は、`api.user.setUserMetadata`または`api.user.setAppMetadata`を呼び出す必要があります。アクションでは、1つまたは複数のアクションにわたってこれらの関数を複数回呼び出すと、フローが完了したときに1つのManagement API呼び出しが行われます。

### 他のManagement API呼び出しを変換する

一般に、ルールやアクションなどの高トラフィックのクリティカルパスからManagement APIを呼び出すことはお勧めしません。拡張ポイントからの呼び出しを含め、すべてのAuth0 APIへの要求には[レート制限](/support/policies/rate-limit-policy)があり、すべてのログインに対してAPIを呼び出すと、トラフィックが多いときにログインが失敗する可能性があります。

ただし、呼び出しが必要で、それらがレート制限を回避するように構成されている場合は、アクション内からManagement APIを呼び出すことができます。前述の「制限事項を理解する」セクションで説明しているように、アクションにはManagement APIのアクセストークンが提供されないため、アクションを有効にする前にアクセストークンを取得する必要があります。

1. [M2Mアプリケーションを登録し、Management APIに対して認可します](/get-started/create-apps/machine-to-machine-apps)。
2. アクションに**クライアントID**と**クライアントシークレット**を保存します。
3. [Management APIのアクセストークンを取得します](/security/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)。
4. Management APIを呼び出します。

**変更前**

****

**変換後**

********

### リダイレクトを変換する

ルールは、外部ページにログインしているユーザーをリダイレクトし、応答を待つことができます。この場合、リダイレクト前のすべてのルールが2回実行されます。つまり、リダイレクト前に1回と、応答時に1回です。リダイレクトと応答のロジックは通常、同じルールに含まれます。

アクションでは、リダイレクトが発生するとアクションパイプラインが一時停止し、ユーザーが戻ると再開されます。また、エクスポートされたリダイレクトトリガー関数はリダイレクトコールバックとは別のものです。



**変更前**



**変換後**



### 現在のSSOクライアント参照を変換します

ルールの`context.sso`オブジェクトは、現在のセッションとそれを使用しているクライアントに関する詳細を提供します。詳細については、[ルールのコンテキストオブジェクトプロパティ](/rules/context-object)の`context.sso`エントリを参照してください。同様の情報は、アクションの`event.session`オブジェクトでも入手できます。

**変更前**

****

**変換後**

****

## 移行を完了する

新しいアクションコードを作成してテストしたら、アクションを有効にし、ルールを無効にする必要があります。これらの2つのタスクは連続してすばやく実行できますが、順序によっては、両方が実行されない、またはどちらも実行されない時間が短期間発生する場合があります。アクティブなルールは導入されたアクションの前に実行されるため、ルールパイプラインの最後から開始して逆方向に作業すると、アクションで他のロジックを構築およびテストするときに、一部のロジックをルールに保持したままにすることができます。