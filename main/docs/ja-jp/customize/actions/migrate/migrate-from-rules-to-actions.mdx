---
og:description: Learn how to migrate your existing Auth0 Rules code to Auth0 Actions
  code.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: RulesからActionsに移行する
og:url: https://auth0.com/docs/
permalink: migrate-from-rules-to-actions
title: RulesからActionsに移行する
twitter:description: Learn how to migrate your existing Auth0 Rules code to Auth0
  Actions code.
twitter:title: RulesからActionsに移行する
---

既存のルールをアクションに変換する場合は、新しいアクションをログインフローのログイン後(`post-login`)トリガーに関連付ける必要があります。以下の手順に従い、アクションを元のルールと同じ順序にしておくと、機能は同じになります。

## 移行を計画する

Post-Login Actions run after existing Rules, so you can either convert Rules one at a time in the Dashboard or all at once using the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip>.

コードを変換してから、アクションをアクティブにし、ルールを非アクティブにする必要があります。アクションの有効化とルールの無効化は、連続してすばやく実行できますが、順序によっては、両方が実行されない、またはどちらも実行されない時間が短期間発生する場合があります。

このため、パイプラインを段階的に移行することをお勧めします。ルールコードの一部をアクションコードに変換し、ステージング環境でテストしてから、一度に1つずつライブに移行します。アクティブなルールはデプロイされたアクションの前に実行されるため、ルールパイプラインの最後から開始して逆方向に作業すると、アクションで他のロジックを構築およびテストするときに、一部のロジックをルールに保持したままにすることができます。

<Card title="Tips when planning your migration">

* Keep your Actions and Rules 1:1, so functionality can be turned off and on in blocks and tested.
* Use flags in user metadata to avoid duplicating expensive or one-time operations.
* Start at the end of your Rules pipeline and work backwards; because active Rules run before deployed Actions, you can keep some logic in Rules as you build and test other logic in Actions.
* Make sure to run changes at a time when impact and traffic will be lowest.
* Consider temporarily [customizing your login page](/docs/customize) to halt logins if the cutover could cause invalid logins or gaps in protection.
* Consider using the [Auth0 Deploy CLI](/docs/deploy-monitor/deploy-cli-tool) to script, test, and quickly implement the migration all at once or iteratively.

</Card>

## 制限事項を理解する

アクションはルールでできることの大部分を処理できますが、移行を開始する前にいくつかの制限事項に注意する必要があります（注：フックとアクションはどちらも移行中に実行できます）。

* Actions are not provided with [an access token for the Management API](/docs/customize/rules/use-management-api) or [access to the global `auth0` object](/docs/rules-best-practices/rules-environment-best-practices) as in Rules. To learn how Management API calls can still be made, read the [Convert Code](#convert-code) section.

For the full list of limitations, see [Actions Limitations](/docs/customize/actions/limitations).

## コードを変換する

ルールをアクションに変換するには、ルール固有のコードをアクションコードに置き換える必要があります。このセクションでは、機能するルールを同等のアクションに変換するためのタスクについて説明します。

<Card title="Tips when converting code">

* In general, look for the read-only properties of Rules `user` and `context` objects on the Actions `event` object. Look for any side effects your Actions have on the system (like failing a login or updating user metadata) in the `api` object functions.
* Use the Actions Code Editor in the Auth0 Dashboard to write your code; it will help by highlighting errors and supplying auto-complete suggestions.
* Before you go live, thoroughly [test your new Actions](/docs/customize/actions/test-actions) in a [staging or test environment](/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).

</Card>

### ルールコードを新しいアクションにコピーする

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

We recommend copying your Rule code into a new Action and using the Actions Code Editor in the Auth0 Dashboard; it will help you identify outstanding issues with your code.

</Callout>

1. Log in to your production tenant, and copy the code from the Rule you want to convert.
2. Switch to a non-production tenant, and navigate to [Auth0 Dashboard > Actions > Library](https://manage.auth0.com/#/select-tenant?path=/actions/library).
3. Select **Build Custom**, then:

   * 変換するルールの名前と一致するアクションの**名前**を入力します。
   * **トリガー**を見つけて、**ログイン/ログイン**後を選択します。
   * Locate **Runtime**, and select **Node 16.**
   * **［Create（作成）］**を選択します。
4. In the code block of the Actions Code Editor, paste the Rule code you want to convert below the exported `onExecutePostLogin` function.
5. Make the changes detailed in the rest of this article as you move the code into the function.

### 関数宣言を変更する

ルールは、`ユーザー`、`コンテキス`ト、および`コールバック`パラメータを持つ単純な宣言済み関数を使用しますが、アクションは特定の名前にエクスポートされた関数を使用します。以下の変更を加えます。現在のところ、表示されるエラーは無視してください。

現在のSSOクライアント参照を変換します

```js lines
async function myRulesFunction(user, context, callback) {
    // ... additional code
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
	// ... additional code
};
```






### ルールでは、ログインするユーザーに関するデータは[`user`オブジェクト](/rules/user-object-in-rules)に保存されます。アクションでは、このデータは[`event`オブジェクト](/signup-and-login-triggers/login-trigger/post-login-event-object)の`user`プロパティにあります。既存のプロパティの大部分は、この新しい場所でアクセスできます。

In Rules, data about the user logging in is stored in the [`user` object](/docs/customize/rules/user-object-in-rules). In Actions, this data is found in the `user` property of the [`event` object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-event-object). The majority of existing properties are accessible in this new location.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Data stored or modified in properties in the `event` object are not accessible in other Actions.

</Callout>

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
	const userEmail = user.email;
	const userId = user.user_id;

	// This property could be undefined in Rules.
	const userAppMetadata = user.app_metadata || {};

	// ... additional code
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
	const userEmail = event.user.email;
	const userId = event.user.user_id;

	// This property will never be undefined in Actions.
	const userAppMetadata = event.user.app_metadata;

	// ... additional code
};
```






### 依存関係を変換する

In Rules, data about the current login session is stored in the [`context` object](/docs/customize/rules/context-object). For Actions, this data has been reshaped and moved to the [`event` object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-event-object). Many of the properties moved over as-is, but some have been combined to increase clarity.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Data stored or modified in properties in the `event` object are not accessible in other Actions. If your Rule triggers core functionality by setting data on these properties, like `context.idToken` or `context.multifactor`, please read one of the sections below that addresses your use case.

</Callout>

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
	const clientId = context.clientID;
	const clientMetadata = context.clientMetadata || {};

	const connectionId = context.connectionID;
	const connectionMetadata = context.connectionMetadata || {};

	const protocol = context.protocol;

	const tenant = context.tenant;

	// ... additional code
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
	const clientId = event.client.client_id;
	const clientMetadata = event.client.metadata;

	const connectionId = event.connection.id;
	const connectionMetadata = event.connection.metadata;

	const protocol = event.transaction.protocol;

	const tenant = event.tenant.id;

	// ... additional code
};
```






### コールバックを変換する

ルールの処理が完了したら、`callback()`関数を呼び出して、ログインに失敗した場合はエラーを渡す必要があります。逆に、アクションは成功時に返したり、ログインに失敗した場合はメッセージとともに`api`メソッドを呼び出したりできます。ルール内の`callback()`のすべてのインスタンスは削除するか、失敗した場合は`api.access.deny()`に置き換える必要があります。ルールとアクションの両方で、特定の条件で処理を停止する必要がある場合は、`return`ステートメントを使用します。

シークレットの処理を変更する

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If your `npm` modules are not on the latest version, this is a great time to get up to date!

</Callout>

1. Search for `require` statements inside your Rule code.
2. Remove version numbers, but make a note of them.
3. Add the dependency by following the steps in the "Add a Dependency" section of [Write Your First Action](/docs/customize/actions/write-your-first-action) (if the dependency is not a [core NodeJS module](https://github.com/nodejs/node/tree/master/lib); if the dependency is a core NodeJS module, you do not need to include it).
4. Move the found `require` statements outside of the `function` declaration:

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
	const dependency = require("dependency@1.2.3");

	// ... additional code
}
```






**After**

```javascript lines
const dependency = require("dependency"); // v1.2.3
exports.onExecutePostLogin = async (event, api) => {
	// ... additional code
};
```






### シークレットをルールからアクションに変換するには：

ルールの場合と同様に、Auth0は保管時のすべてのシークレット値を暗号化します。

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
	const userAppMetadata = user.app_metadata || {};
	if (userAppMetadata.condition === "success") {
		// This Rule succeeded, proceed with next Rule.
		return callback(null, user, context);
	}

	if (userAppMetadata.condition === "failure") {
		// This Rule failed, stop the login with an error response.
		return callback(new Error("Failure message"));
	}

	// ... additional code
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
	if (event.user.app_metadata.condition === "success") {
		// This Action succeeded, proceed with next Action.
		return;
	}

	if (event.user.app_metadata.condition === "failure") {
		// This Action failed, stop the login with an error response.
		return api.access.deny("Failure message");
	}

	// ... additional code
};
```






### ルールとアクションでは共に、カスタムクレームをIDトークンおよびアクセストークンに追加できます。ルールでは、これは`context`オブジェクトのプロパティですが、アクションでは[`api`オブジェクト](/signup-and-login-triggers/login-trigger/post-login-api-object)のメソッドが使用されます。

In Rules, you set configuration values globally, which means that all Rules can access all secret values. (To learn more, read [Store Rule Configurations](/docs/customize/rules/configuration).) In Actions, you set configuration values for each individual Action. You can't access an Action's secret value from outside the context of the Action.

ルールでは、[`context`オブジェクト](/rules/context-object)の`multifactor`プロパティを変更することで、多要素認証をトリガーできます。アクションでは、これは[`api`オブジェクトのメソッド](/signup-and-login-triggers/login-trigger/post-login-api-object)を使用して実行されます。

1. Save the values needed for the specific Action you are working on.
2. Add a Secret for each value you need to access from inside the Action. To learn how, read the **Add a Secret** section in [Write Your First Action](/docs/customize/actions/write-your-first-action).
3. Convert your code:

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction (user, context, callback) {
  const { CLIENT_ID, CLIENT_SECRET } = configuration;

  // ... additional code
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
  const { CLIENT_ID, CLIENT_SECRET } = event.secrets;

  // ... additional code
}
```






ルール内の`user_metadata`プロパティと`app_metadata`プロパティを更新するには、Management APIの呼び出しが必要であり、[レート制限](/support/policies/rate-limit-policy/management-api-endpoint-rate-limits)エラーが発生する可能性があります。ただし、アクションは複数のユーザーメタデータの変更を示す方法を提供しますが、Management APIを呼び出すのは1回だけです。

### 後続のルールでユーザーメタデータを更新する必要がある場合は、Management APIを個別に呼び出す必要があるため、[レート制限](/support/policies/rate-limit-policy/management-api-endpoint-rate-limits)に達する可能性が高くなります。

Rules and Actions can both add custom claims to ID and <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip>. In Rules, this is a property of the `context` object, while Actions uses a method on the [`api` object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-api-object).

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
	const userAppMetadata = user.app_metadata || {};
	const namespace = "https://namespace/";

	context.idToken[`${namespace}/emp_id`] = userAppMetadata.emp_id;
	context.accessToken[`${namespace}/emp_id`] = userAppMetadata.emp_id;

	// ... additional code
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
	const namespace = "https://namespace/";

	api.idToken.setCustomClaim(
		`${namespace}/emp_id`, 
		event.user.app_metadata.emp_id
	); 		   

	api.accessToken.setCustomClaim(
		`${namespace}/emp_id`, 
		event.user.app_metadata.emp_id
	);

	// ... additional code
};
```






### 一般に、ルールやアクションなどの高トラフィックのクリティカルパスからManagement APIを呼び出すことはお勧めしません。拡張ポイントからの呼び出しを含め、すべてのAuth0 APIへの要求には[レート制限](/support/policies/rate-limit-policy)があり、すべてのログインに対してAPIを呼び出すと、トラフィックが多いときにログインが失敗する可能性があります。

In Rules, <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=multi-factor+authentication">multi-factor authentication</Tooltip> can be triggered by modifying the `multifactor` property of the [`context` object](/docs/customize/rules/context-object). In Actions, this is done with a [method on the `api` object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-api-object).

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
	if (user.app_metadata.needs_mfa === true) {
		context.multifactor = { 
			provider: "any", 
			allowRememberBrowser: false,
		};
	}

	// ... additional code
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
	if (event.user.app_metadata.needs_mfa === true) {
		api.multifactor.enable("any", { allowRememberBrowser: false });
	}

	// ... additional code
};
```






### ルールは、外部ページにログインしているユーザーをリダイレクトし、応答を待つことができます。この場合、リダイレクト前のすべてのルールが2回実行されます。つまり、リダイレクト前に1回と、応答時に1回です。リダイレクトと応答のロジックは通常、同じルールに含まれます。

Updating the `user_metadata` and `app_metadata` properties in Rules requires a call to the Management API, which can lead to [rate limit](/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/management-api-endpoint-rate-limits) errors. Actions, however, provides a way to indicate multiple user metadata changes but only call the Management API once.

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
	user.app_metadata = user.app_metadata || {}; 
	user.app_metadata.roles = user.app_metadata.roles || [];
	user.app_metadata.roles.push("administrator"); 

	auth0.users
		.updateAppMetadata(user.user_id, user.app_metadata) 
		.then(() => callback(null, user, context))
		.catch((err) => callback(err));

	// ... additional code
}
```






If subsequent Rules need to update the user metadata, then they would have to call the Management API separately, making it more likely that you would hit the [rate limit](/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/management-api-endpoint-rate-limits).

**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
	const userRolesUpdated = event.user.app_metadata.roles || [];
	userRolesUpdated.push("administrator"); 

	// Note the two different methods here. 
	api.user.setAppMetadata("roles", userRolesUpdated);
	api.user.setUserMetadata("hasRoles", true);

	// ... additional code
};
```






移行を完了する

### 新しいアクションコードを作成してテストしたら、アクションを有効にし、ルールを無効にする必要があります。これらの2つのタスクは連続してすばやく実行できますが、順序によっては、両方が実行されない、またはどちらも実行されない時間が短期間発生する場合があります。アクティブなルールは導入されたアクションの前に実行されるため、ルールパイプラインの最後から開始して逆方向に作業すると、アクションで他のロジックを構築およびテストするときに、一部のロジックをルールに保持したままにすることができます。

In general, we do not recommend calling the Management API from a high-traffic, critical path like Rules or Actions. Requests to all Auth0 APIs are [rate limited](/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy), including calls from extensibility points, and calling an API for all logins could easily result in failed logins at high-traffic times.

However, If the calls are necessary and are configured to avoid rate limits, it's possible to call the Management API from within Actions. As mentioned in the "Understand limitations" section earlier in this article, Actions are not provided with an access token for the Management API, so you will need to get an access token before activating your Action:

1. [Register a Machine-to-Machine application and authorize it for the Management API](/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).
2. Save the **Client ID** and **Client Secret** in the Action.
3. [Get an access token for the Management API](/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production).
4. Call the Management API:

   <Warning>

   Actions cannot persist data across executions, so it's not possible to cache the access token for any length of time; because every Management API call also requires an Authentication API call, calling the Management API is a very expensive operation.

   </Warning>

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
	const ManagementClient = require("auth0@2.9.1").ManagementClient; 
	const managementClientInstance = new ManagementClient({
		// These come from built-in Rules globals
		token: auth0.accessToken, 
		domain: auth0.domain,
	}); 

	managementClientInstance.users.assignRoles(
		{ id: user.user_id }, 
		{ roles: ["ROLE_ID_TO_ADD"] }, 
		(error, user) => {
			if (error) {
				return callback(error);
			}

			// ... additional code
		}
	);
}
```






**After**

```javascript lines
const auth0Sdk = require("auth0");
exports.onExecutePostLogin = async (event, api) => {
	const ManagementClient = auth0Sdk.ManagementClient;

	// This will make an Authentication API call
	const managementClientInstance = new ManagementClient({
		// These come from a machine-to-machine application
		domain: event.secrets.M2M_DOMAIN,
		clientId: event.secrets.M2M_CLIENT_ID,
		clientSecret: event.secrets.M2M_CLIENT_SECRET,
		scope: "update:users"
	});

	managementClientInstance.users.assignRoles(
		{ id: event.user.user_id }, 
		{ roles: ["ROLE_ID_TO_ADD"]}, 
		(error, user) => {
			if (error) {
				return api.access.deny(error.message);
			}

			// ... additional code
		}
	);
};
```






### Convert redirects

Rules can redirect a user who is logging in to an external page, then wait for a response. In this case, all Rules before the redirection will run twice--once before the redirect and once on the response. The logic for the redirect and the response are typically contained in the same Rule.

In Actions, the Action pipeline is paused when the redirect happens and picks up once the user returns. Also, the exported redirect triggering function is separate from the redirect callback.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Doing all redirects correctly in Actions is beyond the scope of this guide. For more detailed information, read [Redirect with Actions](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/redirect-with-actions).

</Callout>

現在のSSOクライアント参照を変換します

```javascript lines
function myRulesFunction(user, context, callback) {
    if (context.protocol === "redirect-callback") {
        // User was redirected to the /continue endpoint
        user.app_metadata.wasRedirected = true;
        return callback(null, user, context);
    } else if (
        context.protocol === "oauth2-password" ||
        context.protocol === "oauth2-refresh-token" ||
        context.protocol === "oauth2-resource-owner"
    ) {
        // User cannot be redirected
        return callback(null, user, context);
    }
    // User is logging in directly
    if (!user.app_metadata.wasRedirected) {
        context.redirect = {
            url: "https://example.com",
        };
        callback(null, user, context);
    }
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
    api.accessToken.setClaim("https://dev.TLD/wasRedirected", true)
```






### Convert current SSO clients references

The Rules `context.sso` object provides details about the current session and clients using it. For more information, see the `context.sso` entry in [Context Object Properties in Rules](/docs/customize/rules/context-object). Similar information is available in the Actions `event.session` object.

現在のSSOクライアント参照を変換します

```javascript lines
function (user, context, callback) {

  const clients = context.sso?.current_clients ?? []; 

  if (clients.length > 0) { 
	context.idToken.clients = clients.join(" "); 
  }

  return callback(null, user, context);
}
```






**After**

```js lines
exports.onExecutePostLogin = async (event, api) => {
  const clients = event?.session?.clients ?? []; 

  if (clients.length > 0) { 
    api.idToken.setCustomClaim('clients', clients.map(c=> c?.client_id).join(" ")); 
  }
};
```






## Complete the migration

Once your new Actions code has been written and tested, you must activate the Action and deactivate the Rule. These two tasks can be done quickly in succession, but depending on the order, there might be a short period of time where either both or neither are running. Because active Rules run before deployed Actions, if you start at the end of your Rules pipeline and work backwards, you can keep some logic in Rules as you build and test other logic in Actions.