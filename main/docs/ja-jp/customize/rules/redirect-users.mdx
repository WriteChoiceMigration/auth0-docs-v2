---
og:description: Learn how to customize authentication flows by redirecting users using
  rules. Example areas that can be customized include MFA, privacy policy acceptance,
  and gathering user data.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: ルール内でユーザーをリダイレクトする
og:url: https://auth0.com/docs/
permalink: redirect-users
title: ルール内でユーザーをリダイレクトする
twitter:description: Learn how to customize authentication flows by redirecting users
  using rules. Example areas that can be customized include MFA, privacy policy acceptance,
  and gathering user data.
twitter:title: ルール内でユーザーをリダイレクトする
---

<Warning>

The End of Life (EOL) date of Rules and Hooks will be **November 18, 2026**, and they are no longer available to new tenants created as of **October 16, 2023**. Existing tenants with active Hooks will retain Hooks product access through end of life.

We highly recommend that you use Actions to extend Auth0. With Actions, you have access to rich type information, inline documentation, and public `npm` packages, and can connect external integrations that enhance your overall extensibility experience. To learn more about what Actions offer, read [Understand How Auth0 Actions Work](/docs/customize/actions/actions-overview).

To help with your migration, we offer guides that will help you [migrate from Rules to Actions](/docs/customize/actions/migrate/migrate-from-rules-to-actions) and [migrate from Hooks to Actions](/docs/customize/actions/migrate/migrate-from-hooks-to-actions). We also have a dedicated [Move to Actions](https://auth0.com/extensibility/movetoactions) page that highlights feature comparisons, [an Actions demo](https://www.youtube.com/watch?v=UesFSY1klrI), and other resources to help you on your migration journey.

To read more about the Rules and Hooks deprecation, read our blog post: [Preparing for Rules and Hooks End of Life](https://auth0.com/blog/preparing-for-rules-and-hooks-end-of-life/).

</Warning>

You can use [Auth0 Rules](/docs/customize/rules) to redirect users before an authentication transaction is complete. This lets you implement custom authentication flows that require additional user interaction beyond the standard login form. Redirect rules are commonly used to do custom <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=Multi-factor+Authentication">Multi-factor Authentication</Tooltip> (MFA) in Auth0, but they can also be used for:

* カスタムのプライバシーポリシーへの同意、利用規約、データ開示のフォーム。
* 追加で必要なプロファイルデータを安全に一度だけ収集する。
* Active Directoryのリモートユーザーがパスワードを変更できるようにする。
* ユーザーが未知の場所からログインする際に、追加で検証を求める。
* サインアップ時にユーザーが提供した以上のユーザー情報を集める。

認証フローごとに、ユーザーを**1回**リダイレクトできます。ユーザーをリダイレクトするルールが1つある場合、後でユーザーをリダイレクトする2つ目のルールを呼び出すことは**できません**。

To learn more, see [Multi-Factor Authentication in Auth0](/docs/secure/multi-factor-authentication).

## リダイレクトを開始して認証を再開する

すべてのルールの実行が完了したら、Auth0は`context.redirect.url`プロパティで指定されたURLにユーザーをリダイレクトします。また、Auth0はそのURLで`state`パラメーターも渡します。例：

```javascript lines
function (user, context, callback) {
  context.redirect = {
    url: "https://example.com/foo"
  };
  return callback(null, user, context);
}
```






認証トランザクションを再開するには、リダイレクトURLが`state`パラメーターを抽出し、それをAuth0に送り返す必要があります。状態は不透明な値で、[クロスサイトリクエストフォージェリ（CSRF）攻撃](/security/common-threats#cross-site-request-forgery)を防ぐために使用されます。

```http lines
https://example.com/foo?state=abc123
```






Your redirect URL needs to extract the `state` parameter and send it back to Auth0 to resume the authentication transaction. State is an opaque value, used to prevent [Cross-Site Request Forgery (CSRF) attacks](/docs/secure/security-guidance/prevent-threats#cross-site-request-forgery).

カスタムドメインを使用している場合：

ユーザーが`/continue`エンドポイントにリダイレクトされた場合：

```http lines
https://{yourDomain}/continue?state={originalState}
```






If you're using a <Tooltip tip="Custom Domain: Third-party domain with a specialized, or vanity, name." cta="View Glossary" href="/docs/glossary?term=custom+domain">custom domain</Tooltip>:

```http lines
https://{yourAuth0CustomDomain}/continue?state={originalState}
```






`THE_ORIGINAL_STATE` is the value that Auth0 generated and sent to the redirect URL. For example, if your rule redirected to `https://example.com/foo`, Auth0 would use a redirect URL similar to `https://example.com/foo?state=abc123`. So `abc123` would be the `THE_ORIGINAL_STATE`. To resume the authentication transaction, you would redirect to:

```http lines
https://{yourDomain}/continue?state=abc123
```






ユーザーオブジェクトへの変更は、`/continue` エンドポイントを呼び出す前のリダイレクト中に行われます。たとえば、Auth0 Management APIを介した更新は、トランザクションの続行後に使用できます。

* 再開したログインを確認する
* any changes to the user object are made during the redirect, prior to calling the `/continue` endpoint. For example, updates through the Auth0 <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> are available after continuing the transaction.

## パスワード変更の強制の例

特定の条件下で、ユーザーにパスワード変更を強制する場合、次の動作のルールを作成できます。

```javascript lines
function (user, context, callback) {
    if (context.protocol === "redirect-callback") {
        // User was redirected to the /continue endpoint
    } else {
        // User is logging in directly
    }
}
```






## データの保管場所

Auth0のプロファイルに保管するデータは多すぎないようにします。このデータは認証および認可の目的で使用されるものです。Auth0のメタデータと検索機能は、市場調査や高い検索・更新の頻度が必要なものを想定して設計されていません。Auth0をそのような目的で使用すると、ほぼ確実にシステムの拡張性や性能に問題が生じます。データを外部システムに保管して、Auth0にポインター（ユーザーID）を保管した方が、バックエンドシステムが必要に応じてデータを取得できます。従うべきルールはシンプルです。トークンに追加したり決定したりするためにルールで使用する予定のアイテムだけを保管します。

1. The user attempts to log in and needs to change their password.
2. The user is redirected to an application-specific page with a JWT in the query string. This JWT ensures that only this user's password can be changed and **must be validated** by the application.
3. The user changes their password in the application-specific page by having the application call the [Auth0 Management API](https://auth0.com/docs/api/v2#!/Users/patch_users_by_id)
4. Once the user has successfully changed their password, the application extracts the `authorize_again` claim from the verified and decoded JWT, then proceeds to redirect the user to that URL allowing them to sign in with their new password.

```javascript lines expandable
function(user, context, callback) {
   /*
   * Prerequisites:
   * 1. Implement a `mustChangePassword` function
   * 2. Set configuration variables for the following:
   *    - CLIENT_ID
   *    - CLIENT_SECRET
   *    - ISSUER
   */

  const url = require('url@0.10.3');
  const req = context.request;

  function mustChangePassword() {
    // TODO: implement function
    return true;
  }

  if (mustChangePassword()) {
    // User has initiated a login and is forced to change their password
    // Send user's information and query params in a JWT to avoid tampering
    function createToken(clientId, clientSecret, issuer, user) {
      const options = {
        expiresInMinutes: 5,
        audience: clientId,
        issuer: issuer
      };
      return jwt.sign(user, clientSecret, options);
    }

    const token = createToken(
      configuration.CLIENT_ID,
      configuration.CLIENT_SECRET,
      configuration.ISSUER,
      {
        sub: user.user_id,
        email: user.email,
        authorize_again: url.format({
          protocol: 'https',
          hostname: auth0.com,
          pathname: '/authorize',
          query: req.query
        })
      }
    );

    context.redirect = {
      url: `https://example.com/change-pw?token=${token}`
    };
  }

  return callback(null, user, context);
}
```






## セキュリティに関する考慮事項

情報をフロントチャネルでやり取りすると、悪意のある行為者の攻撃対象になる領域を広げることになります。これは必ず、ルールで対処しなければならない場合（`UnauthorizedError`での認可試行の拒否など）にのみ行う必要があります。

## ただし、直接Auth0に通信を返し、アクセスを制限する指示を与える必要がある場合（CAPTCHA認証やカスタムMFAを実装する場合など）には、その操作の要件が実行されたことをAuth0に安全に伝える方法を確保する必要があります。同様に、リダイレクト先のアプリケーションに情報を渡す必要がある場合、転送された情報が改ざんされていないことを保証する安全な方法を確保する必要があります。

Passing information back and forth in the front channel opens up surface area for <Tooltip tip="Bad Actors: Entity (a person or group) that poses a threat to the business or environment with the intention to cause harm." cta="View Glossary" href="/docs/glossary?term=bad+actors">bad actors</Tooltip> to attack. This should definitely be done only in conditions where you must take action in the rule (such as rejecting the authorization attempt with `UnauthorizedError`).

If, however, you need to communicate directly back to Auth0 and give it instructions for restricting access (you are implementing CAPTCHA checks or custom MFA), then you must have a way to securely tell Auth0 that the requirements of that operation were performed. Likewise, if you need to hand information to the application that you are redirecting to, then you must have a secure way to ensure that the information transferred has not been tampered with.

### アプリに送信されるトークンには、次の要件があります。

The application is going to redirect the user back to the Auth0 tenant, so any data related to the user can be gathered through the <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+token">ID token</Tooltip> that is returned to the application. However, you may want to ensure that the application is logging into the same user that is being redirected from to ensure that there is no tampering of any sort in-between. Therefore you will likely want to send a token along with the request.

大半のシナリオでは、ルールからアプリケーションに情報を渡します。アプリケーションは、必要なストレージにかかわらず、情報を安全に保管できるはずです。アプリやユーザーメタデータをAuth0で更新することが目的であっても、Management APIを使用できます。ユーザー情報の更新は、ユーザーを`/continue`エンドポイントにリダイレクトで戻す前に更新が完了する限り、達成されます。ルール自体が情報を取得する必要があり、その情報がこの特定のサインインだけに関連する場合にのみ、セッションが情報をルールに戻すようにします。

<table class="table"><thead>
<tr>
<th>Token Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sub</code></td>
<td>The Auth0 <code>user_id</code> of the user.</td>
</tr>
<tr>
<td><code>iss</code></td>
<td>An identifier that identifies the rule itself.</td>
</tr>
<tr>
<td><code>aud</code></td>
<td>The application that is targeted for the redirect.</td>
</tr>
<tr>
<td><code>jti</code></td>
<td>A randomly generated string that is stored for confirmation in the user object (in the rule code, set user.jti = uuid.v4(); and then add it as a jti to the token you create).  user.jti will still be set when rules run again when /continue is called.  This is inline with specifications.</td>
</tr>
<tr>
<td><code>exp</code></td>
<td>Should be as short as possible to avoid re-use of the token.</td>
</tr>
<tr>
<td><code>other</code></td>
<td>Any other custom claims information you need to pass.</td>
</tr>
<tr>
<td><code>signature</code></td>
<td>Assuming that the application has a secure place to store a secret, you can use HS256 signed signatures.  This greatly reduces the complexity of the solution and since the token being passed back will have to be signed as well, this is a requirement of this solution.  You can use RS256, but it requires the creating of a certificate and updating that certificate when it expires.  If you are not passing any information directly back to the rules, then you could use an SPA for this intermediate app and then may prefer RS256 so that the application doesn't have to store the info.  It would require you to have a way to validate the token, either through an introspection endpoint or through a public JWKS endpoint.</td>
</tr>
</tbody>
</table>

<Warning>

This token should **not** be treated as a Bearer token! It is a signed piece of information for use in the application. The application should still redirect back to Auth0 to authenticate the user.

</Warning>

### クエリパラメーターとして渡すのではなく、POSTを使用して送信し、`context.request.body.token`（または類似のもの）で取得する必要があります。これは、認証のform-postメソッドに似ています。

In most scenarios, even if you want to pass information from the rule to the application. The application will hopefully be able to safely store the information in whatever storage is necessary. Even if the idea is to update the app or user metadata in Auth0, that can be done using the management API and the user information will be updated as long as it has been completed before redirecting the user back to the `/continue` endpoint. Only if the rule itself must get information and that information is only relevant to this particular sign in session should you pass information back to the rule.

リダイレクトルールは、以下では動作しません。

<table class="table"><thead>
<tr>
<th>Token Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sub</code></td>
<td>The Auth0 <code>user_id</code> of the user.</td>
</tr>
<tr>
<td><code>iss</code></td>
<td>The application that is targeted for the redirect.</td>
</tr>
<tr>
<td><code>aud</code></td>
<td>Some identifier that identifies the rule itself.</td>
</tr>
<tr>
<td><code>jti</code></td>
<td>The same JTI that was stored in the token passed to the application (NOTE: it should match user.jti or fail).</td>
</tr>
<tr>
<td><code>exp</code></td>
<td>Should be as short as possible to avoid reuse of the token.</td>
</tr>
<tr>
<td><code>other</code></td>
<td>Any other custom claims information you need to pass.</td>
</tr>
<tr>
<td><code>signature</code></td>
<td>Assuming that the application has a secure place to store a secret, you can use HS256 signed signatures.  This greatly reduces the complexity of the solution and since the token being passed back will have to be signed as well, this is a requirement of this solution.  You can use RS256, but it requires the creating of a certificate and updating that certificate when it expires.</td>
</tr>
</tbody>
</table>

It should be sent using POST and then fetched at `context.request.body.token` (or something similar) rather than passing it as a query parameter. This is similar to the form-post method for authentication.

[パスワードの交換](/login/flows/resource-owner-password-flow)

## [リフレッシュトークンの交換](/security/tokens/refresh-tokens)

パスワードの交換：`context.protocol === 'oauth2-password'`

* [Resource Owner endpoint](https://auth0.com/docs/api/authentication/reference#resource-owner)
* [Password exchange](/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)
* [Refresh Token exchange](/docs/secure/tokens/refresh-tokens)

リダイレクトルールのセッションは、**［Login Session Management（ログインセッションの管理）］**設定でより短いタイムアウトを設定した場合を除き、通常3日間有効です。これらの設定は、[テナントの高度な設定](%24%7Bmanage_url%7D/#/tenant/advanced)で確認できます。

* リソース所有者 のエンドポイント
* For <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+Token">Refresh Token</Tooltip> exchange: `context.protocol === 'oauth2-refresh-token'`
* For <Tooltip tip="Resource Owner: Entity (such as a user or application) capable of granting access to a protected resource." cta="View Glossary" href="/docs/glossary?term=Resource+Owner">Resource Owner</Tooltip> logins: `context.protocol === 'oauth2-resource-owner'`

### リフレッシュトークン

Redirect rule sessions are normally valid for 3 days unless you have configured a shorter timeout in your **Login Session Management** settings. You can find these settings in your [tenant's advanced settings](https://manage.auth0.com/#/tenant/advanced).

### ログインに関するどのような制約も、適用されたかを安全に検証することは困難です。MFAチャレンジに成功したユーザーなど、セッションに関する情報を集めるのに使用可能なコンテキストでは、恒常的なセッションIDはありません。そのため、`prompt=none`はまったく使用できません。

It is impossible to use redirect rules in the context where you are calling `/oauth/token` directly for the Resource Owner Password Grant. Since the user is not in a redirect flow to begin with, you can not redirect the user in a rule. If you attempt to set context.redirect you will get a failed login attempt with the error interaction_required.

### Flows where prompt=none

Since the goal of `prompt=none` is to avoid any scenario where the user will be required to enter input, any redirection will result in an `error=interaction_required`.

Since rules run after an authentication session is created, you cannot use `prompt=none` if you have a redirect rule that is attempting to block access to tokens under certain conditions (custom MFA, CAPTCHA with login, etc.).

You cannot create a redirect flow that blocks token access and bypasses the redirect rule if `prompt=none` because after a failed attempt, a user can simply call again with `prompt=none` and get tokens because their authentication session has been created even though rules failed the first time.

### Refresh tokens

Due to the fact that using a refresh token requires a backchannel call to `/oauth/token`, this will also fail if you set `context.redirect`.

It is difficult to securely verify that any restrictions on login were carried out. There is not a consistent session ID in the context that could be used to collect information associated with the session such as this user passed MFA challenges. Therefore, you cannot use `prompt=none` at all.

Anytime `context.redirect` is set in a rule, if `prompt=none` was passed, then the authorization fails with `error=interaction_required`, but since the user's session is created even if rules fail, we can't trust that a user passed all `context.redirect` challenges and therefore can't use `prompt=none` as a way to get tokens.

In this specific case, we recommend that you use refresh tokens exclusively, because you can ensure that a user passed challenges if those challenges are required to generate a refresh token.

## Learn more

* [Redirect Users](/docs/authenticate/login/redirect-users-after-login)
* [Understand How Progressive Profiling Works](/docs/manage-users/user-accounts/user-profiles/progressive-profiling)
* [Redirect Users with Alternative Logout](/docs/authenticate/login/logout/redirect-users-after-logout)