---
og:description: Learn how to customize authentication flows by redirecting users using
  rules. Example areas that can be customized include MFA, privacy policy acceptance,
  and gathering user data.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: ルール内でユーザーをリダイレクトする
og:url: https://auth0.com/docs/
permalink: redirect-users
title: ルール内でユーザーをリダイレクトする
twitter:description: Learn how to customize authentication flows by redirecting users
  using rules. Example areas that can be customized include MFA, privacy policy acceptance,
  and gathering user data.
twitter:title: ルール内でユーザーをリダイレクトする
---



認証トランザクションの完了前に、 [Auth0ルール](/rules)を使用してユーザーをリダイレクトすることができます。これによって、カスタム認証フローを実装して、標準のログインフォームにはない追加のユーザー操作に対応できるようになります。リダイレクトルールは一般的に、Auth0でカスタムの多要素認証（MFA）を実行するために使用されますが、以下にも使用できます。

* カスタムのプライバシーポリシーへの同意、利用規約、データ開示のフォーム。
* 追加で必要なプロファイルデータを安全に一度だけ収集する。
* Active Directoryのリモートユーザーがパスワードを変更できるようにする。
* ユーザーが未知の場所からログインする際に、追加で検証を求める。
* サインアップ時にユーザーが提供した以上のユーザー情報を集める。

認証フローごとに、ユーザーを**1回**リダイレクトできます。ユーザーをリダイレクトするルールが1つある場合、後でユーザーをリダイレクトする2つ目のルールを呼び出すことは**できません**。

詳細については、「[Auth0での多要素認証](/mfa)」をご覧ください。

## リダイレクトを開始して認証を再開する

`context.redirect`プロパティを以下のように設定します。



すべてのルールの実行が完了したら、Auth0は`context.redirect.url`プロパティで指定されたURLにユーザーをリダイレクトします。また、Auth0はそのURLで`state`パラメーターも渡します。例：



認証トランザクションを再開するには、リダイレクトURLが`state`パラメーターを抽出し、それをAuth0に送り返す必要があります。状態は不透明な値で、[クロスサイトリクエストフォージェリ（CSRF）攻撃](/security/common-threats#cross-site-request-forgery)を防ぐために使用されます。

リダイレクト後、ユーザーを`/continue`エンドポイントにリダイレクトして認証を再開し、受け取った`state`パラメーターをURLに含めます。元の状態を`/continue`エンドポイントに送り返さない場合、Auth0はログイントランザクションのコンテキストを失うことになり、ユーザーは`invalid_request`エラーのためにログインできなくなります。

例：



カスタムドメインを使用している場合：



`THE_ORIGINAL_STATE`はAuth0が生成した値で、リダイレクトURLに送信されます。たとえば、ルールが`https://example.com/foo`にリダイレクトする場合、Auth0は`https://example.com/foo?state=abc123`に類似したリダイレクトURLを使用します。つまり、`abc123`が`THE_ORIGINAL_STATE`です。認証トランザクションを再開するには、以下にリダイレクトします。



ユーザーが`/continue`エンドポイントにリダイレクトされた場合：

* **すべてのルールが再度実行されます**が、`context.redirect`は無視され、認証を続行することができます。
* ユーザーオブジェクトへの変更は、`/continue` エンドポイントを呼び出す前のリダイレクト中に行われます。たとえば、Auth0 Management APIを介した更新は、トランザクションの続行後に使用できます。

## 再開したログインを確認する

ユーザーが開始したログインと再開したログインのフローを区別するには、`context.protocol`を確認します。



## パスワード変更の強制の例

特定の条件下で、ユーザーにパスワード変更を強制する場合、次の動作のルールを作成できます。

1. ユーザーがログインを試み、パスワードを変更する必要がある。
2. クエリ文字列にJWTがあるアプリケーション固有のページにユーザーがリダイレクトされる。このJWTにより、このユーザーのパスワードだけが変更でき、アプリケーションによって**検証されなければならない**ことが保証される。
3. アプリケーションが[Auth0 Management API](/api/v2#!/Users/patch_users_by_id)
4. ユーザーがパスワードを変更したら、アプリケーションは検証済みのデコードされたJWTから`authorize_again`クレームを抽出し、そのURLにユーザーをリダイレクトして、新しいパスワードでサインインできるようにする。



## データの保管場所

Auth0のプロファイルに保管するデータは多すぎないようにします。このデータは認証および認可の目的で使用されるものです。Auth0のメタデータと検索機能は、市場調査や高い検索・更新の頻度が必要なものを想定して設計されていません。Auth0をそのような目的で使用すると、ほぼ確実にシステムの拡張性や性能に問題が生じます。データを外部システムに保管して、Auth0にポインター（ユーザーID）を保管した方が、バックエンドシステムが必要に応じてデータを取得できます。従うべきルールはシンプルです。トークンに追加したり決定したりするためにルールで使用する予定のアイテムだけを保管します。

## セキュリティに関する考慮事項

情報をフロントチャネルでやり取りすると、悪意のある行為者の攻撃対象になる領域を広げることになります。これは必ず、ルールで対処しなければならない場合（`UnauthorizedError`での認可試行の拒否など）にのみ行う必要があります。

ただし、直接Auth0に通信を返し、アクセスを制限する指示を与える必要がある場合（CAPTCHA認証やカスタムMFAを実装する場合など）には、その操作の要件が実行されたことをAuth0に安全に伝える方法を確保する必要があります。同様に、リダイレクト先のアプリケーションに情報を渡す必要がある場合、転送された情報が改ざんされていないことを保証する安全な方法を確保する必要があります。

### アプリが確実に同じユーザーにログインするようにする

アプリケーションは、ユーザーをリダイレクトしてAuth0テナントに戻します。そのため、そのユーザーに関連するあらゆるデータを、アプリケーションに戻されるIDトークンを介して収集することができます。ただし、その間にいかなる改ざんも行われていないことを保証するため、リダイレクト元と同じユーザーにアプリケーションが確実にログインする必要があります。そのため、要求と一緒にトークンを送信する必要があるかもしれません。

アプリに送信されるトークンには、次の要件があります。





### 情報をルールへ戻す

大半のシナリオでは、ルールからアプリケーションに情報を渡します。アプリケーションは、必要なストレージにかかわらず、情報を安全に保管できるはずです。アプリやユーザーメタデータをAuth0で更新することが目的であっても、Management APIを使用できます。ユーザー情報の更新は、ユーザーを`/continue`エンドポイントにリダイレクトで戻す前に更新が完了する限り、達成されます。ルール自体が情報を取得する必要があり、その情報がこの特定のサインインだけに関連する場合にのみ、セッションが情報をルールに戻すようにします。

`/continue`エンドポイントに情報を戻す際、渡されるトークンは次の要件に従う必要があります。



クエリパラメーターとして渡すのではなく、POSTを使用して送信し、`context.request.body.token`（または類似のもの）で取得する必要があります。これは、認証のform-postメソッドに似ています。

`/continue`エンドポイントに情報を戻さないのであれば、有効期間が短く、リプレー攻撃がほぼ不可能な場合を除き、 JTIを拒否リストに登録することをお勧めします。

## 制約と制限

リダイレクトルールは、以下では動作しません。

* [リソース所有者 のエンドポイント](/api/authentication/reference#resource-owner)
* [パスワードの交換](/login/flows/resource-owner-password-flow)
* [リフレッシュトークンの交換](/security/tokens/refresh-tokens)

`context.protocol`を確認することで、上記のケースを検出できます。

* パスワードの交換：`context.protocol === 'oauth2-password'`
* リフレッシュトークンの交換：`context.protocol === 'oauth2-refresh-token'`
* リソースオーナーのログイン：`context.protocol === 'oauth2-resource-owner'`

### セッションタイムアウト

リダイレクトルールのセッションは、**［Login Session Management（ログインセッションの管理）］**設定でより短いタイムアウトを設定した場合を除き、通常3日間有効です。これらの設定は、[テナントの高度な設定](%24%7Bmanage_url%7D/#/tenant/advanced)で確認できます。

### リソース所有者 のエンドポイント

`/oauth/token`をリソース所有者のパスワード付与で直接呼び出す場合、リダイレクトルールを使用することはできません。そもそもユーザーがリダイレクトフローにいないため、ルールでユーザーをリダイレクトすることはできません。context.redirectを設定しようと試みると、ログイン試行は失敗し、interaction_requiredエラーになります。

### `prompt=none`の場合のフロー

`prompt=none`は、ユーザーが入力を求められるシナリオを避けることを目的としているため、あらゆるリダイレクトの結果は`error=interaction_required`になります。

ルールは認証セッションの作成後に実行されるため、特定の条件（カスタムMFA、ログインでのCAPTCHAなど）でトークンへのアクセスを阻止しようとするリダイレクトルールがある場合、`prompt=none`は使用できません。

`prompt=none`の場合、トークンへのアクセスを阻止し、リダイレクトルールをバイパスするリダイレクトフローは作成できません。これは、最初の実行でルールが失敗してもユーザーの認証セッションが作成されるため、試行が失敗すると、ユーザーが`prompt=none`で再び呼び出してトークンを取得できるからです。

### リフレッシュトークン

リフレッシュトークンの使用には`/oauth/token`へのバックチャネル呼び出しが必要なため、`context.redirect`を設定した場合、これも失敗します。

ログインに関するどのような制約も、適用されたかを安全に検証することは困難です。MFAチャレンジに成功したユーザーなど、セッションに関する情報を集めるのに使用可能なコンテキストでは、恒常的なセッションIDはありません。そのため、`prompt=none`はまったく使用できません。

ルールに`context.redirect` が設定されている場合は常に、`prompt=none`が渡された場合、認可は`error=interaction_required`で失敗します。ところが、ルールが失敗の場合でもユーザーのセッションは作成されるため、ユーザーがすべての`context.redirect`チャレンジを渡したことを信頼できません。そのため、トークンの取得方法として`prompt=none`は使用できません。

この特有なケースには、リフレッシュトークンの排他的な使用をお勧めします。リフレッシュトークンの生成にチャレンジが必要な場合に、ユーザーがチャレンジに成功したことを確認できるからです。