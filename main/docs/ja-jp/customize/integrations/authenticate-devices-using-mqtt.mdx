---
og:description: How to authenticate and authorize devices using MQTT with Auth0.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Auth0でのMQTTによるデバイスの認証と認可
og:url: https://auth0.com/docs/
permalink: authenticate-devices-using-mqtt
title: Auth0でのMQTTによるデバイスの認証と認可
twitter:description: How to authenticate and authorize devices using MQTT with Auth0.
twitter:title: Auth0でのMQTTによるデバイスの認証と認可
---

[](http://en.wikipedia.org/wiki/MQ_Telemetry_Transport)MQTTは、他のシステムと通信するためのデバイスによく使用される軽量なプロトコルで、**publish/subscribe（パブリッシュ/サブスクライブ）**型のメッセージングプラットフォーム向けに設計されています。詳細については、Wikipediaの[MQTT](http://en.wikipedia.org/wiki/MQ_Telemetry_Transport)をお読みください。

一般には3つのコンポーネントから成り立ちます。

1. メッセージの`publisher`（パブリッシャー）
2. メッセージの`subscriber`（サブスクライバー）
3. メッセージを仲介する`broker`（ブローカー）

メッセージが関連付けられている`topics`（トピック）（`チャネル`または`サブジェクト`とも呼ばれる）の概念があります。トピックはパブリッシャーとサブスクライバー間のメッセージをルーティングします。

MQTTプロトコルは、`usernames`および`passwords`に基づいて基本的な認証メカニズムをサポートします。これらの資格情報は、`CONNECT`メッセージとともに送信されます。

この記事では、nodejsベースのMQTTブローカー（[mosca](https://github.com/mcollina/mosca)および[Auth0](http://auth0.com)）間の統合について説明します。この例では、Auth0を使って`publishers`および`subscribers`のブローカーに対する**認証**を行い、メッセージのルーティングを**認可**します。

## ソリューションのコンポーネント

### ブローカー

**mosca**はホストにとっては簡単で、他のサーバーに埋め込むことができます。このサンプルの目的上、**mosca**サーバーを自己ホストします。



これによって、ポート9999でMQTTメッセージをリッスンするサーバーが作成されます。**mosca**では、操作の認証と認可に使用する3つの関数をオーバーライドすることができます。

このサンプルでは、非常に単純なモジュール`auth0mosca`を使ってこれらの関数を実行します。Auth0は**mosca**に結びついています。

### Auth0Moscaモジュール

この小さな[モジュール](https://www.npmjs.org/package/auth0mosca)には、**mosca**で使用される4つの関数（`authenticateWithCredentials`、`authenticateWithJWT`、`authorizePublish`、`authorizeSubscribe`）があります。



`authenticateWithCredentials`は[OAuth2リソース所有者のパスワード資格情報付与](/protocols)を使って、ブローカーおよびブローカーへのすべての接続を認証します。`publisher`または`subscriber`が**CONNECT**メッセージをブローカーに送信するたびに、`authenticate`関数が呼び出されます。この関数でAuth0エンドポイントを呼び出し、デバイスの`username`/`password`を転送します。Auth0は、これをアカウントストア（コード内の最初の`request.post`）と比較して検証します。検証に成功した場合、JSON Web Token（JWT）を検証および解析してデバイスのプロファイルを取得し、`subscriber`または`publisher`を表す`client`オブジェクトに追加します。これは、`jwt.verify`呼び出しで行われます。

慣例により、ブローカーに接続されたデバイスはすべて、Auth0にアカウントがあります。

デバイスプロファイルにも`topics`プロパティがあります。これは、この特定のデバイスが許可されたすべてのトピックを含む配列です。上のスクリーンショットでは、`thermostat-1a`は`temperature`および`config`トピックへのパブリッシュ（またはサブスクライブ）が許可されます。

`authorizePublish`関数と`authorizeSubscribe`関数は、要求された特定のトピックがこのリストに載っているかどうかを確認するだけです。

`authenticateWithJWT`は、`password`フィールドでJWTを想定します。この場合の流れは若干異なります。

1. パブリッシャーとサブスクライバーがトークンを取得する
2. `mosca`に接続してJWTを送信する
3. `mosca`がJWTを検証する
4. メッセージが送信されサブスクライバーに再送信される

パブリッシャーとサブスクライバーは何らかの方法でJWTを取得します。ブローカーはAuth0と通信する必要はなくなりました。JWTは自己完結型のアーティファクトであり、署名に使用するシークレットで検証することができます。

### パブリッシャー

このサンプルの場合、パブリッシャーは`mqtt`モジュールを使用する単純なnodejsプログラムであり、正しい資格情報を追加します。



もちろん、`username`と`password`は、Auth0に保存されているものに一致しなければなりません。

### サブスクライバー

サブスクライバーはパブリッシャーに非常に似ています。



## Summary（概要）

ご覧のように、Auth0はさまざまなシナリオで簡単に使用することができます。Auth0のユーザーストアを使ってデバイスを管理します。時間や場所、デバイスIDといった他の状況に基づいて、はるかに洗練された認証ルールを記述する​ことも当然可能です。これらはすべて、追加のプロファイル属性や[](/rules)ルールを通じて非常に簡単に実装​することができます。柔軟なAuth0 Profileが、任意のアーティファクト（この例の`topics`など）をサポートするためにどのように拡張できるかについても説明しています。

Rules（ルール）の詳細については、[「Auth0 Rules」](/rules)を確認してください。

資格情報（`username`/`password`）を安全でないネットワークを介して送信することは絶対に避けてください。メッセージ内容が公開されることを防ぐTransport Level Securityを提供する他の実装もあります。1つの例として、**mosca**はTLSをサポートします。すべてのトラフィックが閉域網を通る場合を除き、運用環境への導入ではこれが優先されるでしょう。

### 謝辞

本記事の編集にご協力いただき、素晴らしい**mosca**を構築していただいた[Matteo Collina](http://www.matteocollina.com/)氏に感謝の意を表します。