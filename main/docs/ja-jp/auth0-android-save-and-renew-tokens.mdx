---
og:description: Keeping your user logged in with Auth0.Android
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Auth0.Androidでトークンを保存および更新する
og:url: https://auth0.com/docs/
permalink: auth0-android-save-and-renew-tokens
title: Auth0.Androidでトークンを保存および更新する
twitter:description: Keeping your user logged in with Auth0.Android
twitter:title: Auth0.Androidでトークンを保存および更新する
---

When an authentication is performed with the `offline_access` scope included, it returns a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=refresh+token">refresh token</Tooltip> that can be used to request a new user token, without forcing the user to perform authentication again.

## Credential Managers（資格情報マネージャー）は、Auth0.Android SDKの一部として含まれています。これがまだ、ユーザーの依存関係の一部でない場合は、[Auth0.Android](/libraries/auth0-android)の指示に従ってください。

[Auth0.Android](https://github.com/auth0/Auth0.Android) provides a utility class to streamline the process of storing and renewing credentials. You can access the `accessToken` or `idToken` properties from the [Credentials](https://github.com/auth0/Auth0.Android/blob/master/auth0/src/main/java/com/auth0/android/result/Credentials.java) instance. This is the preferred method to manage user credentials.

Credential Managers are included as part of the Auth0.Android SDK. If this is not yet part of your dependencies, follow the instructions in [Auth0.Android](/docs/libraries/auth0-android).

`CredentialsManager`はプレーンテキスト形式でデータを保存します。

* `SecureCredentialsManager`はデータを保存する前に暗号化し、[Android KeyStore]()と共にRSAとAESアルゴリズムの組み合わせを使用します。
* `SecureCredentialsManager` encrypts the data before storing it, using a combination of RSA and AES algorithms along with [Android KeyStore](https://developer.android.com/reference/java/security/KeyStore.html).

## CredentialsManagerをセットアップする

### 認証の現在の状態

保存された資格情報は、期限切れになっていないか更新可能である場合は有効であるとみなされます。ユーザーが既にログインしているか確認します。

```kotlin lines
val auth0 = Auth0(this)
val apiClient = AuthenticationAPIClient(auth0)
val manager = CredentialsManager(apiClient, SharedPreferencesStorage(this))
```






### ユーザーをアプリケーションからログアウトするには、保存された資格情報を削除し、ユーザーをログイン画面に誘導します。

資格情報の取得

```kotlin lines
val loggedIn = manager.hasValidCredentials()
```






資格情報はAuth0 Serversに対して更新される必要があるため、この方法は非同期です。資格情報を受信したいコールバック実装を渡します。正常に実行された後、この方法で返される資格情報は常に有効です。

```kotlin lines
manager.clearCredentials()
```






### 新しい資格情報を保存する

マネージャーで認証中に取得した資格情報を保存することができます。

```kotlin lines
manager.getCredentials(object: Callback<Credentials, CredentialsManagerException>() {
    override fun onSuccess(credentials: Credentials) {
        // Use credentials
    }

    override fun onFailure(error: CredentialsManagerException) {
        // No credentials were previously saved or they couldn't be refreshed
    }
})
```






SecureCredentialsManagerクラスの使用

### SecureCredentialsManagerをセットアップする

有効なAndroid `Context`、`AuthenticationAPIClient`、および`Storage`実装を渡して、新しいインスタンスを作成します。

```text lines
manager.saveCredentials(credentials)
```






## 資格情報を取得、保存、有無を確認、および消去する方法は、上のセクションで説明したのと同じです。

### ユーザーを事前認証する

このクラスは、デバイスで構成されたロック画面を使って、さらなる認証のためのオプション機能を備えています。

```kotlin lines
val auth0 = Auth0(this)
val apiClient = AuthenticationAPIClient(auth0)
val manager = SecureCredentialsManager(this, apiClient, SharedPreferencesStorage(this))
```






以下のメソッドを呼び出して認証を有効にします。有効な`Activity`コンテント、要求コード、および2つの任意の文字列を渡し、ロック画面のタイトルと説明に使用します。

### また、アクティビティの結果からの要求コードが一致するように、要求コード定数を定義します。

機能が有効な場合、マネージャーは構成されたロック画面を使ってユーザーに認証を行うよう促します。この呼び出しの結果は、最初のパラメーターとして以前に渡されたアクティビティの`onActivityResult`メソッドで取得されます。機能が有効でなかった場合、ロック画面の認証はスキップされます。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If Lock Screen Security is set to something different than PIN, Pattern, Password or Fingerprint, this feature isn't available.

</Callout>

受け取った要求コードが構成手順で使用されたものに一致することを確認したら、受信したパラメーターをマネージャーにリダイレクトし、認証を終了します。資格情報が元のコールバックに渡ります。

使用状況の例外処理

```kotlin lines
companion object {
  const val RC_UNLOCK_AUTHENTICATION = 123
}

// Called from an Activity
val available = manager.requireAuthentication(this, RC_UNLOCK_AUTHENTICATION, getString(R.string.unlock_authentication_title), getString(R.string.unlock_authentication_description))
```






Credentials（資格情報）を保存または取得中に予期しないイベントが起きた場合は、`CredentialsManagerException`が発生します。想定できる失敗したシナリオには以下のようなものがあります。

保存される資格情報が無効である（`access_token`、`id_token`、または`expires_at`といった一部のフィールドが定義されていないなど）。

```kotlin lines
override fun onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == RC_UNLOCK_AUTHENTICATION && manager.checkAuthenticationResult(requestCode, resultCode)) {
        return
    }

    super.onActivityResult(requestCode, resultCode, data)
}
```






<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

The `onActivityResult` method was deprecated on 2021 in favor of the new [Activity Result APIs](https://developer.android.com/training/basics/intents/result). However, the Auth0.Android SDK is not compatible with these contracts. You can continue to use the deprecated methods safely.

</Callout>

### 保存された資格情報の有効期限が切れているが、自動更新するために利用できるリフレッシュトークンがない。

デバイスのロック画面のセキュリティ設定が変更されている（セキュリティPINコードが変更されているなど）。`hasCredentials`がTrueを返しても、暗号化キーは無効とみなされます。`saveCredentials`が再び呼び出されても、前の既存のコンテンツを復号化することはできません。これは、前に使用したキーが新しいものと同じではないためです。

* デバイスが`SecureCredentialsManager`クラスで必要な一部の暗号化アルゴリズに対応していない。これは壊滅的なイベントとしてみなされ、ユーザーが実装を使用するのを阻止する唯一の例外です。このシナリオは、OEMがデバイスのAndroid ROMを変更し、各Androidディストリビューションに正式に含まれている一部のアルゴリズムを削除するときに発生します。しかしながら、`isDeviceIncompatible`メソッドを呼び出して、これが例外インスタンス自体で本当かどうかを確認することができます。そうすることで、ユーザーは資格情報を保存するためのフォールバックの実装（通常の`CredentialsManager`クラスを使用するなど）を決定することができます。
* The stored Credentials have expired but there is no refresh token available to renew them automatically.
* The device's lock screen security settings have changed (for example the security PIN code changed). Even when `hasCredentials` returns true, the encryption keys will be deemed invalid. Until `saveCredentials` is called again, it won't be possible to decrypt any previously existing content because they previously used keys are not the same as the new ones.
* The device is not compatible with some of the cryptography algorithms required by the `SecureCredentialsManager` class. This is considered a catastrophic event and is the only exception that will prevent you from using this implementation. This scenario happens when the OEM has modified the Android ROM of the device, removing some of the algorithms officially included in every Android distribution. Nevertheless, you can check if this is the case in the exception instance itself by calling the `isDeviceIncompatible` method. By doing so you can decide the fallback implementation for storing the credentials, such as using the regular `CredentialsManager` class.