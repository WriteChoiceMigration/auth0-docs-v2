---
og:description: Learn about best practices for executing Auth0 rules.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: ルールの実行に関するベストプラクティス
og:url: https://auth0.com/docs/
permalink: rules-execution-best-practices
title: ルールの実行に関するベストプラクティス
twitter:description: Learn about best practices for executing Auth0 rules.
twitter:title: ルールの実行に関するベストプラクティス
---

<Warning>

The End of Life (EOL) date of Rules and Hooks will be **November 18, 2026**, and they are no longer available to new tenants created as of **October 16, 2023**. Existing tenants with active Hooks will retain Hooks product access through end of life.

We highly recommend that you use Actions to extend Auth0. With Actions, you have access to rich type information, inline documentation, and public `npm` packages, and can connect external integrations that enhance your overall extensibility experience. To learn more about what Actions offer, read [Understand How Auth0 Actions Work](/docs/customize/actions/actions-overview).

To help with your migration, we offer guides that will help you [migrate from Rules to Actions](/docs/customize/actions/migrate/migrate-from-rules-to-actions) and [migrate from Hooks to Actions](/docs/customize/actions/migrate/migrate-from-hooks-to-actions). We also have a dedicated [Move to Actions](https://auth0.com/extensibility/movetoactions) page that highlights feature comparisons, [an Actions demo](https://www.youtube.com/watch?v=UesFSY1klrI), and other resources to help you on your migration journey.

To read more about the Rules and Hooks deprecation, read our blog post: [Preparing for Rules and Hooks End of Life](https://auth0.com/blog/preparing-for-rules-and-hooks-end-of-life/).

</Warning>

Each rule is executed as a JavaScript function called in the order defined. The next rule in order won’t execute until the previous rule has completed. In addition, the rule pipeline only executes for workflows that involve user credentials; the rule pipeline **does not** execute during the [Client Credentials Flow](/docs/get-started/authentication-and-authorization-flow/client-credentials-flow). For functionality similar to a rule, an [Action](/docs/customize/actions) in the [Machine to Machine Flow](/docs/customize/actions/explore-triggers/machine-to-machine-trigger) on the `credentials-exchange` trigger can be used instead.

パイプラインの用語では、ルールはルールに提供された`callback`関数が呼び出されたときに完了します。関数の呼び出しに失敗すると、パイプラインの実行は停止し、最終的にはエラーが返されます。各ルールは、`callback`関数を1回**だけ**呼び出す必要があります。

Rule execution supports the asynchronous nature of JavaScript, and constructs such as [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) objects and the like can be used. Asynchronous processing effectively results in suspension of a pipeline pending completion of the asynchronous operation. An Auth0 serverless Webtask container typically has a circa 20-second execution limit, after which the container may be recycled. Recycling of a container due to this limit will prematurely terminate a pipeline—suspended or otherwise—ultimately resulting in an error in authentication being returned (as well as resulting in a potential reset of the `global` object).

非同期実行では、非同期操作が完了した後に（JavaScript）コールバックが実行されます。このコールバックは通常、JavaScript関数のメイン（同期）本文が完了した後のいずれかの時点で呼び出されます。ルールが非同期処理を利用している場合、（Auth0）提供の`callback`関数の呼び出しは、非同期処理が完了するまで延期され、最後に呼び出される必要があります。上述のように、（Auth0）提供の`callback`関数は1回だけ呼び出す必要があります。ルール内で関数を複数回呼び出すと、予期しない結果が得られたり、エラーが発生したりすることにつながります。

`context`オブジェクト

## context object

The コンテキストバイパスロジックを使用して多要素認証チェックを行う場合は、ベストプラクティスを確認することを強くお勧めします。たとえば、MFAの使用が`context.request.query.prompt==='none'`を前提としている場合、**重大なセキュリティ上の欠陥**が表面化する可能性があります。さらに、`context`オブジェクトの内容は**セキュリティ上重要**なため、オブジェクトを外部またはサードパーティのサービスに直接渡さ**ない**でください。 provides information about the context in which a rule is run (such as client identifier, connection name, session identifier, request context, protocol, etc). Using the context object, a rule can determine the reason for execution. For example, as illustrated in the sample fragment below, `context.clientID` as well as `context.protocol` can be used to implement conditional processing to determine when rule logic is executed. The sample also shows some best practices for exception handling, use of `npm` modules (for `Promise` style processing), and the `callback` object. To learn more, read [Custom Database Action Script Environment Best Practices](/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment)`.`

```js lines expandable
switch (context.protocol) {
    case 'redirect-callback':
      return callback(null, user, context);
    	break;

    default: {
      user.app_metadata = user.app_metadata || {};
      switch(context.clientID) {
        case configuration.PROFILE_CLIENT: {
          user.user_metadata = user.user_metadata || {};
          Promise.resolve(new
            Promise(function (resolve, reject) {
              switch (context.request.query.audience) {
                case configuration.PROFILE_AUDIENCE: {
                  switch (context.connection) {
                      .
                      .
                  }
                } break;
              .
              .
            })
          )
          .then(function () {
              .
              .
          })
          .catch(function (error) {
            return callback(new UnauthorizedError("unauthorized"), user, context);
          });
        } break;

        default:
          return callback(null, user, context);
          break;

    } break;
```






We highly recommend reviewing best practices when using contextual bypass logic for <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=Multi-Factor+Authentication">Multi-Factor Authentication</Tooltip> checking. For example, **serious security flaws** can surface if use of MFA is predicated on `context.request.query.prompt === 'none'`. In addition, the content of the コンテキストバイパスロジックを使用して多要素認証チェックを行う場合は、ベストプラクティスを確認することを強くお勧めします。たとえば、MFAの使用が`context.request.query.prompt==='none'`を前提としている場合、**重大なセキュリティ上の欠陥**が表面化する可能性があります。さらに、`context`オブジェクトの内容は**セキュリティ上重要**なため、オブジェクトを外部またはサードパーティのサービスに直接渡さ**ない**でください。 is **security sensitive**, so you should **not** directly pass the object to any external or third-party service.

### Auth0を使用すると、ユーザーから情報を収集できる任意のURLにユーザーをリダイレクトし、その後、リダイレクトをトリガーした元の/authorize要求を完了できる`/continue`エンドポイントにユーザーを戻すことができます。これは強力な機能であり、ユースケースによっては、誤って実行した場合の影響は、無害なものから、アプリケーションにセキュリティの脆弱性を残すものまでさまざまです。そのため、これを正しく実行することが重要です。

It may not be practical to collect information from a user as part of a login flow in situations where there are many applications and you want a centralized service to manage that, or if you are using a SPA and you want to prevent the user from getting an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> under certain conditions. In these cases, having a centralized way to collect information or provide a challenge to a user is necessary.

Auth0 allows you to redirect the user to any URL where you can collect information from that user and then return the user to the `/continue` endpoint where they can complete the original /authorize request that triggered the redirect. This is a powerful capability, and depending on the use case, the impact of doing it wrong can be anywhere from innocuous to leaving a security vulnerability in the application. As such, it is important to ensure that this is done correctly.

メールの確認

* プロファイルへの情報の追加
* ルールでは、ユーザーの`app_metadata`内のフラグまたは値をチェックし、Auth0への独自の/authorize呼び出しを実行するアプリケーションにリダイレクトして、ユーザーのメタデータに変更を加え、ユーザーをAuth0にリダイレクトすることをお勧めします。これは、プロファイル変更のリダイレクトや、ユーザーのログインを制限する必要がない場合に最適です。
* ルールからのリダイレクトを使用すると、context.redirectによってトリガーされる追加のユーザー操作を必要とするカスタム認証フローを実装できます。ルールからのリダイレクトは、`/authorize`エンドポイントを呼び出す場合にのみ使用できます。

We recommend that the rule check for some flag or value in the user's `app_metadata`, then redirect to an application that does its own /authorize call to Auth0 and make any changes to the user's metadata and redirect the user back to Auth0. This works great for any profile changing redirects or anything that does not need to restrict the user from logging in.

リダイレクトされると、独自のホスト型ユーザーインターフェイスは、ユーザー認証されたコンテキストで実行され、Auth0 SSOによって信頼性アーティファクトを取得します。これらのアーティファクト（OpenID Connect（OIDC）のIDトークンやOAuth 2.0のアクセストークンなど）を取得するには、リダイレクトをトリガーしたものでは**ない**`context.clientID`コンテキストを使用します。これを行うには、`/authorize`エンドポイントにリダイレクトします。たとえば、SPAの場合は、サイレント認証を使用します。これにより、すべてのルールが再度実行される新しいパイプラインが作成され、ルール内の`context`オブジェクトを使用して条件付き処理を実行できます。

実行する処理が完了すると、`/continue`エンドポイントを介してユーザーをAuth0にリダイレクトし（提供された`state`を指定）、パイプラインの実行が続行されます。これにより、すべてのルールが現在のパイプライン内で再度実行され、ルール内の`context`オブジェクトを使用して条件付き処理チェックを実行できます。

Once redirected, your own hosted user interface executes in a user authenticated context, and obtains authenticity artifacts by the virtue of Auth0 <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=SSO">SSO</Tooltip>. Obtaining these artifacts—e.g., an <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=ID+Token">ID Token</Tooltip> in <Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=OpenID">OpenID</Tooltip> Connect (OIDC), and/or an Access Token in <Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=OAuth+2.0">OAuth 2.0</Tooltip>—is achieved by using a `context.clientID` context **that is not** the one which triggered redirect. To do this, redirect to the `/authorize` endpoint. In the case of a SPA for example, use silent authentication. This creates a new pipeline that causes all rules to execute again, and you can use the コンテキストバイパスロジックを使用して多要素認証チェックを行う場合は、ベストプラクティスを確認することを強くお勧めします。たとえば、MFAの使用が`context.request.query.prompt==='none'`を前提としている場合、**重大なセキュリティ上の欠陥**が表面化する可能性があります。さらに、`context`オブジェクトの内容は**セキュリティ上重要**なため、オブジェクトを外部またはサードパーティのサービスに直接渡さ**ない**でください。 within a rule to perform conditional processing.

情報をフロントチャネルでやり取りすると、悪意のある行為者の攻撃対象になる領域を広げることになります。これは、ルールでアクションを実行する必要がある場合にのみ実行する必要があります（`UnauthorizedError`で承認試行を拒否するなど）。

`user`オブジェクト

Passing information back and forth in the front channel opens up surface area for <Tooltip tip="Bad Actors: Entity (a person or group) that poses a threat to the business or environment with the intention to cause harm." cta="View Glossary" href="/docs/glossary?term=bad+actors">bad actors</Tooltip> to attack. This should definitely be done only in conditions where you must take action in the rule (such as rejecting the authorization attempt with `UnauthorizedError`).

## user object

The アイデンティティ provides access to a cached copy of the user account (user profile) record in Auth0. The object provides access to information regarding the user without the need to access the Auth0 <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip>—access which is both rate limited and subject to latency.

ロール、グループ、部門、ジョブコードなどのユーザーの認証関連属性は、`u​​ser_metadata`ではなく`app_metadata`に保存する必要があります。これは、`user_metadata`は基本的にユーザーが変更できるのに対し、`app_metadata`は変更できないためです。

たとえば、ユーザーに関連付けられたメタデータの更新を保持することが必要になる場合があり、必要に応じて`auth0`オブジェクトを使用してそのような操作を実行できます。いずれかのメタデータオブジェクトを更新するときは、保存する情報について慎重に検討することが重要です。メタデータのベストプラクティスに従って、メタデータを過剰に使用しないように注意してください。メタデータの過剰使用は、パイプライン内での過剰な処理によって遅延が増える可能性があります。詳細については、[メタデータのフィールド名とデータタイプ](/users/metadata/metadata-fields-data)をご覧ください。`auth0`オブジェクトを使用すると、Auth0管理APIも呼び出されます。Auth0管理APIはレート制限があり、遅延の影響を受けるため、更新を実行するタイミングと頻度については注意が必要です。

`callback`関数

ルールに提供される`callback`関数は、ルールの完了を示す信号として効果的に機能します。ルールは、コールバック関数の呼び出しの直後に暗示的または（JavaScript）`return`ステートメントを明示的に実行して完了する必要があり、その他の操作は実行しません。

### 関数の呼び出しに失敗すると、パイプラインの実行は停止し、最終的にはエラー状態が返されます。各ルールは、`callback`関数を1回だけ呼び出す必要があります。1回呼び出すとパイプラインの停止は防止されますが、複数回呼び出すと、予期しない結果やエラーが発生する可能性があります。

The アイデンティティ also contains a reference to the identities associated with the user account. The `identities` property is an array of objects, each of which contain properties associated with the respective identity as known to the <Tooltip tip="Identity Provider (IdP): Service that stores and manages digital identities." cta="View Glossary" href="/docs/glossary?term=identity+provider">identity provider</Tooltip> (for example, the `provider` name, associated `connection` in Auth0, and the `profileData` obtained from the identity provider during the last authentication using that identity). Linking user accounts creates multiple entries in the array.

特定の状況では、`user`または`context`オブジェクトの特定のコンテンツを変更することは許容されますが、推奨されるベストプラクティスとして、`user`または`context`オブジェクトの新規作成されたインスタンスを渡さないようにしてください。`user`または`context`オブジェクト以外のものを渡すと、予期しない結果が生じ、例外またはエラー状態が発生する可能性があります。

### ステータスパラメーターは、`null`、`Error`オブジェクトのインスタンス、または`UnauthorizedError`オブジェクトのインスタンスのいずれかとして渡す必要があります。nullを指定するとパイプライン処理の継続が許可されますが、その他の値を指定するとパイプラインが終了します。`UnauthorizedError`はアクセス拒否を通知し、アクセス拒否の理由に関する情報を認証操作の発信者に返すことができます。これらのパラメーターのいずれかにその他の値を渡すと、予期しない結果が生じ、例外またはエラー状態が発生する可能性があります。

認証はすでに行われているため、（認証）エラーでパイプラインが早期に終了しても、ブラウザー内の認証済みセッションには影響しません。/authorizeへの後続のリダイレクトは通常、自動ログインになります。パイプラインが早期に終了すると、トークンなどの生成が停止されます。1つのオプションは、必要に応じてアプリケーションを認証APIの[ログアウトエンドポイント](/api/authentication#logout)にリダイレクトし、ブラウザー内のAuth0セッションを強制的に終了することです。

ログアウトエンドポイントへの呼び出しは中断される可能性があるため、明示的なAuth0セッションの終了は保証されません。これは,`unauthorized`エラーの原因となった明示的な条件を、後続のルールパイプライン実行で再チェックする必要があり、他の条件（`prompt===none` など）によってこれらの条件チェックをバイパスできないようにする必要があるため重要です。

There may be occasions when it becomes necessary to persist, say, updates to metadata associated with a user, and the `auth0` object can be used to perform such operations where required. When updating either metadata object, it is important to be judicious regarding what information is stored: in line with metadata best practice, be mindful of excessive use of metadata, which can result in increased latency due to excessive processing within the pipeline. To learn more, read [Metadata Field Names and Data Types](/docs/manage-users/user-accounts/metadata/metadata-fields-data). Use of the `auth0` object also results in a call to the Auth0 Management API, so caution should be exercised regarding when and how often updates are performed since the Auth0 Management API is both rate limited and subject to latency.

## callback function

The `callback` function supplied to a rule effectively acts as a signal to indicate completion of the rule. A rule should complete immediately following a call to the callback function, either implicitly or by explicitly executing a (JavaScript) `return` statement, and should refrain from any other operation.

Failure to call the function will result in a stall of pipeline execution, and ultimately in an error condition being returned. Each rule then must call the `callback` function exactly once. Calling it once prevents the stall of the pipeline, but more could cause unpredictable results or errors.

```javascript lines
function (user, context, callback) {
  getRoles(user.user_id, (err, roles) => {
    if (err) return callback(err);

    context.idToken['https://example.com/roles'] = roles;

    return callback(null, user, context);
  });
}
```






As can be seen in the example above, the `callback` function can be called with up to three parameters. The first parameter is mandatory and provides an indication of the status of rule operation. The second and third parameters are optional and represent the user and the context to be supplied to the next rule in the pipeline. If these are specified, then it is a recommended best practice to pass the `user` and コンテキストバイパスロジックを使用して多要素認証チェックを行う場合は、ベストプラクティスを確認することを強くお勧めします。たとえば、MFAの使用が`context.request.query.prompt==='none'`を前提としている場合、**重大なセキュリティ上の欠陥**が表面化する可能性があります。さらに、`context`オブジェクトの内容は**セキュリティ上重要**なため、オブジェクトを外部またはサードパーティのサービスに直接渡さ**ない**でください。 (respectively) as supplied to the rule.

While it can be acceptable to modify certain contents of either the `user` or the コンテキストバイパスロジックを使用して多要素認証チェックを行う場合は、ベストプラクティスを確認することを強くお勧めします。たとえば、MFAの使用が`context.request.query.prompt==='none'`を前提としている場合、**重大なセキュリティ上の欠陥**が表面化する可能性があります。さらに、`context`オブジェクトの内容は**セキュリティ上重要**なため、オブジェクトを外部またはサードパーティのサービスに直接渡さ**ない**でください。 for certain situations, as a recommended best practice you should refrain from passing a newly-created instance of either the `user` or the `context` object. Passing anything other than a `user` or コンテキストバイパスロジックを使用して多要素認証チェックを行う場合は、ベストプラクティスを確認することを強くお勧めします。たとえば、MFAの使用が`context.request.query.prompt==='none'`を前提としている場合、**重大なセキュリティ上の欠陥**が表面化する可能性があります。さらに、`context`オブジェクトの内容は**セキュリティ上重要**なため、オブジェクトを外部またはサードパーティのサービスに直接渡さ**ない**でください。 will have unpredictable results and may lead to an exception or error condition.

The status parameter should be passed as either `null`, an instance of an `Error` object, or an instance of an `UnauthorizedError` object. Specifying null will permit the continuation of pipeline processing, while any of the other values will terminate the pipeline; an `UnauthorizedError` signals denial of access and allows information to be returned to the originator of the authentication operation regarding the reason why access is denied. Passing any other value for any of these parameters will have unpredictable results and may lead to an exception or error condition.

As authentication has already occurred, any early exit of the pipeline with an (authorization) error will not impact the authenticated session within the browser; subsequent redirects to /authorize will typically result in an automatic login. The early exit of the pipeline simply stops tokens et al from being generated. One option is for the application to redirect to the Authentication API's [Logout endpoint](https://auth0.com/docs/api/authentication#logout), if required, to force termination of the Auth0 session in the browser.

Any call to the Logout endpoint could be interrupted, so explicit Auth0 session termination is not guaranteed. This is important, as any explicit condition that caused an `unauthorized` error must be re-checked in any subsequent rule pipeline execution, and it should not be possible to bypass these condition check(s) through any other conditions (such as `prompt===none`).

## Learn more

* [Rules Anatomy Best Practices](/docs/rules-best-practices/rules-anatomy-best-practices)
* [Rules Environment Best Practices](/docs/rules-best-practices/rules-environment-best-practices)
* [Rules Security Best Practices](/docs/rules-best-practices/rules-security-best-practices)
* [Rules Testing Best Practices](/docs/rules-best-practices/rules-testing-best-practices)
* [Error Handling Best Practices](/docs/troubleshoot/error-handling-best-practices)