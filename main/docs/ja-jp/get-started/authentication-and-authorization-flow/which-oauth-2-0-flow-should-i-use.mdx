---
og:description: Learn how to identify the proper OAuth 2.0 flow for your use case.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: どちらのOAuth 2.0フローを使用するべきですか？
og:url: https://auth0.com/docs/
permalink: which-oauth-2-0-flow-should-i-use
title: どちらのOAuth 2.0フローを使用するべきですか？
twitter:description: Learn how to identify the proper OAuth 2.0 flow for your use
  case.
twitter:title: どちらのOAuth 2.0フローを使用するべきですか？
---

The [OAuth 2.0 Authorization Framework](/docs/authenticate/protocols/oauth) supports several different flows (or grants). <Tooltip tip="Flow: Processes that can be extended using Actions. Each Flow is made up of one or more Triggers and represents the logical pipeline through which information moves during a single point in the Auth0 journey." cta="View Glossary" href="/docs/glossary?term=Flow">Flow</Tooltip> are ways of retrieving an <Tooltip tip="Flow: Processes that can be extended using Actions. Each Flow is made up of one or more Triggers and represents the logical pipeline through which information moves during a single point in the Auth0 journey." cta="View Glossary" href="/docs/glossary?term=Access+Token">Access Token</Tooltip>. Deciding which one is suited for your use case depends mostly on your [application type](/docs/get-started/applications), but other parameters weigh in as well, like the level of trust for the client, or the experience you want your users to have.

## **Resource Owner（リソース所有者）**：保護されたリソースへのアクセス権を付与できるエンティティ。大抵の場合、エンドユーザーです。

* **<Tooltip tip="Resource Owner: Entity (such as a user or application) capable of granting access to a protected resource." cta="View Glossary" href="/docs/glossary?term=Resource+Owner">Resource Owner</Tooltip>**: Entity that can grant access to a protected resource. Typically, this is the end-user.
* **Resource Server（リソースサーバー）**：保護されたリソースをホストするサーバー。アクセスしたいAPIのことです。
* **<Tooltip tip="Resource Server: Server hosting protected resources. Resource servers accept and respond to protected resource requests." cta="View Glossary" href="/docs/glossary?term=Resource+Server">Resource Server</Tooltip>**: Server hosting the protected resources. This is the API you want to access.
* **<Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/docs/glossary?term=Authorization+Server">Authorization Server</Tooltip>**: Server that authenticates the Resource Owner and issues Access Tokens after getting proper authorization. In this case, Auth0.
* クライアントはリソース所有者ですか？

## 最初の判断のポイントは、リソースにアクセスが必要な関係者がマシンかどうかです。マシンツーマシンの認可の場合、クライアントもリソース所有者であるため、エンドユーザーの認可は必要ありません。たとえば、APIを使用して情報をデータベースにインポートするcronジョブです。この例では、cronジョブはクライアントであり、リソース所有者です。その理由は、クライアントがクライアントIDとクライアントシークレットを持っていて、認可サーバーからアクセストークンを取得するのにそれらを使用しているからです。

The first decision point is about whether the party that requires access to resources is a machine. In the case of machine-to-machine authorization, the Client is also the Resource Owner, so no end-user authorization is needed. An example is a cron job that uses an API to import information to a database. In this example, the cron job is the Client and the Resource Owner since it holds the <Tooltip tip="Client ID: Identification value given to your registered resource from Auth0." cta="View Glossary" href="/docs/glossary?term=Client+ID">Client ID</Tooltip> and <Tooltip tip="Client Secret: Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable." cta="View Glossary" href="/docs/glossary?term=Client+Secret">Client Secret</Tooltip> and uses them to get an Access Token from the Authorization Server.

If this case matches your needs, then to learn how this flow works and how to implement it, see [Client Credentials Flow](/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).

## クライアントがサーバー上で実行されている一般的なWebアプリであれば、認可コードフローが適しています。このフローを使用すれば、クライアントはアクセストークンを取得できる上に、リフレッシュトークンも任意で取得できます。アクセストークンはクライアントをホストしているWebサーバーへ直接渡されるため、最も安全な選択だと考えられています。ユーザーのWebブラウザーが関わることはなく、暴露のリスクもありません。

If the Client is a regular web app executing on a server, then the Authorization Code Flow is the flow you should use. Using this the Client can retrieve an Access Token and, optionally, a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+Token">Refresh Token</Tooltip>. It's considered the safest choice since the Access Token is passed directly to the web server hosting the Client, without going through the user's web browser and risking exposure.

If this case matches your needs, then to learn how this flow works and how to implement it, see [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow).

## 決定のポイントは、リソース所有者のパスワード資格情報付与の処理結果になります。このフローでは、エンドユーザーは資格情報（識別子とパスワード）を、通常は対話型フォームを使用して提供するように要求されます。この情報はバックエンドに送信され、そこからAuth0へ送信されます。このため、この情報を扱うのにクライアントが絶対的に信頼できることが不可欠です。

この付与の使用は、（[認可コードフロー](/login/flows/authorization-code-flow)のような）リダイレクトベースのフローが使用できない場合にのみ限定すべきです。これに該当するのであれば、このフローの仕組みと実装方法については、「[リソース所有者のパスワードフロー](/login/flows/resource-owner-password-flow)」を参照してください。

This grant should only be used when redirect-based flows (like the [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)) are not possible. If this is your case, then to learn about how this flow works and how to implement it, see [Resource Owner Password Flow](/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow).

## クライアントがシングルページアプリ（SPA）であれば、JavaScriptなどのスクリプト言語を使用してブラウザーで実行されているアプリケーションであることになり、付与には2つのオプションがあります。Proof Key for Code Exchange（PKCE）を使った認可コードフロー、そして、フォームPOSTを使った暗黙フローです。ほとんどの場合、PKCEを使った認可コードフローの使用をお勧めします。アクセストークンがクライアント側で暴露されることがない上に、このフローが[リフレッシュトークン](/security/tokens/refresh-tokens)を返すことができます。

If the Client is a Single-Page App (SPA), an application running in a browser using a scripting language like JavaScript, there are two grant options: the Authorization Code Flow with Proof Key for Code Exchange (PKCE) and the Implicit Flow with Form Post. For most cases, we recommend using the Authorization Code Flow with PKCE because the Access Token is not exposed on the client side, and this flow can return [Refresh Tokens](/docs/secure/tokens/refresh-tokens).

To learn more about how this flow works and how to implement it, see [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). The [Auth0 Single-Page App SDK](/docs/libraries/auth0-single-page-app-sdk) provides high-level API for implementing Authorization Code Flow with PKCE in SPAs.

If your SPA doesn't need an Access Token, you can use the Implicit Flow with Form Post. To learn more about how this flow works and how to implement it, see [Implicit Flow with Form Post](/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).

## アプリケーションがネイティブアプリの場合は、**Proof Key for Code Exchange（PKCE）を使った認可コードフロー**を使用してください。

このフローの仕組みと実装方法については、「[Proof Key for Code Exchange（PKCE）を使った認可コードフロー](/login/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)」を参照してください。

To learn more about how this flow works and how to implement it, see [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).

## アプリケーションを実装する前に、エンドポイントを試してみることができますか？

If a single application needs access tokens for different resource servers, then multiple calls to `/authorize` (that is, multiple executions of the same or different <Tooltip tip="Authorization Flow: Authorization grant (or workflow) specified in the OAuth 2.0 framework." cta="View Glossary" href="/docs/glossary?term=Authorization+Flow">Authorization Flow</Tooltip>) needs to be performed. Each authorization will use a different value for `audience`, which will result in a different access token at the end of the flow. For more information, see the [OAuth 2.0: Audience Information Specification](https://tools.ietf.org/html/draft-tschofenig-oauth-audience-00#section-3).

## 認可エンドポイントについては、「[アプリケーションを認可する](/api/authentication#authorize-application)」に記載の「このエンドポイントをテストする」段落をお読みください。

Sure! You can use our [Authentication API Debugger Extension](/docs/customize/extensions/authentication-api-debugger-extension). You can find detailed instructions per `/grant` endpoint at our [Authentication API Reference](https://auth0.com/docs/api/authentication).

* For the Authorize endpoint, go to [Authorize Application](https://auth0.com/docs/api/authentication#authorize-application) and read the "Test this endpoint" paragraph for the grant you want to test.
* For the <Tooltip tip="Token Endpoint: Endpoint on the Authorization Server that is used to programmatically request tokens." cta="View Glossary" href="/docs/glossary?term=Token+endpoint">Token endpoint</Tooltip>, go to [Get Token](https://auth0.com/docs/api/authentication#get-token) and read the "Test this endpoint" section for the grant you want to test.

## クライアントアプリケーションがエンドユーザーに代わって認証プロセスを開始する。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Client-Initiated Backchannel Authentication is currently in Early Access. To enable CIBA, contact your Technical Account Manager.

</Callout>

Client-Initiated Backchannel Authentication (CIBA) is an <Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=OpenID">OpenID</Tooltip> Foundation standard for implementing an alternative authentication flow to [OpenID Connect](https://openid.net/developers/how-connect-works/). CIBA differs from the standard OpenID Connect flow in that:

* クライアントアプリケーションとOpenIDプロバイダーが直接通信する。
* CIBAは、ユーザーがクライアントアプリケーションを信頼できない、クライアントアプリケーションにブラウザーがない、またはユーザーが認証を必要とするアプリケーションの前にいない際に役立ちます。以下でCIBAフローが使用できる例をご紹介します。
* **販売端末でのユーザーのチェックイン：**クリック＆コレクトのシナリオで、ユーザーは公共のキオスクで認証し、存在を確認できます。

**コールセンターまたは担当者デスクでの認証：**コールセンターののオペレーターは認証フローを開始し、 発信者を認証できます。通常、スマートフォンのカスタムモバイルアプリを使用します。

* **User check-in at a retail sales terminal:** For click-collect scenarios, a user can authenticate at a public kiosk and confirm their presence.
* **Authenticating in a call center or at a clerk's desk:** A call center agent can initiate an authentication flow to authenticate a caller, typically using a custom mobile app on a smartphone.
* **Authenticating on a device with no input:** For example, a smart speaker (or another connected device) can use a backend service to contact the user for authentication, typically using a custom mobile app on a smartphone.

**認証デバイス**：ユーザーが認証、同意の付与を行うデバイス。

* 詳細については、「[クライアントが開始するバックチャネル認証フロー](/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow)」をお読みください。
* **Authentication device**: The device on which the user will authenticate and grant consent.

To learn more, read [Client-Initiated Backchannel Authentication Flow](/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow).