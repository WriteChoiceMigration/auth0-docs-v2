---
og:description: Learn how to call your API from an input-constrained device using
  the Device Authorization flow.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: デバイス認可フローを使用してAPIを呼び出す
og:url: https://auth0.com/docs/
permalink: call-your-api-using-the-device-authorization-flow
title: デバイス認可フローを使用してAPIを呼び出す
twitter:description: Learn how to call your API from an input-constrained device using
  the Device Authorization flow.
twitter:title: デバイス認可フローを使用してAPIを呼び出す
---



Auth0を使用すると、以下を使ってアプリでデバイス認可フローを簡単に実装できます。

* [Authentication API](/api/authentication)：APIを直接呼び出す方法については、このまま続けてお読みください。インタラクティブエクスペリエンスについては、「[デバイスフロープレイグラウンド](https://auth0.github.io/device-flow-playground/)」をお読みください。

## 前提条件

このチュートリアルを始める前に：

* 制限事項（下記）を確認して、デバイス認可フローが実装に適しているかどうかを確認してください。
* [Auth0にアプリケーションを登録します](/get-started/create-apps/native-apps)。

* **［Application Type（アプリケーションタイプ）］**として**［Native（ネイティブ）］**を選択します。
* 必要な場合は、**［Allowed Web Origins（許可されたWebオリジン）］**を設定します。これを使用して、ローカル開発のオリジンとしてlocalhostを許可したり、CORSの対象となるアーキテクチャ（例：HTML5+JS）を持つ特定のTVソフトウェアの許可されたオリジンを設定したりできます。ほとんどのアプリケーションはこの設定は使用しません。
* **［OIDC Conformant（OIDC準拠）］**トグルが有効になっていることを確認します。この設定は[［Dashboard］](%24%7Bmanage_url%7D)の**［Applications（アプリケーション）］>［Application（アプリケーション）］>［Advanced Settings（アプリケーション設定）］>［OAuth］**にあります。
* アプリケーションの**［Grant Types（付与タイプ）］**に**［Device Code（デバイスコード）］**が含まれていることを確認します。詳細については、「[付与タイプを更新する](/applications/update-grant-types)」をお読みください。
* アプリケーションがリフレッシュトークンを使用できるようにするには、アプリケーションの**［Grant Types（付与タイプ）］**に**［Refresh Token（リフレッシュトークン）］**が含まれていることを確認します。詳細については、「[付与タイプを更新する](/applications/update-grant-types)」をお読みください。リフレッシュトークンの詳細については、「[リフレッシュトークン](/security/tokens/refresh-tokens)」をお読みください。
* アプリケーションに少なくとも次の1つの接続をセットアップして有効にします：[データベース接続](/applications/set-up-database-connections)、[ソーシャル接続](/social)
* [APIをAuth0に登録します](/architecture-scenarios/mobile-api/part-2#create-the-api)。

* APIがリフレッシュトークンを受信して、トークンの有効期限が切れたときに新しいトークンを取得できるようにするには、**［Allow Offline Access（オンラインでのアクセスを許可する）］**を有効にします。リフレッシュトークンの詳細については、「[リフレッシュトークン](/security/tokens/refresh-tokens)」をお読みください。
* [デバイスのユーザーコードの設定を構成](/tenant-settings/configure-device-user-code-settings)して、ランダムに生成されたユーザーコードの文字セット、形式、長さを定義します。

## 手順

1. [デバイスコードの要求](#request-device-code)（デバイスフロー）：ユーザーがデバイスを認可するために使用できるデバイスコードを要求します。
2. [デバイスのアクティベーションの要求](#request-device-activation)（デバイスフロー）：ユーザーにノートパソコンまたはスマートフォンを使用してデバイスを認可するよう要求します。
3. [トークンの要求](#request-tokens)（デバイスフロー）：トークンエンドポイントをポーリングし、トークンを要求します。
4. [ユーザーの認可](#authorize-user)（ブラウザフロー）：デバイスがトークンを受け取れるように、ユーザーがデバイスを認可します。
5. [トークンの受け取り](#receive-tokens)（デバイスフロー）：ユーザーがデバイスを正常に認可すると、トークを受け取ります。
6. [APIの呼び出し](#call-api)（デバイスフロー）：取得したアクセストークンを使ってAPIを呼び出します。
7. [トークンのリフレッシュ](#refresh-tokens)（デバイスフロー）：既存のトークンが期限切れになったら、リフレッシュトークンを使用して新しいトークンを要求します。

任意：[サンプルユースケースを参考にしてください](#sample-use-cases)。

任意：[トラブルシューティング](#troubleshoot)。

### デバイスコードを要求する

ユーザーがデバイスアプリを起動し、デバイスを認可したい場合は、デバイスコードを取得する必要があります。ユーザーがブラウザベースのデバイスでセッションを開始すると、このコードはそのセッションにバインドされます。

デバイスコードを取得するには、アプリがクライアントIDを含む[デバイスコードURL](/api/authentication#get-device-code)からコードを要求する必要があります。

#### デバイスコードに対するPOSTの例URL



##### デバイスコードのパラメーター

カスタムAPIを呼び出すためのデバイスコードを要求するときは、以下のことにご注意ください。

* オーディエンスパラメーターを含めなければなりません
* ターゲットAPIによってサポートされている追加のスコープを含めなければなりません





#### デバイスコードの応答

すべてがうまくいけば、`device_code`、`user_code`、`verification_uri`、`expires_in`、`interval`、および`verification_uri_complete`値を含むペイロードを持つ`HTTP 200`応答を受け取ります。



* `device_code`は、デバイスに対して一意のコードです。ユーザーがブラウザベースのデバイスで`verification_uri`にアクセスすると、このコードはセッションにバインドされます。
* `user_code`には、デバイスを認可するために`verification_uri`に入力する必要のあるコードが含まれます。
* `verification_uri`には、ユーザーがデバイスを認可するためにアクセスする必要があるURLが含まれます。
* `verification_uri_complete`には、ユーザーがデバイスを認可するためにアクセスする必要がある完全なURLが含まれています。これにより、必要に応じてアプリでURLに`user_code`を埋め込むことができます。
* `expires_in`は、`device_code`および`user_code`の有効期間（秒）を示します。
* `interval`は、アプリがトークンを要求するためにトークンURLをポーリングする間隔（秒）を示します。



### デバイスのアクティベーションを要求する

`device_code`および`user_code`を受け取ったら、ユーザーに、ノートパソコンまたはスマートフォンで`verification_uri`にアクセスして`user_code`を入力するよう求める必要があります。

`device_code`はユーザーに直接提供するものではないため、ユーザーが混乱しないように、処理中に表示するべきではありません。



### トークンを要求する

ユーザーがデバイスを有効にするのを待っている間に、トークンURLのポーリングを開始してアクセストークンを要求します。前のステップで抽出したポーリング間隔（`interval`）を使用して、`device_code`とともに[トークンURL](/api/authentication#device-auth)を`POST`する必要があります。

ネットワーク遅延によるエラーを回避するには、最後のポーリング要求の応答を受信してから各間隔のカウントを開始する必要があります。

#### トークンURLに対するトークンPOST要求の例



##### トークン要求のパラメーター



#### トークンの応答

ユーザーがデバイスを認可するのを待っている間に、いくつかの異なる`HTTP 4xx`応答を受け取る場合があります。

##### 認可待ち

このエラーは、ユーザーの操作を待っている間に表示されます。このチュートリアルの前の手順で推奨されているintervalを使ってポーリングを継続してください。



##### 減速

ポーリングが速すぎます。このチュートリアルの前の手順で推奨されている間隔を使ってポーリングしてください。ネットワーク遅延が原因でこのエラーを受け取ることを避けるには、ポーリング要求の応答を受け取ってから間隔をカウントし始めるようにします。



##### 有効期限切れのトークン

ユーザーがデバイスをすぐに認可しなかったため、「device_code」の有効期限が切れました。アプリケーションはユーザーにフローの失効を通知して、フローをもう一度始めるように促す必要があります。





##### アクセスが拒否されました

最後に、アクセスが拒否された場合は、次のメッセージが表示されます。



これは、以下を含むさまざまな原因で発生します。

* ユーザーがデバイスの認可を拒否した
* 認可サーバーがトランザクションを拒否した
* 構成されたルールによってアクセスが拒否された（詳細については、「[Auth0ルール](/rules)」をお読みください）

### ユーザーを認可する

ユーザーはQRコードをスキャンするか、アクティベーションページを開いてユーザーコードを入力します：

確認ページが表示され、ユーザーが正しいデバイスであることを確認します：

ユーザーがサインインして、トランザクションが完了します。この手順には、以下の1つ以上のプロセスが含まれます。

* ユーザーを認証する
* 認証を行うために、ユーザーをIDプロバイダーへリダイレクトする
* アクティブなSSOセッションをチェックする
* 事前に同意が得られていない場合、デバイスに対するユーザーの同意を取得する

認証と同意が成功すると、確認のプロンプトが表示されます：

この時点で、ユーザーは認証され、デバイスは認可されています。

### トークンを受け取る

ユーザーが認証とデバイスの認可を行っている間、デバイスアプリはトークンURLをポーリングしてアクセストークンを要求し続けます。

ユーザーが正常にデバイスの認可を行った場合、`access_token`、`refresh_token`（任意）、`id_token`（任意）、`token_type`、および`expires_in`値を含むペイロードを持つ`HTTP 200`応答を受け取ります。





アクセストークンは、Auth0 Authentication APIの[`/userinfo`エンドポイント](/api/authentication#get-user-info)や他のAPIを呼び出すために使用されます（アクセストークンの詳細については、「[アクセストークン](/security/tokens/access-tokens)」を参照してください）。`openid`スコープを含めた場合にのみ、アクセストークンを使用して`/userinfo`を呼び出すことができます。独自のAPIを呼び出す場合に、APIがまず実行しなければならいことは、[アクセストークンを検証](/security/tokens/access-tokens/validate-access-tokens)することです。

IDトークンにはデコードして抽出するべきユーザー情報が含まれています（IDトークンの詳細については、「[IDトークン](/security/tokens/id-tokens)」をお読みください）。`id_token`は`openid`スコープを含めた場合にのみ応答で返されます。

リフレッシュトークンは、トークンの有効期限が切れた後に、新しいアクセストークンまたはIDトークンを取得するために使用されます（リフレッシュトークンの詳細については、「[リフレッシュトークン](/security/tokens/refresh-tokens)」をお読みください）。`refresh_token`は、`offline_access`スコープを含めて、DashboardでAPIの**［Allow Offline Access（オンラインでのアクセスを許可する）］**を有効にした場合にのみ応答で返されます。



### APIを呼び出す

APIを呼び出すには、アプリケーションは、取得したアクセストークンをベアラートークンとしてHTTP要求の認証ヘッダーで渡さなければなりません。



### リフレッシュトークン

このチュートリアルに従って次の操作を完了している場合は、すでにリフレッシュトークンを受け取っています。

* オフラインアクセスを許可するように、APIを構成する。
* [認可エンドポイント](/api/authentication/reference#authorize-application)を通じて認証要求を開始するときに`offline_access`スコープを含める。

リフレッシュトークンを使用して新しいアクセストークンを取得できます。通常、ユーザーが新しいアクセストークンを必要とするのは、以前のアクセストークンの有効期限が切れた後、または新しいリソースに初めてアクセスするときだけです。APIを呼び出すたびにエンドポイントを呼び出して新しいアクセストークンを取得するのは良くない慣行であり、Auth0では同じIPから同じトークンを使用して実行できるエンドポイントへの要求の量を制限するレート制限を維持しています。

トークンを更新するには、`grant_type=refresh_token`を使用して、認証APIの`/oauth/token`エンドポイントに対して`POST`要求を行います。

#### トークンURLに対するリフレッシュトークンのPOST要求の例



##### リフレッシュトークン要求パラメーター



#### リフレッシュトークンの応答

すべてがうまくいけば、`HTTP 200`応答がペイロードに新しい`access_token`、`id_token`（任意）、秒単位のトークン有効期間（`expires_in`）、付与された`scope`の値、`token_type`を含めて返されます。





## サンプルユースケース

### デバイス認可フローの使用を検出する

ルールを使用して、現在のトランザクションがデバイス認可フローを使用しているかを検出できます（ルールの詳細については、「[Auth0ルール](/rules)」をお読みください）。これを行うには、`context`オブジェクトの`protocol`プロパティを確認します。



### 実装例

* [デバイス認可プレイグラウンド](https://auth0.github.io/device-flow-playground/)
* [AppleTV（Swift）](https://github.com/pushpabrol/auth0-device-flow-appletv)：AppleTVからのデバイス認可フローにAuth0を使用できることを示す簡素なアプリケーションです。
* [CLI（Node.js）](https://gist.github.com/panva/ebaacfe433a8677bdbf458f6e1132045)：認可コードフローではなく、デバイス認可フローを使用するCLIの実装例です。CLIではWebサーバーをホストしてポートを待ち受ける必要がない点で大きく異なります。

## トラブルシューティング

テナントログは実行されるあらゆるやり取りを記録するため、問題の解決に利用できます。詳細については、「[ログ](/logs)」をお読みください。

### エラーコード



### 制限事項

デバイス認可フローを使用するには、デバイスが次の要件を満たす必要があります。

* [カスタムドメイン](/custom-domains)の使用にServer Name Indication（SNI）をサポートしている
* [Auth0アプリケーションタイプ](/applications)が**［Native（ネイティブ）］**である
* [トークンエンドポイントの認証方法](/applications/application-settings)が**［None（なし）］**に設定されている
* [OIDCに準拠](/applications/application-settings)している
* [動的クライアント登録（Dynamic Client Registration）](/applications/dynamic-client-registration)で作成されていない

また、デバイス認可フローでは以下を実行できません：

* [ソーシャル接続](/social)に[Auth0開発者キー](/devkeys)を使用する（[ユニバーサルログインエクスペリエンス](/login/universal-login/universal-experience)を使用していない場合）
* クエリ文字列パラメーターへのアクセスをホスト済みのログインページまたはルールから行う
* [ユーザーアカウントをリンクする](/users/user-account-linking)

機密クライアント以外では、Draft 15に完全に対応しています。詳細については、[ietf.orgにあるOAuth 2.0 Device Authorization GrantのDraft 15](https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15)をお読みください。