---
og:description: The ASP.NET Core implementation for the Single Sign-on (SSO) for Regular
  Web Apps architecture scenario
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: ASP.NET Coreの実装（Webアプリ + SSO）
og:url: https://auth0.com/docs/
permalink: implementation-aspnetcore
title: ASP.NET Coreの実装（Webアプリ + SSO）
twitter:description: The ASP.NET Core implementation for the Single Sign-on (SSO)
  for Regular Web Apps architecture scenario
twitter:title: ASP.NET Coreの実装（Webアプリ + SSO）
---

Full source code for the ASP.NET Core implementation can be found in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-webapp-oidc).

## クッキーおよびOIDCミドルウェアを構成する

このガイドの目的のために、シンプルなホスト型ログインを使用します。標準クッキーと、ASP.NET Coreで利用できるOIDCミドルウェアを使用できるため、NuGetパッケージをインストールしてください。

```bash lines
Install-Package Microsoft.AspNetCore.Authentication.Cookies
Install-Package Microsoft.AspNetCore.Authentication.OpenIdConnect
```






その後、アプリケーションのミドルウェアパイプライン内でクッキーとOIDCミドルウェアを構成します。

```csharp lines expandable
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Add authentication services
        services.AddAuthentication(
            options => options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme);

        // Code omitted for brevity...
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory, IOptions<Auth0Settings> auth0Settings)
    {
        // Code omitted for brevity...

        // Add the cookie middleware
        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            AutomaticAuthenticate = true,
            AutomaticChallenge = true
        });

        // Add the OIDC middleware
        app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions("Auth0")
        {
            // Set the authority to your Auth0 domain
            Authority = "https://{yourDomain}/",

            // Configure the Auth0 Client ID and Client Secret
            ClientId = {yourClientId},
            ClientSecret = YOUR_CLIENT_SECRET,

            // Do not automatically authenticate and challenge
            AutomaticAuthenticate = false,
            AutomaticChallenge = false,

            // Set response type to code
            ResponseType = "code",

            CallbackPath = new PathString("/signin-auth0"),

            // Configure the Claims Issuer to be Auth0
            ClaimsIssuer = "Auth0"
        });

        // Code omitted for brevity...
    }
}
```






上記のコードでは、2つの異なるタイプの認証ミドルウェアを構成しました。

ユーザーがOIDCミドルウェアを使用してAuth0にサインインすると、ユーザーの情報はセッションクッキー内に自動的に保存されます。上記の通りにミドルウェアを構成するだけで、ユーザーセッションは管理されます。

Once the user has signed in to Auth0 using the OIDC middleware, their information will automatically be stored inside a <Tooltip tip="Session Cookie: Entity that, when present, allows the user to be considered authenticated." cta="View Glossary" href="/docs/glossary?term=session+cookie">session cookie</Tooltip>. All you need to do is to configure the middleware as above and it will take care of managing the user session.

The <Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=OpenID">OpenID</Tooltip> Connect (OIDC) middleware will also extract all the claims from the <Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=ID+Token">ID Token</Tooltip>, which is sent from Auth0 once the user has authenticated, and add them as claims on the `ClaimsIdentity`.

## クッキーミドルウェアのサインアウトと、それによるアプリケーションの認証クッキーの消去の例として、以下の呼び出しを作成できます。

同様に、`SignOutAsync`メソッドを呼び出し、サインアウトするために認証スキームとして`Auth0`を伝えることで、ユーザーをAuth0からログアウトできます。

ただし上記が機能するためには、`OnRedirectToIdentityProviderForSignOut`イベントを処理して、OIDCミドルウェアを登録するときに別の構成を追加する必要があります。イベント内で、Auth0クッキーを消去する[Auth0ログアウトエンドポイント]()にリダイレクトする必要があります。

```csharp wrap lines
await HttpContext.Authentication.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
```






また、Auth0 Dashboard内のアプリケーションのために、アプリケーションのURLを**［Allowed Logout URLs（許可されているログアウトURL）］**に追加する必要があります。詳細については、[ログアウト]()を参照してください。

```csharp lines
await HttpContext.Authentication.SignOutAsync("Auth0");
```






For the above to work you will however also need to add extra configuration when registering the OIDC middleware by handling the `OnRedirectToIdentityProviderForSignOut` event. Inside the event you will need to redirect to the [Auth0 logout endpoint](https://auth0.com/docs/api/authentication/reference#logout) which will clear the Auth0 cookie.

```csharp lines
app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions("Auth0")
{
    // Some code omitted for brevity
    Events = new OpenIdConnectEvents
    {
        OnRedirectToIdentityProviderForSignOut = context =>
        {
            context.Response.Redirect($"https://{auth0Settings.Value.Domain}/v2/logout?client_id={auth0Settings.Value.ClientId}&returnTo={context.Request.Scheme}://{context.Request.Host}/");
            context.HandleResponse();

            return Task.FromResult(0);
        }
    }
});
```






You will also need to ensure that you add your application's URL to the **Allowed Logout URLs** for your application inside the <Tooltip tip="Auth0 Dashboard: Auth0's main product to configure your services." cta="View Glossary" href="/docs/glossary?term=Auth0+dashboard">Auth0 dashboard</Tooltip>. For more information refer to [Logout](/docs/authenticate/login/logout).

## 上記タイプのクレームを追加する必要があります。

The easiest way to integrate the groups into an ASP.NET Core application is to use the built-in [Role-based Authorization](https://docs.asp.net/en/latest/security/authorization/roles.html) available in ASP.NET Core. In order to achieve this we will need to add a Claim of type

```http lines
http://schemas.microsoft.com/ws/2008/06/identity/claims/role
```






ASP.NET OIDCミドルウェアは、JWTで返されたすべてのクレームを、クレームとして`ClaimsIdentity`に自動的に追加します。このため、`authorization`クレームから情報を抽出し、クレームのJSONボディーを逆シリアル化して、グループごとに、`

その後、管理者にタイムシートの承認を許可するアクションを追加できます。

The ASP.NET OIDC middleware will automatically add all claims returned in the <Tooltip tip="JSON Web Token (JWT): Standard ID Token format (and often Access Token format) used to represent claims securely between two parties." cta="View Glossary" href="/docs/glossary?term=JWT">JWT</Tooltip> as claims to the `ClaimsIdentity`. We would therefore need to extract the information from the `authorization` claim, deserialize the JSON body of the claim, and for each of the groups add a `http://schemas.microsoft.com/ws/2008/06/identity/claims/role` claim to the `ClaimsIdentity`.

```csharp lines expandable
app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions("Auth0")
{
    // Some configuration omitted for brevity

    Events = new OpenIdConnectEvents
    {
        OnTicketReceived = context =>
        {
            var options = context.Options as OpenIdConnectOptions;

            // Get the ClaimsIdentity
            var identity = context.Principal.Identity as ClaimsIdentity;
            if (identity != null)
            {
                // Add the groups as roles
                var authzClaim = context.Principal.FindFirst(c => c.Type == "authorization");
                if (authzClaim != null)
                {
                    var authorization = JsonConvert.DeserializeObject<Auth0Authorization>(authzClaim.Value);
                    if (authorization != null)
                    {
                        foreach (var group in authorization.Groups)
                        {
                            identity.AddClaim(new Claim(ClaimTypes.Role, group, ClaimValueTypes.String, options.Authority));
                        }
                    }
                }
            }

            return Task.FromResult(0);
        }
    }
});
```






And subsequently we can add an action which allows Administrators to approve timesheets:

```csharp lines
[Authorize(Roles = "Admin")]
public IActionResult TimesheetApproval()
{          
    return View();
}
```