---
og:description: Regular web app scenario solution overview.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: ソリューションの概要（Webアプリ + SSO）
og:url: https://auth0.com/docs/
permalink: part-1
title: ソリューションの概要（Webアプリ + SSO）
twitter:description: Regular web app scenario solution overview.
twitter:title: ソリューションの概要（Webアプリ + SSO）
---

このセクションでは、ID管理、使用するプロトコル、必要な認証フローの詳細など、実装するソリューションについて説明します。

## ID管理

ExampleCo は、Identity as a Service（IDaaS）プロバイダーとしてAuth0を使用することを決定しました。この決定の理由は、会社がIDおよびアクセス管理のトレーニング、実装、保守にリソースを投入したくなかったためです。さらに、同社は将来的にこのソリューションにモバイルネイティブアプリとAPIを追加し、承認されたタイムシートを社内システムにプッシュする計画もあります。Auth0は、最小限の労力でアーキテクチャにこのような変更を組み込む柔軟性を提供します。



## 使用するプロトコル

次の決定は、OpenID Connect（OIDC）を使用したOAuth 2.0 とSAMLのどちらのプロトコルを使用するかという点に関係します。



**OpenID Connect**は、OAuth 2.0ファミリーの仕様に基づいた認証プロトコルです。OAuth 2.0プロトコルを介して配信されるシンプルなJSON IDトークン（JWT）を使用します。



**SAML**は、信頼できる当事者間の認証と認可の両方を提供するXMLベースのプロトコルです。

SAMLと比較すると、OpenID Connectは軽量で扱いが簡単です。SAMLは実績があり、強力で柔軟性がありますが、このアプリの要件では、その柔軟性と強力さは必要ありません。IDフェデレーション（SAMLを採用する最も説得力のある理由の1つ）もここでは必要ありません。また、IDフェデレーションが必要になった場合でも、AD（LDAP を使用）を処理するのと同じ方法でAuth0によって簡単に処理できます。

これらの理由から、ExampleCoは実装にOpenID Connectを使用します。

## 認証フロー

OpenID Connectは、認証のために複数のフローをサポートします。このシナリオでは通常のWebアプリを使用するため、認可コードフローを使用します。

フローは以下のようになります：

1. Webアプリ（OIDC用語ではクライアントと呼ばれます）は、ユーザーエージェント（ブラウザー）をAuth0（OIDC用語では認可サーバー）にリダイレクトして認証要求を開始します。
2. Auth0はユーザーを認証します（ユーザーエージェント経由）。ユーザーが初めてこのフローを通過すると、同意ページが表示され、アプリケーションに付与される権限（メッセージの投稿、連絡先の一覧表示など）がリストされます。ユーザーはサービスにログインし（すでにログインしていない場合）、アプリケーションアクセスを認可します。
3. ユーザーがアクセスを許可した場合、Auth0はクエリ文字列内の認可コードとともにユーザーエージェントをアプリケーションにリダイレクトします。
4. アプリケーションは、アプリケーションの資格情報（client_idおよびclient_secret）とともに認可コードをAuth0に送信し、トークンを要求します。
5. Auth0はアプリケーションを認証し（client_idおよびclient_secretを使用）、認可コードを検証します。有効な場合、Auth0はIDトークンで応答します。



**［ID Token（IDトークン）］**（コードサンプルでは通常`id_token`と呼ばれます）は、IDデータを含む**JSON Webトークン（JWT）**です。これはアプリケーションによって使用され、ユーザーの名前、メールなどのユーザー情報を取得するために使用され、通常はUI表示に使用されます。



### IDトークンの検証方法

IDトークンの検証にはいくつかの手順が必要です：

1. IDトークンが暗号化されている場合は、アプリケーションが指定したキーとアルゴリズムを使用して復号化します。
2. OpenIDプロバイダーの発行者識別子は、`iss`（発行者）クレームの値と一致する必要があります。
3. `aud`（オーディエンス）クレームには、アプリケーションの`client_id`値が含まれている必要があります。IDトークンにアプリケーションが有効なオーディエンスとしてリストされていない場合、またはアプリケーションによって信頼されていない追加のオーディエンスが含まれている場合、IDトークンは拒否されなければなりません。
4. IDトークンに複数のオーディエンスが含まれている場合、アプリケーションは`azp`クレームが存在することを確認する必要があります。
5. `azp`（承認された当事者）クレームが存在する場合、アプリケーションは、その`client_id`がクレーム値であることを確認する必要があります。
6. アプリケーションは、JWT`alg`ヘッダーパラメータで指定されたアルゴリズムを使用して、JWSに従ってIDトークンの署名を検証する必要があります。アプリケーションは発行者によって提供されたキーを使用する必要があります。
7. `alg`値は、`RS256`のデフォルト、または登録時に`id_token_signed_response_alg`パラメータでアプリケーションによって送信されたアルゴリズムである必要があります。
8. JWT`alg`ヘッダーパラメータが`HS256`、`HS384`、`HS512`,などのMACベースアルゴリズムを使用する場合、`aud`（オーディエンス）クレームに含まれる`client_id`に対応する`client_secret`のUTF-8表現のオクテットが、署名を検証するためのキーとして使用されます。MACベースアルゴリズムの場合、`aud`が複数値である場合、または`aud`値とは異なる`azp`値が存在する場合、動作は未指定です。
9. 現在の時刻は、`exp`クレームによって表される時刻より前である必要があります。
10. `iat`クレームを使用すると、現在の時刻からかなり離れて発行されたトークンを拒否し、攻撃を防ぐためにnonce を保存する必要がある時間を制限できます。許容範囲はアプリケーションによって異なります。
11. 認証要求で`nonce`値が送信された場合、`nonce`クレームが存在し、その値が認証要求で送信された値と同じであることを確認するためにチェックされる必要があります。アプリケーションは、リプレイ攻撃に備えて`nonce`値をチェックする必要があります。リプレイ攻撃を検出するための正確な方法はアプリケーションによって異なります。
12. `acr`クレームが要求された場合、アプリケーションは主張されたクレーム値が適切であることを確認する必要があります。
13. `auth_time`クレームが、このクレームに対する特定の要求を通して、または`max_age`パラメータを使用して要求された場合、アプリケーションは`auth_time`クレーム値を確認し、最後のエンドユーザー認証から経過した時間が長すぎると判断した場合は再認証を要求する必要があります。