---
og:description: Regular web app scenario solution overview.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: ソリューションの概要（Webアプリ + SSO）
og:url: https://auth0.com/docs/
permalink: part-1
title: ソリューションの概要（Webアプリ + SSO）
twitter:description: Regular web app scenario solution overview.
twitter:title: ソリューションの概要（Webアプリ + SSO）
---

このセクションでは、ID管理、使用するプロトコル、必要な認証フローの詳細など、実装するソリューションについて説明します。

## ID管理

ExampleCo は、Identity as a Service（IDaaS）プロバイダーとしてAuth0を使用することを決定しました。この決定の理由は、会社がIDおよびアクセス管理のトレーニング、実装、保守にリソースを投入したくなかったためです。さらに、同社は将来的にこのソリューションにモバイルネイティブアプリとAPIを追加し、承認されたタイムシートを社内システムにプッシュする計画もあります。Auth0は、最小限の労力でアーキテクチャにこのような変更を組み込む柔軟性を提供します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Identity-as-Service ("IDaaS") is a cloud-based service for identity and access management. The offered services often include Single Sign-on (SSO), federated identity, password management, and more.

</Callout>

## 使用するプロトコル

The next decision has to do with which protocol to use, <Tooltip tip="OAuth 2.0: Authorization framework that defines authorization protocols and workflows." cta="View Glossary" href="/docs/glossary?term=OAuth+2.0">OAuth 2.0</Tooltip> with <Tooltip tip="OAuth 2.0: Authorization framework that defines authorization protocols and workflows." cta="View Glossary" href="/docs/glossary?term=OpenID">OpenID</Tooltip> Connect (OIDC) or <Tooltip tip="Security Assertion Markup Language (SAML): Standardized protocol allowing two parties to exchange authentication information without a password." cta="View Glossary" href="/docs/glossary?term=SAML">SAML</Tooltip>.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0 implements proven, common and popular identity protocols, both for consumer oriented web products (OAuth 2.0, OAuth 1.0, OpenID) and for enterprise deployments (SAML, WS-Federation, LDAP). You have complete freedom to use the one that best meets your business needs.

</Callout>

**OpenID Connect** is an authentication protocol, based on the OAuth 2.0 family of specifications. It uses simple JSON <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=identity+tokens">identity tokens</Tooltip> (<Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=JWT">JWT</Tooltip>) delivered via the OAuth 2.0 protocol.

<Info>
### OAuth vs OpenID Connect (OIDC)

OAuth 2.0 and OpenID Connect (OIDC) are often mistaken for the same thing, but this is not exact.
**OAuth 2.0** is a protocol that lets you authorize one website (the consumer or application) to access your data from another website (the resource server or provider). For example, you want to authorize a website to access some files from your Dropbox account. The website will redirect you to Dropbox which will ask you whether it should provide access to your files. If you agree the website will be authorized to access your files from Dropbox. At the core, OAuth 2.0 is about resource access and sharing.
**OpenID Connect**, on the other hand, is a simple identity layer built on top of the OAuth 2.0 protocol. It gives you one login for multiple sites. Each time you need to log in to a website using OIDC, you are redirected to your OpenID site where you login, and then taken back to the website. At the core, OIDC is concerned with user authentication.
</Info>

**SAML**は、信頼できる当事者間の認証と認可の両方を提供するXMLベースのプロトコルです。

SAMLと比較すると、OpenID Connectは軽量で扱いが簡単です。SAMLは実績があり、強力で柔軟性がありますが、このアプリの要件では、その柔軟性と強力さは必要ありません。IDフェデレーション（SAMLを採用する最も説得力のある理由の1つ）もここでは必要ありません。また、IDフェデレーションが必要になった場合でも、AD（LDAP を使用）を処理するのと同じ方法でAuth0によって簡単に処理できます。

これらの理由から、ExampleCoは実装にOpenID Connectを使用します。

## 認証フロー

OpenID Connectは、認証のために複数のフローをサポートします。このシナリオでは通常のWebアプリを使用するため、認可コードフローを使用します。

フローは以下のようになります：

1. The web app (called the Client in OIDC terms) initiates the authentication request by redirecting the user-agent (browser) to Auth0 (the Authorization Server in OIDC terms).
2. Auth0 authenticates the user (via the user-agent). The first time the user goes through this flow a consent page will be shown where the permissions that will be given to the Application are listed (for example, post messages, list contacts). The user logs in to the service (unless they are already logged in) and authorizes the application access.
3. Assuming the user grants access, Auth0 redirects the user-agent back to the Application, along with an authorization code in the query string.
4. The Application sends the authorization code to Auth0, along with the application credentials (client_id and client_secret), and asks for a token.
5. Auth0 authenticates the Application (using the client_id and client_secret) and validates the authorization code. If valid, Auth0 responds back with an ID Token.

<Frame>![undefined](/images/cdy7uua7fh8z/5qO4QJH0YW34apsypLXnIk/e27a8cf1469c00d948cc476b11b54300/authz-code-flow.png)</Frame>

<Info>
### Form Post Response Mode

Another option is to use the **OAuth 2.0 Form Post Response Mode** with `response_type=id_token&response_mode=form_post`. Due to the `response_type=id_token` request parameter, the response contains the ID Token directly, instead of the authorization code, while the `response_mode=form_post` encodes the ID Token with the rest of the Authorization Response parameters as HTML form values that are auto-submitted in the User Agent. This way you can have an optimized authentication flow (no need to exchange the code for an ID Token), however you have to make sure that it is supported by the technology you are using to implement your app (ASP .NET Core middleware does support it). For more details refer to the [OAuth 2.0 Form Post Response Mode specification](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html).
</Info>

**［ID Token（IDトークン）］**（コードサンプルでは通常`id_token`と呼ばれます）は、IDデータを含む**JSON Webトークン（JWT）**です。これはアプリケーションによって使用され、ユーザーの名前、メールなどのユーザー情報を取得するために使用され、通常はUI表示に使用されます。

<Info>
### More on tokens

Tokens are alphanumeric strings used in token-based authentication. They allow users to authenticate with a username and password once and get a token in return which they can use from that point on. They have a limited lifetime duration.

**JSON Web Tokens (JWTs)** are tokens that conform to the [JSON Web Token Standard](https://tools.ietf.org/html/rfc7519) and contain information about an identity in the form of claims. They are self-contained in that it is not necessary for the recipient to call a server to validate the token. JWTs can be signed using a secret (with the **HMAC** algorithm) or a public/private key pair using **RSA**. You can find more information on JWT [here](/docs/secure/tokens/json-web-tokens).

The ID Token, which is a JWT, conforms to an industry standard (IETF [RFC 7519](https://tools.ietf.org/html/rfc7519)) and contains three parts: A header, a body and a signature.

* The header contains the type of token and the hash algorithm used on the contents of the token.
* The body, also called the payload, contains identity claims about a user. There are some claims with registered names, for things like the issuer of the token, the subject of the token (who the claims are about), and the time of issuance. Any number of additional claims with other names can be added, though care must be taken to keep the JWT within the browser size limitations for URLs.
* The signature is used by the recipient of a JWT to validate the integrity of the information conveyed in the JWT.
</Info>

### IDトークンの検証方法

IDトークンの検証にはいくつかの手順が必要です：

1. If the ID Token is encrypted, decrypt it using the keys and algorithms that the Application specified.
2. The Issuer Identifier for the OpenID Provider must match the value of the `iss` (issuer) claim.
3. The `aud` (audience) claim should contain the Application's `client_id` value. The ID Token must be rejected if the ID Token does not list the Application as a valid audience, or if it contains additional audiences not trusted by the Application.
4. If the ID Token contains multiple audiences, the Application should verify that an `azp` claim is present.
5. If an `azp` (authorized party) claim is present, the Application should verify that its `client_id` is the claim value.
6. The Application must validate the signature of ID Tokens according to JWS using the algorithm specified in the JWT `alg` header parameter. The Application must use the keys provided by the Issuer.
7. The `alg` value should be the default of `RS256` or the algorithm sent by the Application in the `id_token_signed_response_alg` parameter during registration.
8. If the JWT `alg` header parameter uses a MAC based algorithm such as `HS256`, `HS384`, or `HS512`, the octets of the UTF-8 representation of the `client_secret` corresponding to the `client_id` contained in the `aud` (audience) claim are used as the key to validate the signature. For MAC based algorithms, the behavior is unspecified if the `aud` is multi-valued or if an `azp` value is present that is different than the `aud` value.
9. The current time must be before the time represented by the `exp` claim.
10. The `iat` claim can be used to reject tokens that were issued too far away from the current time, limiting the amount of time that nonces need to be stored to prevent attacks. The acceptable range is Application specific.
11. If a `nonce` value was sent in the Authentication Request, a `nonce` claim must be present and its value checked to verify that it is the same value as the one that was sent in the Authentication Request. The Application should check the `nonce` value for replay attacks. The precise method for detecting replay attacks is Application specific.
12. If the `acr` claim was requested, the Application should check that the asserted claim value is appropriate.
13. If the `auth_time` claim was requested, either through a specific request for this claim or by using the `max_age` parameter, the Application should check the `auth_time` claim value and request re-authentication if it determines too much time has elapsed since the last End-User authentication.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If you store ID Tokens on your server, you must do so securely.

</Callout>