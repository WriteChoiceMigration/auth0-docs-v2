---
og:description: Regular web app scenario application implementation
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: アプリケーションの実装（Webアプリ + SSO）
og:url: https://auth0.com/docs/
permalink: part-3
title: アプリケーションの実装（Webアプリ + SSO）
twitter:description: Regular web app scenario application implementation
twitter:title: アプリケーションの実装（Webアプリ + SSO）
---

Let's walk through the implementation of our regular web application. We used ASP .NET Core for the implementation, you can find the code in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-webapp-oidc).

サンプルには、会社の従業員の認証にActive Directory統合を使用し、社外の請負業者用にAuth0データベース接続を使用するアプリケーションが含まれています。認可は、ルールとクレームを使用して実装されており、この段落で詳しく説明します。

## ユーザーログイン

Auth0 provides a Lock widget which serves as a login component for your application, meaning that you do not have to implement your own login screen. The Lock widget seamlessly integrates with all of the connections you configure inside your <Tooltip tip="Auth0 Dashboard: Auth0's main product to configure your services." cta="View Glossary" href="/docs/glossary?term=Auth0+dashboard">Auth0 dashboard</Tooltip>, whether they be database, social or enterprise connections.

WebアプリケーションとAuth0を使用してログイン画面を実装する方法には、いくつかの異なる方法があります。

* **ホストされたLock**：Auth0のインフラストラクチャでホストされているLockウィジェットのインスタンスを使用します。
* **埋め込まれたLock**：アプリケーションのWebページ内にLockウィジェットを埋め込みます。実際のLockウィジェットにはいくつかのカスタマイズオプションがあり、ページ上の他のHTMLを完全に制御できます。
* **Custom UI**: Develop a completely custom web page for the login screen. The custom HTML form will post back to your server which will, in turn, authenticate the user using the Authentication API. For more information on when to use a Custom UI, refer to [Customize Classic Login Pages with Lock or SDK](/docs/customize/login-pages/classic-login/customize-with-lock-sdk).

### 推奨されるベストプラクティスは、ホストされたLockを使用することです。最も安全で、ユーザーがアプリケーションにログインできるようになる最も簡単な方法だからです。

By default, Lock will display all the connections available for login. Selecting the appropriate <Tooltip tip="Identity Provider (IdP): Service that stores and manages digital identities." cta="View Glossary" href="/docs/glossary?term=Identity+Providers">Identity Providers</Tooltip> from multiple options is called Home Realm Discovery (HRD). In our case, the options are either authenticating with Active Directory (for company employees) or using email/password for our database connection (external contractors).

Lockではデフォルトで、ログイン可能なすべての接続が表示されます。複数のオプションから適切なIDプロバイダーを選択することを、「ホーム領域検出（HRD）」と呼びます。今回の事例では、オプションはActive Directory（会社の従業員向け）で認証するか、データベース接続（社外の請負業者向け）にメール/パスワードを使用するかのいずれかとなります。

* しかし、ユーザーがIDプロバイダー（IdP）を選択する必要がある最初のステップを省略し、毎回IdPをたずねるのではなく、システムがこれを特定するようにしたい場合があります。Lockには以下のオプションがあります。

  + There are multiple practical ways of getting the `connection` value. One of them is to use **vanity URLs**: for example, company employees will use `https://internal.yoursite.com`, while external contractors will use `https://external.yoursite.com`.
* `connection`値を取得するための実用的な方法は複数あります。そのうちの1つは、**バニティURL**を使用する方法です。たとえば、会社の従業員は`

For additional information on this topic refer to [Select from Multiple Connection Options](/docs/libraries/lock/selecting-from-multiple-connection-options).

## このトピックに関する追加情報は、「[複数の接続オプションから選択する](/libraries/lock/selecting-from-multiple-connection-options)」を参照してください。

セッション管理

* セッション管理について話す場合、通常、考慮すべき3つのレイヤーのセッションがあります。
* **アプリケーションセッション**：最初のレイヤーはアプリケーションの内部セッションです。アプリケーションがAuth0を使用してユーザーを認証していたとしても、ユーザーがアプリケーションにログインしたという事実を追跡する必要があります。通常のWebアプリケーションでは、これは情報をクッキーに保存することで達成されます。
* **Auth0セッション**：次に、Auth0もセッションを保持し、ユーザーの情報をクッキー内に保存します。次回、ユーザーがAuth0のLock画面にリダイレクトされた時に、ユーザーの情報は保存されます。

**IDプロバイダーセッション**：最後のレイヤーはIDプロバイダー（FacebookやGoogleなど）です。ユーザーがこれらのプロバイダーのいずれかでサインインできるように許可しており、ユーザーがすでにプロバイダーにサインインしている場合、再度サインインを求められることはありません。ユーザーは、Auth0と、そしてひいてはアプリケーションと、情報を共有するための権限を与えるだけで済むかもしれません。

<Info>
### How do I control the duration of the user's local application session? Can I drive that from Auth0?

The web app has full control over the user's local application session. How this is done usually depends on the web stack being used (for example, ASP.NET). Regardless, all approaches ultimately use one or more cookies to control the session. The developer can choose to use the expiration of the JWT ID Token returned by Auth0 to control their session duration or ignore it completely. Some developers store the ID Token itself in session state and end the user's session when it has expired.

The reason why you would use the expiration of the token to determine the expiration of the local session is because it gives you centralized control of the duration of a user session from the Auth0 Dashboard.
</Info>

したがって、Webアプリケーションを開発している場合は、ユーザーがWebアプリケーションにログインしたという事実を追跡する必要があります。これは、クッキーベースのセッションを使用してユーザーがサインインした事実を追跡し、ユーザーに関連する情報やトークンを保存することで行うことができます。

<Frame>![undefined](/images/cdy7uua7fh8z/4bqozVk6fF4JrWRP1BJK7Y/1403eb1c0efb12552307358a26c6e7f7/login-flow.png)</Frame>

1. **Initiate OIDC Authentication Flow**: The user's browser will send a request to Auth0 to initiate the OIDC flow.
2. **Set SSO Cookie**: Auth0 will set a cookie to store the user's information.
3. **Code exchange and return ID Token**: Auth0 will make a request back to the web server and return the code. The web server will exchange the code for an ID Token.
4. **Set auth cookie and send response**: The web server will send a response back to the browser and set the application authentication cookie to store the user's session information.
5. **Auth cookie sent with every subsequent request**: The application authentication cookie will be sent on every subsequent request as proof that the user is authenticated.

<Info>
### How does Auth0's SSO session impact the application's session?

Auth0 manages its own single-sign-on session. Applications can choose to honor or ignore that SSO session when it comes to maintaining their own local session. The Lock widget even has a special feature where it can detect if an Auth0 SSO session exists and ask the user if they wish to log in again as that same user.

<Frame>![Lock Widget SSO](https://cdn2.auth0.com/docs/1.14516.0/media/articles/architecture-scenarios/web-app-sso/sso-login.png)</Frame>

If they do so, they are signed in without having to re-enter their credentials with the actual IDP. Even though the user didn't authenticate, the application still performs an authentication flow with Auth0 and obtains a new ID Token, which can be used to then manage the new local application session.
</Info>

**See the implementation in** [**ASP.NET Core**](/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/implementation-aspnetcore#configure-the-cookie-and-oidc-middleware).

## ユーザーログアウト

ユーザーをログアウトさせる際には、先程話した3つのレイヤーのセッションについて再度考慮する必要があります。

* **アプリケーションセッション**：ユーザーのセッションを消去して、Webアプリケーションからユーザーをログアウトさせる必要があります。
* **Auth0 session**: You need to log out the user from Auth0. To do this you redirect the user to `https://{yourDomain}/v2/logout`. Redirecting the user to this URL clears all <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=single+sign-on">single sign-on</Tooltip> cookies set by Auth0 for the user.
* **Identity Provider session**: Although this is not common practice, you can force the user to log out from the Identity Provider used, for example Facebook or Google. To do this add a `federated` query string parameter to the logout URL: `https://{yourDomain}/v2/logout?federated`.

To redirect a user after logout, add a `returnTo` query string parameter with the target URL as the value: `https://{yourDomain}/v2/logout?returnTo=http://www.example.com`. Note, that you will need to add the `returnTo` URL as an **Allowed Logout URLs**. For more information on how to implement this refer to: [Logout](/docs/authenticate/login/logout).

ログアウトフロー（フェデレーションログアウトを除く）は次のとおりです。

<Frame>![undefined](/images/cdy7uua7fh8z/5t5iXTeGMUzyKHhqOAGRmp/d51797c6513686ea758f0613d01b55d4/logout-flow.png)</Frame>

1. **Initiate Logout Flow**: The logout flow will be initiated from the browser, for example by the user clicking a **Logout** link. A request will be made to the web server.
2. **Clear user’s local session**: The user's Application Session / Cookie will be cleared.
3. **Redirect browser to Auth0 Logout**: The user's browser will be redirected to the Auth0 Logout URL.
4. **Clear SSO Cookie**: Auth0 will clear the user's SSO Cookie.
5. **Redirect to post-logout URL**: Auth0 will return a redirect response and redirect the user's browser to the `returnTo` query string parameter.

**See the implementation in** [**ASP.NET Core**](/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/implementation-aspnetcore#implement-the-logout).

## 認可とは、ユーザーがアプリケーション内で実行できるアクションを決定するプロセスを指します。

Auth0とは独立してアプリケーション内で認可を直接実装するか、使用可能な方法の1つを使用してユーザーの認可レベルを取得し、それをIDトークン内の認可クレームとして設定し、いったんトークンを取得したらアプリケーション内でこれらのクレームを検証してアクセス制御を行うことができます。

You can either implement authorization directly inside your application, independently of Auth0, or use one of the available ways to retrieve the user authorization levels, put them as authorization claims inside the <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+Token">ID Token</Tooltip> and validate these claims inside your application, once you retrieve the token, to control access.

[Auth0認可拡張機能](/extensions/authorization-extension)を構成して使用する。

* By configuring and using the [Auth0 Authorization Extension](/docs/customize/extensions/authorization-extension).
* [ルール](/rules)を利用してユーザープロファイルにメタデータを追加する。
* Add metadata to the user's profile by making use of [rules](/docs/customize/rules).
* 今回の事例では、すでに会社にActive Directoryが設定されているため、Active Directoryグループと組み合わせて認可拡張機能を使用してアクセス制御を強制します。

すべてのユーザーは暗黙的に通常のユーザーとみなされますが、タイムシート管理者は`Admin`グループに割り当てられ、これによりタイムシートの承認が可能になります。Authorization Extension（認可拡張機能）では、グループを既存のグループメンバーシップにマッピングすることができます。

<Card title="Authorization extension">

At this point in time the authorization extension is primarily designed to enforce coarse-grained authorization, for example to control access to an application based on a user's group membership. It is not necessarily designed to control fine-grained access (such as whether a user can perform a specific action inside the application), even though this is how we are utilizing it in this instance.

</Card>

すべてのタイムシート管理者はActive Directoryの`Timesheet Administrators`グループに割り当てられ、これがタイムシートアプリケーション内の`Admin`グループに自動的にマッピングされます。

認可拡張機能をインストールすると、バックグラウンドでルールが作成され、以下の処理が行われます。

認可拡張機能をインストールする

1. Determine the user's group membership.
2. Store the user's group membership info as part of the `app_metadata`.
3. Add the user's group membership to the outgoing token.
4. Verify that the user has been granted access to the current application.

### 認可拡張機能をインストールするには、Auth0 Dashboardの[［Extensions（拡張機能）］](%24%7Bmanage_url%7D/#/extensions)ビューに移動し、Auth0 Authorization拡張機能を選択してインストールします。

To install the Authorization extension navigate to the [Extensions](https://manage.auth0.com/#/extensions) view of your Auth0 Dashboard, and select and install the Auth0 Authorization extension.

リンクをクリックして拡張機能を初めて開くと、Auth0アカウントにアクセスするための許可を拡張機能に与えるよう求めるメッセージが表示されます。許可を与えると、Authorization Dashboard（認可ダッシュボード）にリダイレクトされます。

Authorization Dashboard（認可ダッシュボード）に移動したら、ナビゲーションメニューの［Groups（グループ）］に進み、「Admin」という新しいグループを作成します。

グループが追加されたら、そのグループをクリックしてグループ管理セクションに進むことができます。［Group Mappings（グループマッピング）］タブに移動し、「`Timesheet Admins`」グループのすべてのActive Directoryユーザーを、先ほど作成した「`Admin`」グループにマッピングする新しいグループマッピングを追加します。

<Frame>![undefined](/images/cdy7uua7fh8z/6zOF0mCrLV2rwdpxn9JD1e/5d6e227c4a96260856afd8f94c4212d9/create-admin-group.png)</Frame>

**［Save（保存）］**をクリックすると、新しいマッピングが一覧表示されます。

<Frame>![undefined](/images/cdy7uua7fh8z/RaMHHJ1G9LoO5xoz3BJnN/b01c93948b1a54b599f1eb106bd8ef26/add-group-mapping.png)</Frame>

マッピングが構成されると、Active Directoryの「`Timesheet Admins`」グループのメンバーシップを維持するだけで、これらのユーザーは自動的にアプリケーション内の「`Admin`」グループにマッピングされます。

<Frame>![undefined](/images/cdy7uua7fh8z/1whRHGlsRhGhA6vcrsElsv/093716ca939c843729c3022c810ee6a7/view-group-mapping.png)</Frame>

詳細については、[認可拡張機能に関するドキュメント](/extensions/authorization-extension)を参照してください。

For more information refer to the [Authorization Extension documentation](/docs/customize/extensions/authorization-extension).

### 認証拡張機能をインストールした時に、特定のユーザーに関連するすべての認可設定を含む`authorization`クレームを追加するAuth0ルールも作成されました。ユーザーのグループは、「`groups`」という`authorization`クレームのサブクレームとして追加され、ユーザーが所属するすべてのグループがこのクレームに配列として追加されます。以下は、グループが表示されたIDトークンのJSONペイロードの例です。

したがってアプリケーションでは、ユーザーが認証されたときに返されるIDトークンをデコードし、ユーザーが所属するグループを`authorization`クレームから抽出する必要があります。その後、これらのグループを他のユーザー情報と共にユーザーのセッション内に保存し、それ以降、ユーザーのグループメンバーシップに基づいて、ユーザーが特定のアクションを実行する権限を持っているかどうか判断するためにクエリを実行することができます。

```json lines
{
  "sub": "1234567890",
  "name": "John Doe",
  "authorization": {
    "groups": ["Admin"]
  }
}
```






In your application you will therefore need to decode the ID Token returned when a user is authenticated, and extract the groups which a user belongs to from the `authorization` claim. You can then store these groups, along with other user information inside the user's session, and subsequently query these to determine whether a user has permissions to perform a certain action based on their group membership.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

See the implementation in [ASP.NET Core](/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/implementation-aspnetcore#implement-admin-permissions).

</Callout>