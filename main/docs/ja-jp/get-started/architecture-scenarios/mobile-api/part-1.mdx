---
og:description: Solutions Overview for the Mobile + API architecture scenario
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: ソリューションの概要（モバイルアプリ + API）
og:url: https://auth0.com/docs/
permalink: part-1
title: ソリューションの概要（モバイルアプリ + API）
twitter:description: Solutions Overview for the Mobile + API architecture scenario
twitter:title: ソリューションの概要（モバイルアプリ + API）
---

ExampleCoでは、認可されたユーザーとアプリケーションだけがタイムシートAPIにアクセスできるように、[OAuth 2.00の認可フレームワーク](https://tools.ietf.org/html/rfc6749)を使用することに決めました。このフレームワークは、異なる付与タイプを使用して、タイムシートAPIと通信する必要があるさまざまな種類のアプリケーションを簡単に認可できるため、同社が求めている柔軟性を提供しています。

## API認証と認可

APIは、アプリケーションの機能性を他のアプリケーションに公開する手段になります。アプリケーションは、APIエンドポイントにメッセージを送信することで要求を行い、応答として情報を受信することができます。

APIエンドポイントはセキュリティ保護されている場合と、そうでない場合があります。この例では、タイムシートAPI審査や財務情報などの機密情報であるため、認可されたユーザーとアプリケーションだけがAPIのエンドポイントを呼び出せるようにしなければなりません。クライアントアプリケーションがAPIの保護されたエンドポイントにアクセスしたい場合は、エンドポイントへの呼び出しに必要なアクセス許可を備えている証拠としてアクセストークンを提示する必要があります。

アクセストークンは認証サーバーでユーザーを認証することにより取得され、ユーザーはアプリケーションが自身の代理でAPIにアクセスすることを許可できます。



APIは、APIが公開するさまざまなエンドポイントに誰がアクセスを許可されるかについて、きめ細かい制御を行うことができます。これらのアクセス許可はスコープと呼ばれます。

ユーザーがクライアントアプリケーションを認可すると、アプリケーションは必要とされるアクセス許可も指定することができます。ユーザーはこれらのアクセス許可を確認して付与します。そして、これらのアクセス許可が`scope`クレームの一部としてアクセストークンに含まれます。

その後、クライアントがAPIへの要求でアクセストークンを渡すと、APIは`scope`クレームを調査し、特定のAPIエンドポイントを呼び出すために必要なアクセス許可が付与されていることを確認します。



OAuth 2.0 Authorization Framework使用することで、独自のアプリケーションや社外の請負業者向けのサードパーティアプリケーションは、アプリケーション自体に代わってAPIに制限付きでアクセスできるようになります。Auth0を使用することで、OAuth 2.0/OpenID Connect（OIDC）の仕様や、API認証に関する他の多くの技術的側面を心配することなく、独自のAPIで異なる認証フローを簡単にサポートすることができます。



## Proof Key for Code Exchange（PKCE）

OAuth 2には、異なるユースケースにいくつかの付与タイプが用意されます。この特定のユースケースでは、モバイルアプリケーションからAPIにアクセスしたいとします。そのためには、[Proof Key for Code Exchange（PKCE）を使った認可コードフロー](/login/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)を使用します。

[認証コードフロー](/login/flows/authorization-code-flow)には、ネイティブアプリケーションでの実装に関してセキュリティ上の問題がいくつかあります。たとえば、Auth0から返された`authorization_code`を悪意のある攻撃者が傍受し、これを[アクセストークン](/security/tokens/access-tokens)（場合によっては、[リフレッシュトークン](/security/tokens/refresh-tokens)）と交換する可能性があります。

[RFC 7636](https://tools.ietf.org/html/rfc7636)で定義されているProof Key for Code Exchange（PKCE）は、この認可コードの傍受攻撃を軽減するために用いられる手法です。

アプリケーションはPKCEを使って、それぞれの認可要求に`code_verifier`と呼ばれる暗号的にランダムなキーと、それから生成される`code_challenge`と呼ばれる値を作成します。そして、このキーは`authorization_code`を取得するためにAuth0に送られます。アプリケーションが`authorization_code`を受け取ると、コードと`code_verifier`をAuth0のトークンエンドポイントに送信し、要求されたトークンと交換します。



1. ネイティブアプリはフローを開始して、ユーザーをAuth0（具体的には[/authorize](/api/authentication#authorization-code-grant-pkce-)エンドポイント）にリダイレクトし、`code_challenge`パラメーターと`code_challenge_method`パラメーターを送ります。
2. Auth0は、クエリ文字列に`authorization_code`を持つネイティブアプリにユーザーをリダイレクトします。
3. ネイティブアプリは、`authorization_code`と`code_verifier`を`redirect_uri`と`client_id`と一緒にAuth0に送ります。これは、[/oauth/token endpoint](/api/authentication?http#authorization-code-pkce-)を使って行われます。
4. Auth0はこの情報を検証し、アクセストークン（と任意でリフレッシュトークン）を返します。
5. ネイティブアプリはアクセストークンを使って、ユーザーの代わりにAPIを呼び出します。



## 認可拡張機能

[Auth0のAuthorization Extension（認可拡張機能）](/extensions/authorization-extension)はユーザーにロール、グループとアクセス許可を割り当てることにより、アプリケーション内で認可に対応できるようにします。

認可拡張機能は[ルール](/rules)を作成し、認証フローの中で、ユーザーに割り当てられたロール、グループとアクセス許可を使ってユーザープロファイルを増補します。この情報を使用して、ユーザーに発行されたアクセストークンに、認可拡張機能で定義された権限が許すスコープのみが含まれるようにします。

前のチュートリアル [はじめに](/architecture-scenarios/mobile-api)

次のチュートリアル [2.Auth0の構成](/architecture-scenarios/mobile-api/part-2)