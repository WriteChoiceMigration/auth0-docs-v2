---
og:description: Learn about the various flows used for authentication and authorization
  of applications and APIs.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: 認証フローと認可フロー
og:url: https://auth0.com/docs/
permalink: authentication-and-authorization-flow
sidebarTitle: 認証フローと認可フロー
title: 認証フローと認可フロー
twitter:description: Learn about the various flows used for authentication and authorization
  of applications and APIs.
twitter:title: 認証フローと認可フロー
---

Auth0は[OpenID Connect（OIDC）プロトコル](/protocols/openid-connect-protocol)と[OAuth 2.0認可フレームワーク](/protocols/oauth)を使用して、ユーザーを認証し、保護されたリソースにアクセスするためのユーザーの認可を得ます。Auth0を使うと、OIDC/OAuth 2.0の仕様やその他の[認証・認可](/get-started/authentication-and-authorization)の技術的側面を気にすることなく、独自のアプリケーションとAPIで各種フローを簡単にサポートすることができます。

サーバー側、モバイル、デスクトップ、クライアント側、マシンツーマシン、およびデバイスアプリケーションのシナリオがサポートされています。

使うべきフローの選択でお困りの場合は、「[どのOAuth 2.0フローを使用するべきですか？](/login/flows/which-oauth-2-0-flow-should-i-use)」で詳細をお読みください。



## 認可コードフロー

通常のWebアプリはソースコードが公開されないサーバー側アプリなので、認可コードとトークンを交換する認可コードフローを使用できます。

* [認可コードフロー](/login/flows/authorization-code-flow)
* [認可コードフローを使用してログインを追加する](/login/authentication/add-login-auth-code-flow)
* [認可コードフローを使用してAPIを呼び出す](/login/flows/call-your-api-using-the-authorization-code-flow)

## Proof Key for Code Exchange（PKCE）を使った認可コードフロー

モバイルアプリケーションとネイティブアプリケーションは認証中に認可コードフローを使用できますが、追加のセキュリティ対策が必要です。加えて、シングルページアプリには特別な課題があります。これらのリスクを軽減するため、OAuth 2.0はProof Key for Code Exchange（PKCE）を活用した認可コードフローのバージョンを提供しています。

* [Proof Key for Code Exchange（PKCE）を使った認可コードフロー](/login/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)
* [PKCEを使った認可コードフローでログインを追加する](/login/authentication/add-login-using-the-authorization-code-flow-with-pkce)
* [PKCEを使った認可コードフローでAPIを呼び出す](/login/flows/call-your-api-using-the-authorization-code-flow-with-pkce)

## プライバシー保護を強化した認可コードフロー

[トランザクション認可](/highly-regulated-identity/transactional-authorization-with-authorization-code-flow)のような一部のユースケースでは、認証と認可のプロセス中に、機密データを含む可能性のあるコンテキスト情報を交換します。このデータや機密情報を保護するため、認可コードフローには各種プロトコル改善策を使用できます。

* [Rich Authorization Requests（RAR）を使った認可コードフロー](/authorization-code-flow-with-rar)
* [Pushed Authorization Requests（PAR）を使った認可コードフロー](/authorization-code-flow-with-par)
* [JWT-Secured Authorization Requests（JAR）を使った認可コードフロー](/authorization-code-flow-with-jar)
* [PARとJARを使った認可コードフロー](/authorization-code-flow-with-par-and-jar)
* [JSON Web Encryption（JWE）](/json-web-encryption)

## フォームPOSTを使った暗黙フロー

OAuth 2.0では、認可コードフローの代わりとして、パブリッククライアントや、クライアントシークレットを安全に保存することのできないアプリケーションでの使用を意図した暗黙フローも提供しています。これは現在ではアクセストークンを要求するためのベストプラクティスとはみなされないフローですが、アプリケーションがユーザー認証にIDトークンのみを必要とする場合、フォームPOST応答モードと併用することでワークフローが効率化します。

* [フォームPOSTを使った暗黙フロー](/login/flows/implicit-flow-with-form-post)
* [フォームPOSTを使った暗黙フローでログインを追加する](/login/authentication/add-login-using-the-implicit-flow-with-form-post)
* [クッキーを使ってSPAを認証する](/users/cookies/spa-authenticate-with-cookies)

## ハイブリッドフロー

クライアントシークレットを安全に保存できるアプリケーションには、ハイブリッドフローが有効です。これは認可コードフローと暗黙フローにフォームPOSTを組み合わせたフローで、アプリケーションはIDトークンに即座にアクセスできるとともに、アクセストークンとリフレッシュトークンを安全に取得できます。これは、アプリケーションがユーザー情報に対して即時アクセスを必要とする場合には便利ですが、何らかの処理を行わないと、保護されたリソースに長期間アクセスすることはできません。

* [ハイブリッドフロー](/login/flows/hybrid-flow)
* [ハイブリッドフローを使用してAPIを呼び出す](/login/flows/call-api-hybrid-flow)

## クライアントの資格情報フロー

バックエンドで動作するCLIやデーモン、サービスなどのマシンツーマシン（M2M）アプリケーションでは、システムがユーザーではなくアプリを認証および認可します。このシナリオでは、識別子とパスワードや、ソーシャルログインなどの典型的な認証方式では意味がありません。代わりに、M2Mアプリではクライアントの資格情報フローを使用します（OAuth 2.0 RFC 6749第4.4節に定義）。

* [クライアントの資格情報フロー](/login/flows/client-credentials-flow)
* [クライアントの資格情報フローを使用してAPIを呼び出す](/login/flows/call-your-api-using-the-client-credentials-flow)

## デバイス認可フロー

ユーザーを直接認証するのではなく、入力に制約のあるインターネット接続デバイスでは、コンピューターやスマートフォンのリンクをクリックして、デバイスを認可するようユーザーに求めます。そうすることで、テキストを入力するのに手軽な方法がないデバイスで、ユーザーエクスペリエンスの質が下がることを防ぎます。これを行うために、デバイスアプリではデバイス認可フローを使用します（OAuth 2.0でドラフト作成）。モバイル／ネイティブアプリケーションで使用します。

* [デバイス認可フロー](/login/flows/device-authorization-flow)
* [デバイス認可フローを使用してAPIを呼び出す](/login/flows/call-your-api-using-the-device-authorization-flow)

## Resource Owner Password（リソース所有者のパスワード）フロー

推奨はされませんが、信頼性の高いアプリケーションでは、リソース所有者のパスワードフローを使うことができます。このフローは、ユーザーに資格情報（識別子とパスワード）の提供を要求するもので、通常は対話型フォームを使用します。リソース所有者のパスワードフローの使用は、（[認可コードフロー](/login/flows/authorization-code-flow)のような）リダイレクトベースのフローが使用できない場合にのみ限定すべきです。

* [Resource Owner Password（リソース所有者のパスワード）フロー](/login/flows/resource-owner-password-flow)
* [リソース所有者のパスワードフローを使ってAPIを呼び出す](/login/flows/call-your-api-using-resource-owner-password-flow)

## クライアントが開始するバックチャネル認証フロー



クライアントが開始するバックチャネル認証フロー（CIBA）を使用すると、ユーザーを直接認証するのではなく、クライアントアプリケーションのバックエンドで認証フローが開始され、ユーザーをチャレンジして認証します。認証自体は、別の認証デバイス（通常、カスタムアプリを実行するスマートフォン）で実行されます。

* [クライアントが開始するバックチャネル認証フロー](/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow)
* [CIBAによるユーザー認証](/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow/user-authentication-with-ciba)