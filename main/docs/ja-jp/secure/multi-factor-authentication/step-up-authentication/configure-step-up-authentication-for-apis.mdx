---
og:description: Learn how an API can check if a user has logged in with Multi-factor
  Authentication by examining their access token.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: APIのステップアップ認証を構成する
og:url: https://auth0.com/docs/
permalink: configure-step-up-authentication-for-apis
title: APIのステップアップ認証を構成する
twitter:description: Learn how an API can check if a user has logged in with Multi-factor
  Authentication by examining their access token.
twitter:title: APIのステップアップ認証を構成する
---

ステップアップ認証を使用すると、さまざまな種類のリソースへのアクセスを許可するアプリケーションは、機密情報にアクセスしたり、特定のトランザクションを実行したりするために、より強力なメカニズムを使用してユーザーに認証を要求することができます。

たとえば、銀行アプリのユーザーは、多要素認証（MFA）を使用してIDを確認した後にのみ、口座間で送金することができます。

対象がAPIの場合、スコープ、アクセストークン、および[アクション](/actions)を使用して、Auth0でステップアップ認証を実装できます。アプリケーションがAPIの保護されたリソースにアクセスする場合、アクセストークンを提供する必要があります。アクセスできるリソースは、アクセストークンに含まれる権限によって異なります。これらの権限は[スコープ](/apis/scopes/api-scopes)として定義されます。

## MFAのアクセストークンを検証する

スコープの確認に加えて、APIは[アクセストークンを検証](/security/tokens/access-tokens/validate-access-tokens)して次の操作を行う必要があります。

* トークンの署名を検証します。これは、トークンの送信者が本人であることを確認し、メッセージが途中で変更されていないことを確認するために使用されます。
* 標準クレームを検証します。

## シナリオ：プッシュ通知による銀行取引

次のシナリオでは、アプリケーションがユーザー名とパスワードでユーザーを認証し、口座残高を要求します。口座残高情報を取得する前に、ユーザーはGuardianプッシュファクターで認証する必要があります。

銀行APIは、口座残高の表示（スコープ`view:balance`）または資金の振替（スコープ`transfer:funds`）という2つの異なるレベルの承認を受け入れることができます。アプリケーションがAPIにユーザーの残高の取得を要求する場合、アクセストークンには`view:balance`スコープが含まれている必要があります。別の口座に送金するには、アクセストークンに`transfer:funds`スコープが含まれている必要があります。

### ワークフロー

1. ユーザーは、ユーザー名とパスワードの認証を使用してアプリケーションにログインします。標準ログインにより、このユーザーはAPIと対話して残高を取得できます。つまり、ユーザーが認証した後にアプリが受け取るアクセストークンには、`view:balance`スコープが含まれます。
2. アプリケーションは、アクセストークンを資格情報として使用して、残高を取得する要求をAPIに送信します。
3. APIはトークンを検証し、残高情報をアプリケーションに送信して、ユーザーがそれを表示できるようにします。
4. ユーザーは、あるアカウントから別のアカウントに資金を移動したいと考えています。これは、`transfer:funds`スコープを必要とする高額トランザクションと見なされます。アプリケーションは同じアクセストークンを使用してAPIに要求を送信します。
5. APIはトークンを検証し、トークンに必要な`transfer:funds`スコープがないため、アクセスを拒否します。
6. アプリケーションはAuth0にリダイレクトします。そこで、高額スコープが要求されたため、アクションを使用してユーザーにMFAによる認証を要求します。ユーザーがMFAで正常に認証されると、正しいスコープを含む新しいアクセストークンが生成され、応答の一部としてアプリケーションに送信されます。
7. アプリケーションは、新しいアクセストークンを使用して別の資金振替要求を送信します。このトークンには、今回は`transfer:funds`スコープが含まれています。
8. APIはトークンを検証し、破棄して操作を続行します。

### 前提条件

このシナリオでは、ダッシュボードで次の項目を構成する必要があります。

* [シングルページWebアプリを登録します](/get-started/create-apps/single-page-web-apps)。
* [データベース接続を作成します](%24%7Bmanage_url%7D/#/connections/database)。
* [APIを登録します](/get-started/set-up-apis)。次の2つのスコープを作成します。`view:balance`と`transfer:funds`.
* プッシュ通知を使用するには、[MFAを有効化](/mfa/enable-mfa)します。

### アクションを作成する

`transfer:funds`スコープが要求されたときに、ユーザーにMFAによる認証を要求するアクションを作成します。[［Dashbord］>［Actions（アクション）］>［Flows（フロー）］](%24%7Bmanage_url%7D/#/actions/flows)に移動し、次のコンテンツを含むアクションを作成します。

* `CLIENTS_WITH_MFA`変数には、このアクションを適用するアプリケーションのクライアントIDが含まれます。必要ない場合は、クライアントID（および後続の`if`条件）を削除できます。
* `event.transaction.requested_scopes`プロパティには、認証要求が要求したすべてのスコープが含まれます。値`transfer:funds`が含まれている場合は、`context.multifactor`プロパティを適切な値に設定してMFAを要求します。この場合、[プッシュ](/mfa/mfa-factors/configure-push-notifications-for-mfa)を使用してMFAを要求しています。

### アプリを構成

ユーザーが資金を送金するという高額取引を実行しようとしているかどうかに応じて、適切な認証要求をAPIに送信するようにアプリを構成します。2つの認証要求（MFAの有無）の唯一の違いはスコープであることに注意してください。

* MFAあり：
* MFAなし：



### APIを構成する

受信トークンを検証し、承認された権限を確認するようにAPIを構成します。

1. 次のAPIの2つのエンドポイントを構成します。 
`GET /balance`： 現在の残高を取得します
`POST /transfer`： 資金を送金します
2. `Node.js`と次の複数のモジュールを使用します。

1. [Express](https://expressjs.com/)： Express Webアプリケーションフレームワークを追加します。
2. [jwks-rsa](https://github.com/auth0/node-jwks-rsa)： **JWKS**（JSON Web Key Set）エンドポイントからRSA署名キーを取得します。`expressJwtSecret`を使用すると、JWTヘッダーの`kid`に基づいて`express-jwt`に適切な署名キーを発行するシークレットプロバイダーを生成できます。
3. [express-jwt](https://github.com/auth0/express-jwt): Node.jsアプリケーションでJWTトークンを使用してHTTP要求を認証できます。JWTを使用した作業を容易にする、いくつかの機能が提供されています。
4. [express-jwt-authz](https://github.com/auth0/express-jwt-authz)： アクセストークンに特定のスコープが含まれているかどうかを確認します。
3. 次の依存関係をインストールします。
`npm install express express-jwt jwks-rsa express-jwt-authz --save`
4. APIエンドポイントを定義し、アクセストークンを検証するミドルウェア関数を作成し、そのミドルウェアを使用してエンドポイントを保護します。`server.js`ファイル内のコードは、次のサンプルスクリプトのようになります。
APIが要求を受信するたびに、次の処理が行われます。

1. エンドポイントは`checkJwt`ミドルウェアを呼び出します。
2. `express-jwt`はトークンをデコードし、要求、ヘッダー、ペイロードを`jwksRsa.expressJwtSecret`に渡します。
3. `jwks-rsa`はJWKSエンドポイントからすべての署名キーをダウンロードし、署名キーの1つがアクセストークンのヘッダー内の`kid`と一致するかどうかを確認します。署名キーのいずれも受信`kid`と一致しない場合は、エラーがスローされます。一致する場合は、正しい署名キーを`express-jwt`に渡します。
4. `express-jwt`は独自のロジックを続行して、トークンの署名、有効期限、対象ユーザー、発行者を検証します。
5. `jwtAuthz`は、エンドポイントに必要なスコープがアクセストークンの一部であるかどうかを確認します。指定されたスコープがアクセストークンにない場合、要求は403エラーメッセージで拒否されます。