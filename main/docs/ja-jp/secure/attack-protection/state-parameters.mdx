---
og:description: Describes how to use the state parameter in authentication requests
  to help prevent CSRF attacks and restore state
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: OAuth 2.0の状態パラメーターを使って攻撃を防ぎ、ユーザーをリダイレクトする
og:url: https://auth0.com/docs/
permalink: state-parameters
title: OAuth 2.0の状態パラメーターを使って攻撃を防ぎ、ユーザーをリダイレクトする
twitter:description: Describes how to use the state parameter in authentication requests
  to help prevent CSRF attacks and restore state
twitter:title: OAuth 2.0の状態パラメーターを使って攻撃を防ぎ、ユーザーをリダイレクトする
---

認可プロトコルは`state`パラメーターを提供して、アプリケーションを以前の状態に復元できるようにします。`state`パラメーターは、クライアントが認可要求で設定した状態オブジェクトの一部を保持して、応答でクライアントが使用できるようにします。

## CSRF攻撃

The primary reason for using the `state` parameter is to mitigate [CSRF attacks](https://en.wikipedia.org/wiki/Cross-site_request_forgery) by using a unique and non-guessable value associated with each authentication request about to be initiated. That value allows you to prevent the attack by confirming that the value coming from the response matches the one you sent.

最新のOIDCとOAuth SDKでは、シングルページアプリケーションにAuth0.jsが含まれており、状態の生成と検証が自動的に処理されます。

A CSRF attack specifically targets state-changing requests to initiate an action instead of getting user data because the attacker has no way to see the response to the forged request. For the most basic cases the state parameter should be a <Tooltip tip="Nonce: Arbitrary number issued once in an authentication protocol to detect and prevent replay attacks." cta="View Glossary" href="/docs/glossary?term=nonce">nonce</Tooltip>, used to correlate the request with the response received from the authentication.

Most modern OIDC and <Tooltip tip="OAuth 2.0: Authorization framework that defines authorization protocols and workflows." cta="View Glossary" href="/docs/glossary?term=OAuth">OAuth</Tooltip> SDKs, including Auth0.js in single-page applications, handle the state generation and validation automatically.

### 要求を送信すると、Auth0がユーザーをアプリケーションにリダイレクトで戻します。`state`値が含まれています。使用している接続の種類に応じて、この値が要求のボディか、クエリ文字列に挿入されます。

1. Before redirecting a request to the Identity Provider (IdP), have the app generate a random string. For example:

   ```text lines
   xyzABC123
   ```

   ユーザーをリダイレクトする
2. Store the string locally. For example:

   ```text lines
   storeStateLocally(xyzABC123)
   ```


   

   
3. Add the `state` parameter to the request (URL-encoding if necessary). For example:

   ```javascript lines
   // Encode the String   
   tenant.auth0.com/authorize?...&state=xyzABC123
   ```


   

   

   nonceを生成して、リダイレクトURLなどの必要な状態データと共に、ローカル（Cookieやセッション、ローカルストレージ）に保管します。nonceをプロトコルメッセージで状態として使用します。返された状態が保管しているnonceと一致する場合には、OAuth2メッセージを受け入れて、対応するデータをストレージから取得します。これが、auth0.jsで使用されている方法になります。

   ```text lines
   /callback?...&state=xyzABC123
   ```


   

   
4. Retrieve the returned `state` value and compare it with the one you stored earlier. If the values match, then approve the authentication response, else deny it.

   ```javascript lines
   // Decode the String
   var decodedString = Base64.decode(encodedString);
   if(receivedState === retrieveStateStoredLocally()) {
    // Authorized request
   } 
   else {
     // This response is not for us, reject it
   }
   ```


   

   

## 保管されているURLを使ってユーザーをリダイレクトする

代替のリダイレクト方法

制限と考慮事項

### 保管する方法はアプリケーションの種類に基づいて選択してください。

1. Set the nonce state parameter value that you used to mitigate CSRF攻撃 as explained above.
2. Store the nonce locally, using it as the key to store all the other application state information such as the URL where the user intended to go. For example:

   ```json lines
   {
     "xyzABC123" : {
       redirectUrl: '/protectedResource',
       expiresOn: [...]
     }
   }
   ```


   

   
3. Authenticate the user, [sending the generated nonce as the state](/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).
4. As part of the callback processing and response validation, verify that the state returned matches the nonce stored locally. If it does, retrieve the rest of the application state (like the `redirectUrl`).
5. Once you complete the callback processing, redirect the user to the URL previously stored.

### セキュリティの観点からすれば、要求も応答も整合性が保護されたものではないため、ユーザーの操作が可能です。これは、パラメーターを`redirect_uri`に追加する場合も同様です。

1. Generate and store a nonce value locally.
2. Encode any desired state (like the redirect URL) along with the nonce in a protected message (that will need to be encrypted/signed to avoid tampering).
3. In the response processing, unprotect the message, getting the nonce and other properties stored.
4. Validate that the included nonce matches what was stored locally and, if so, accept the OAuth2 message.

## 状態パラメーター値の長さは無限ではありません。`414 Request-URI Too Large`エラーが表示された場合は、より小さい値を試してください。

* URLをプレーンテキストや他の推測可能な方法で渡すのは危険です。状態パラメーターの値については、以下を必ず守ってください。

  <table class="table"><thead>
  <tr>
  <th>App Type</th>
  <th>Storage Recommendation</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>Regular Web App</td>
  <td>Cookie or session</td>
  </tr>
  <tr>
  <td>SPA</td>
  <td>Local browser</td>
  </tr>
  <tr>
  <td>Native App</td>
  <td>Memory or local</td>
  </tr>
  </tbody>
  </table>
* CSRF攻撃やフィッシング攻撃からの防御に使えるように、一意で不透明なものにします。
* Cookieに保管する場合には、改ざんを防ぐために必ず署名します。
* Passing URLs in plaintext or in any predictable way is unsafe. Ensure that the state parameter value is:

  + Unique and opaque to ensure that it can be used for defense against CSRF and phishing attacks.
  + If stored in a cookie, it should be signed to prevent forgery.

## Learn more

* [Which OAuth 2.0 Flow Should I Use?](/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)
* [Sessions](/docs/manage-users/sessions)