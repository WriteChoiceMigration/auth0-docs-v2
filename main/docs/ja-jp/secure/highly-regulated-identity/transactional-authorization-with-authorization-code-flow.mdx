---
og:description: Learn about how Highly Regulated Identity enables transactional authorization
  with the Authorization Code Flow.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: コンテキストに基づいた強力な顧客認証を使用したトランザクション認可
og:url: https://auth0.com/docs/
permalink: transactional-authorization-with-authorization-code-flow
title: コンテキストに基づいた強力な顧客認証を使用したトランザクション認可
twitter:description: Learn about how Highly Regulated Identity enables transactional
  authorization with the Authorization Code Flow.
twitter:title: コンテキストに基づいた強力な顧客認証を使用したトランザクション認可
---

Highly Regulated Identity enables Transactional Authorization with the [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) by applying step-up <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=multi-factor+authentication">multi-factor authentication</Tooltip> (MFA) to authorize a transaction. Step-up MFA challenges the user with a second authentication factor to explicitly authorize the transaction details of a one-time operation, which is useful in use cases that require financial-grade security:

* 銀行間振込、操作履歴へのアクセス、アクセス認証情報の変更の承認など、自身のサービスで実行する機密性の高い操作のセキュリティ保護。
* 電子決済の承認や、アカウント検証への1回限りのアクセス許可など、サードパーティーサービスから要求される機密性の高い操作のセキュリティ保護。

This article walks you through the end-to-end journey of approving a bank transfer. The same transactional <Tooltip tip="Authorization Flow: Authorization grant (or workflow) specified in the OAuth 2.0 framework." cta="View Glossary" href="/docs/glossary?term=authorization+flow">authorization flow</Tooltip> can be applied to other use cases.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

You must configure transactional authorization for each API. Once activated, it applies to the scopes and `authorization_details.types` for that API.

</Callout>

## 前提条件

<Warning>

Do not pass fine-grained transaction authorization data or other sensitive or regulated data outside of `authorization_details`.

</Warning>

Before getting started, follow the instructions in [Configure Rich Authorization Requests](/docs/get-started/apis/configure-rich-authorization-requests) to register the `authorization_details.types` for your API or <Tooltip tip="Resource Server: Server hosting protected resources. Resource servers accept and respond to protected resource requests." cta="View Glossary" href="/docs/glossary?term=resource+server">resource server</Tooltip>.

## `transactional-authorization-with-mfa`を`consent_policy`に設定します。

使用する`authorization_details.types`を登録します。

1. Securely redirect the user to Auth0 with the transaction details. In this step, avoid revealing sensitive information on the front channel (e.g. the browser).
2. [OAuthの相互TLS（mTLS）](/authenticate-with-mtls) after the user authenticates. Using [Actions](/docs/customize/actions), you can dynamically decide on the next steps based on the transaction details and other information you may get from sources such as external APIs. To learn more, read [Apply dynamic policy](#apply-dynamic-policy).
3. Challenge the user with a second authentication factor and show transaction details for the user to explicitly approve. This step depends on the authentication factor you chose to apply using Actions.
4. Get the access token and proceed with the sensitive operation. Your API validates the approved transaction details associated with the access token.

<Frame>![](/images/cdy7uua7fh8z/6VYcY5YJRT9Ngaomj5f9yi/ea5f0caa41a7db330a1c1d980ce7116c/Transactional_Authorization__1_.png)</Frame>

エンドツーエンドのフロー

### 以下の図は、コンテキストに基づいたSCAを使用したトランザクション認可のエンドツーエンドのフローを示しています。以下の4つの主要な段階があります。

以下のセクションでは、各段階について詳細に説明します。

To meet financial-grade security standards, Highly Regulated Identity uses Pushed Authorization Requests (PAR) to hide transaction details from the browser. Instead of sending query parameters through the browser to the `/authorize` endpoint, PAR directly sends parameters from your backend to a special `/par` endpoint using a POST request. To learn how to set it up, read [Configure Pushed Authorization Requests](/docs/get-started/applications/configure-par).

Auth0での認証後、ユーザーは最初にWebアプリケーションにアクセスします。このユースケースの例に従うと、その後ユーザーは、連絡先の１つへの送金を要求します。

```json lines
"authorization_details": [
 {
   "type": "money_transfer",
   "instructedAmount": {
     "amount": 150,
     "currency": "USD"
   },
   "sourceAccount": "xxxxxxxxxxx1234",
   "destinationAccount": "xxxxxxxxxxx9876",
   "beneficiary": "Hanna Herwitz",
   "subject": "A Lannister Always Pays His Debts"
 }
]
```






Use Actions to inspect the `authorization_details` to determine which authentication factors to use based on the transaction. To learn more about `authorization_details` and how to use it along PAR, read [Authorization Code Flow with Rich Authorization Requests](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar).

If you want to meet FAPI 1 Advanced Security compliance requirements, you must also use public key cryptography to authenticate the backend against the `/par` or the `/token` endpoint. This is more secure than sending a <Tooltip tip="Client Secret: Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable." cta="View Glossary" href="/docs/glossary?term=Client+Secret">Client Secret</Tooltip>. Auth0 offers the following public key cryptography authentication methods:

* [Private Key JWT](/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)
* [mutual-TLS (mTLS) for OAuth](/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls)

[秘密鍵JWT](/authenticate-with-private-key-jwt)

### [OAuthの相互TLS（mTLS）](/authenticate-with-mtls)

When the user logs in without using <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=SSO">SSO</Tooltip> and the browser hits your Auth0 tenant’s `/authorize` endpoint, Auth0 will attempt to authenticate the user. In our example of approving a bank transfer, Auth0 has already authenticated the user to access your web application. However, when a third party redirects the user, such as for a digital payment, Auth0 presents a login screen to the user. To learn more about the authentication flow, read the [Authenticate](/docs/authenticate) documentation.

Once Auth0 has successfully authenticated the user, Auth0 triggers post-login [Actions](/docs/customize/actions), which expose transaction details about the user, app, authentication factor(s) used, and more in the [post-login event object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-event-object). Within the post-login event object, the `event.transaction.requested_authorization_details` property contains details about the authorization request that were received in the previous step.

Use the [post-login event object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-event-object) to decide how you want to proceed with the transaction. For example, you can send transaction details to an external risk engine, and after evaluating the risk level, determine whether to request step-up authentication using sms, as illustrated in the following code sample.

```js lines expandable
exports.onExecutePostLogin = async (event, api) => {
  if (event.transaction?.requested_authorization_details.some(e => e.type === 'money_transfer')) {
      const axios = require('axios');

      //details to contact risk evaluation engine
      const risk_url = 'https://risk.example.org/score';
      const risk_options = {
        headers: {
          'Content-Type': 'application/json'
        }
      };

      const tx_data = {
        email: event.user.email,
        authorization_details: event.transaction?.requested_authorization_details
      };

      //send operation details to risk evaluation engine
      var risk = await axios.post(risk_url, tx_data, risk_options);

      //if it is a risky operation use push to authorize
      if (risk.data.score >= 2) {
        api.authentication.challengeWith({ type: 'push-notification', options: {otpFallback: false}});

      }
    }
};
```






### Auth0がユーザーの認証に成功したら、Auth0は、ログイン後の[Actions](/actions)をトリガーし、ユーザー、アプリ、使用された認証要素に関するトランザクション詳細、さらに[ログイン後のイベントオブジェクト](/signup-and-login-triggers/login-trigger/post-login-event-object)の詳細を公開します。ログイン後のイベントオブジェクト内の`event.transaction.requested_authorization_details`プロパティには、前段階で受け取った認証要求に関する詳細が含まれています。

You can customize what authentication factor to use depending on factors enrolled by the user, factors already satisfied by the session, and/or your own preferences. You can also provide alternatives for the user to choose from. To learn more, read [Customize MFA Selection in New Universal Login](/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).

Additionally, for SMS, email, and WebAuthn, you can customize the consent screen that Auth0 presents to the user with the information you want to show from authorization_details and other transaction details. To learn more, read [Configure Rich Authorization Requests](/docs/get-started/apis/configure-rich-authorization-requests). For push notifications, this does not apply as the mobile application is the one showing the transaction details to the end user.

ユーザーが登録した要素、セッションにより満たされた要素、および/またはご自身の好みに応じて、使用する認証要素をカスタマイズできます。また、ユーザーが選択できる代替手段も提供できます。詳細については、「[新しいユニバーサルログインでのMFA選択をカスタマイズする](/customize-mfa-selection-universal-login)」をご覧ください。

#### さらにSMS、メール、WebAuthnについては、authorization_detailsおよびその他のトランザクションの詳細からの表示したい情報を使用して、Auth0がユーザーに表示する同意画面をカスタマイズできます。詳細については、「[Rich Authorization Requests（RAR）を構成する](/configure-rich-authorization-requests)」をお読みください。プッシュ通知については、モバイルアプリケーションがエンドユーザーにトランザクション詳細を表示するため、これが適用されません。

以下のセクションでは、トランザクション認可のために構成できる様々な認証要素について説明します。

<Frame>![](/images/cdy7uua7fh8z/4mEJTT4VsAAAb6I0HhJI6r/851fe5ff489bfc9e5aaa2c52b4644f2c/Mobile_Push_-_English.png)</Frame>

プッシュ通知

To display the `authorization_details` to the user, the mobile application must retrieve them from the `txlnkid` parameter. The [Auth0 Guardian SDK](/docs/secure/multi-factor-authentication/auth0-guardian) passes the `txlnkid` parameter from the tenant to the mobile application via a push notification.

プッシュ通知については、モバイルアプリケーションが、明示的な承認のためにユーザーにトランザクション詳細を表示する責任を負います。これを行うには、Actionsを使用して、ユーザーに表示したいトランザクション詳細と一緒に`linking_id`を外部サーバーまたはエンドポイントに保管して、たったの数分で利用できるようにします。その後、以下のコード例で示すように、プッシュ通知でユーザーにチャレンジします。`otpFallback: false`のオプションを追加して、OTPを手動で入力するフォールバックのオプションを禁止することを忘れないでください。

<Tabs><Tab title="iOS">

```swift lines
let device: AuthenticationDevice = // the object you obtained when enrolling
if let consentId = notification.transactionLinkingId {
    Guardian
        .consent(forDomain: {yourTenantDomain}, device: device)
        .fetch(consentId: consentId, notificationToken: notification.transactionToken)
        .start{result in
            switch result {
            case .success(let payload):
                let authorizationDetails = payload.requestedDetails.authorizationDetails
            case .failure(let cause):
                // something went wrong
        }
    }
}
```






</Tab><Tab title="Android">

```kotlin lines
if (notification.getTransctionLinkingId() != null) {
    guardian
      .fetchConsent(notification, enrollment)
      .start(new Callback<Enrollment> {
        @Override
        void onSuccess(RichConsent consentDetails) {
          List<Map<String, Object>> authorizationDetails = consentDetails
                .getRequestedDetails()
                .getAuthorizationDetails();
        }

        @Override
        void onFailure(Throwable exception) {
          if (exception instanceof GuardianException) {
            GuardianException guardianException = (GuardianException) exception;
            if (guardianException.isResourceNotFound()) {
              // there is no consent associated with the transaction
            }
          }
          // something went wrong
        }
      });
}
```






</Tab></Tabs>

From the post-login Action, you can call `api.multifactor.enable()` before `api.authentication.challengeWith()` to remove the option to remember this device and force the user to validate the push challenge for all transactions. To learn more, read [Action Triggers: post-login - API object](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-api-object).

**注意：**プッシュ通知を開くユーザーのIDを検証するには、モバイルアプリケーションに生体認証を追加できます。詳細については、「[MFAのためにデバイス生体認証を使ってWebAuthnを構成する](/mfa/mfa-factors/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)」をご覧ください。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

To verify the identity of the user opening the push notification, you can add biometric authentication to the mobile application. To learn more, read [Configure WebAuthn with Device Biometrics for MFA](/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa).

</Callout>

#### SMS、メール、WebAuthn

You can also set up phone, email, or WebAuthn as authentication factors to challenge the user. For these authentication factors, Auth0 prompts the user with the corresponding MFA waiting screen. After the user validates the challenge on the MFA waiting screen, Auth0 shows the transaction details to the user for explicit approval. Remember you have to [Configure Rich Authorization Requests](/docs/get-started/apis/configure-rich-authorization-requests) for the approval step to work properly.

携帯電話の認証要素については、Auth0は、SMSまたは音声を通して、ユーザーに検証コードを送信します。以下のスクリーンショットは、Auth0がSMSを通してコードを送信した後のMFA待ち画面を示しています。

<Frame>![](/images/cdy7uua7fh8z/kYn2A0p2jTY5CUn1FsjVf/b926a1689ee9722e6b902e433a77223b/Phone_Challenge_-_English.png)</Frame>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

From Actions, you can call `api.multifactor.enable('any', { allowRememberBrowser: false })` before `api.authentication.challengeWith` to remove the option to remember this device and force the user to validate the push challenge for all transactions.

</Callout>

ユーザーは、検証コードが記載されたSMSを受け取ります。

ユーザーがMFA待ち画面に検証コードを入力したら、Auth0は、同意画面でトランザクション詳細をユーザーに提示します。ユーザーがトランザクション詳細を承認または拒否したら、トランザクションは、[操作の完了](#complete-the-operation)の段階へと進みます。

メールおよびWebAuthnは、同じトランザクション承認フロー、および類似のMFA待ち画面と明示的な承認画面を使用します。

<Warning>

Under PSD2, [email is not a valid authentication factor](https://www.eba.europa.eu/sites/default/documents/files/documents/10180/2622242/4bf4e536-69a5-44a5-a685-de42e292ef78/EBA%20Opinion%20on%20SCA%20elements%20under%20PSD2%20.pdf) for Strong Customer Authentication. We recommend you use another authentication factor to challenge users to meet PSD2 compliance.

</Warning>

#### チャレンジなし

第二認証要素でユーザーにチャレンジしない場合、Auth0は、同意画面で、トランザクション詳細の明示的な承認をユーザーに求めます。

### 操作の完了

To complete the operation, Auth0 follows the standard [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow). If the transaction is approved, the user browser is redirected to your application with an authorization code, which is then exchanged for an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> encrypted using [JSON Web Encryption](/docs/secure/tokens/access-tokens/json-web-encryption). The access token contains the `authorization_details` that you originally passed. The following code sample shows the contents of a decrypted access token:

```json lines
{
 "iss": "https://my_tenant.auth0.com/",
 "sub": "auth0|me",
 "aud": "https://myapi.zewobnak.com",
 "iat": 1683661385,
 "exp": 1683747785,
 "azp": "my_client",
 "transaction_linking_id": "ce4842e8-2894-418a-b1f9-39a330cd4911",
 "authorization_details": [
   {
     "type": "money_transfer",
     "instructedAmount": {
       "amount": 150,
       "currency": "USD"
     },
     "sourceAccount": "xxxxxxxxxxx1234",
     "destinationAccount": "xxxxxxxxxxx9876",
     "beneficiary": "Hanna Herwitz",
     "subject": "A Lannister Always Pays His Debts",
   }
 ]
}
```






送金を促すAPIにアクセストークンを渡します。その後APIは、金額、送信元、送信先などのトランザクション詳細を検証するために、アクセストークンの`authorization_details`を確認します。検証後、送金が正常に実行され、承認画面が表示されます。

いずれかの段階でトランザクションが拒否された場合、ユーザーブラウザは、`access_denied`エラーコードを表示します。