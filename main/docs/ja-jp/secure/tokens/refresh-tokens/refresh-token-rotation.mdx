---
og:description: Describes how refresh token rotation provides greater security by
  issuing a new refresh token with each request made to Auth0 for a new access token
  by a client using refresh tokens.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: リフレッシュトークンのローテーション
og:url: https://auth0.com/docs/
permalink: refresh-token-rotation
title: リフレッシュトークンのローテーション
twitter:description: Describes how refresh token rotation provides greater security
  by issuing a new refresh token with each request made to Auth0 for a new access
  token by a client using refresh tokens.
twitter:title: リフレッシュトークンのローテーション
---

<Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+token">Refresh token</Tooltip> rotation is a technique for getting new <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip> using refresh tokens that goes beyond [silent authentication](/docs/authenticate/login/configure-silent-authentication). Refresh tokens are typically longer-lived and can be used to request new access tokens after the shorter-lived access tokens expire. Refresh tokens are often used in native applications on mobile devices in conjunction with short-lived access tokens to provide seamless UX without having to issue long-lived access tokens.

With <Tooltip tip="Refresh Token Rotation: Strategy of frequently replacing refresh tokens to minimize vulnerability. With refresh token rotation, every time your application exchanges a refresh token to get a new access token, Auth0 also returns a new refresh token." cta="View Glossary" href="/docs/glossary?term=refresh+token+rotation">refresh token rotation</Tooltip> enabled in the <Tooltip tip="Refresh Token Rotation: Strategy of frequently replacing refresh tokens to minimize vulnerability. With refresh token rotation, every time your application exchanges a refresh token to get a new access token, Auth0 also returns a new refresh token." cta="View Glossary" href="/docs/glossary?term=Auth0+Dashboard">Auth0 Dashboard</Tooltip>, every time an application exchanges a refresh token to get a new access token, a new refresh token is also returned. Therefore, you no longer have a long-lived refresh token that, if compromised, could provide illegitimate access to resources. As refresh tokens are continually exchanged and invalidated, the threat is reduced.

The way refresh token rotation works in Auth0 conforms with the [OAuth 2.0 BCP](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-4.12) and works with the following flows:

* [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)
* [Authorization Code Flow with Proof Key for Code Exchange](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)
* [Device Authorization Flow](/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)
* [Resource Owner Password Flow](/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)

## SPAでユーザーセッションを維持する

Until very recently, SPAs maintained the user’s session by using the Authorization Code Flow with PKCE in conjunction with silent authentication. Recent developments in browser privacy technology, such as Intelligent Tracking Prevention (ITP) prevent access to the Auth0 <Tooltip tip="Session Cookie: Entity that, when present, allows the user to be considered authenticated." cta="View Glossary" href="/docs/glossary?term=session+cookie">session cookie</Tooltip>, thereby requiring users to reauthenticate.

<Frame>![Refresh Token Rotation Maintain User Sessions in SPAs diagram](/images/cdy7uua7fh8z/3sf7RRsy81bt3zcXMnHUSe/2171fdab4ffeb0987c329aa897038abc/rt-and-at.png)</Frame>

残念ながら、意図されたアプリケーションのみにアクセスを保証できるような永続ストレージのメカニズムがブラウザーにはないため、寿命の長いリフレッシュトークンはSPAには適していません。これら高価値のアーティファクトを手に入れるためや、悪意ある行為者に保護されたリソースへのアクセス権を付与させるために悪用され得る脆弱性があるため、SPAでリフレッシュトークンを使用することは断固としてお勧めできません。

リフレッシュトークンのローテーションは、ブラウザーのプライバシー保護メカニズムが原因で、エンドユーザーのセッションが失われてしまうという不都合を改善します。リフレッシュトークンのローテーションはAuth0のセッションCookieにアクセスしないため、ITPやそれに類似した保護メカニズムの影響を受けません。

以下の図は、リフレッシュトークンのローテーションがどのようにして、PKCEを使った認可コードフローと併せて使用されるのかを表していますが、交換時に新しいリフレッシュトークンの取得に適用される一般原則は、すべての対応するフローに適用されます。

<Frame>![Refresh Token Rotation Maintain User Sessions in SPAs State diagram](/images/cdy7uua7fh8z/41avsR2u0B4fSP3Bwh0WZz/d803a9057ea6e606d602c7c97d99fc3a/rtr-state-diagram.png)</Frame>

つまり、ブラウザーのプライバシー保護ツールがもたらす副作用を軽減するために、リフレッシュトークンを安全に使用して、ユーザーエクスペリエンスを損なうことなく、エンドユーザーに継続してアクセスできるということになります。

## 再利用の自動検出

クライアントは、新しいアクセストークンが必要になると、新しいトークンのペアを取得するために、Auth0へ要求を添えてリフレッシュトークンを送信します。Auth0が新しいトークンのペアを発行すると、要求に使用されたリフレッシュトークンが即座に失効します。こうすることで、トークンの侵害によって起きるリプレイ攻撃からアプリを保護します。

Without enforcing sender-constraint, it’s impossible for the <Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/docs/glossary?term=authorization+server">authorization server</Tooltip> to know which actor is legitimate or malicious in the event of a replay attack. So it’s important that the most recently issued refresh token is also immediately invalidated when a previously-used refresh token (already invalidated) is sent to the authorization server. This prevents any refresh tokens in the same token family (all refresh tokens descending from the original refresh token issued for the client) from being used to get new access tokens.

たとえば、以下のシナリオを考えてみてください。

<Frame>![Refresh Token Rotation Reuse Detection state diagram](/images/cdy7uua7fh8z/33fe73R81Cpm6eTmOWfAnm/e7d168edc27861507a121910b32f1ee2/reuse-detection1.png)</Frame>

1. Legitimate Client has **refresh token 1**, and it is leaked to or stolen by Malicious Client.
2. Legitimate Client uses **refresh token 1** to get a new refresh token/access token pair.
3. Auth0 returns **refresh token 2/access token 2**.
4. Malicious Client then attempts to use **refresh token 1** to get an access token. Auth0 recognizes that refresh token 1 is being reused, and immediately invalidates the refresh token family, including **refresh token 2**.
5. Auth0 returns an access denied response to Malicious Client.
6. **Access token 2** expires and Legitimate Client attempts to use **refresh token 2** to request a new token pair. Auth0 returns an access denied response to Legitimate Client.
7. Re-authentication is required.

This protection mechanism works regardless of whether the legitimate client or the malicious client is able to exchange **refresh token 1** for a new token pair before the other. As soon as reuse is detected, all subsequent requests will be denied until the user re-authenticates. When reuse is detected, Auth0 captures detected reuse [events](/docs/deploy-monitor/logs/log-event-type-codes) (such as `ferrt` indicating a failed exchange) in logs. This can be especially useful in conjunction with Auth0’s [log streaming](/docs/customize/log-streams) capabilities to detect suspicious activity.

別の例として、悪意のあるクライアントが**リフレッシュトークン1**を盗んで使用し、正当なクライアントが**リフレッシュトークン1**を使用する前に、アクセストークンを取得したとします。この場合、以下の図が示すように、正当なクライアントが**リフレッシュトークン1**を使用すると即座に**リフレッシュトークン2**（および後続して発行されたすべてのリフレッシュトークン）が自動的に取り消されるため、悪意のあるクライアントがアクセス権を悪用できる期間が短縮されます。

<Frame>![Refresh Token Rotation Reuse Detection State diagram](/images/cdy7uua7fh8z/36rAUgLOAqW7k7Fdl1eRN1/c1a57be5093416b50d42ec41a1e3a233/reuse-detection2.png)</Frame>

## SDKサポート

以下のSDKは、リフレッシュトークンのローテーションと再利用の自動検出に対応しています。

* Auth0 SPA SDK
* Flutter (Web)
* Swift (iOS) SDK
* Android SDK
* Flutter
* React Native SDK
* WPF / Winforms
* Xamarin

For documentation specific to these SDKs, visit the [Auth0 SDK Libraries](/docs/libraries) page.

You can choose to store tokens in either local storage or browser memory. The default is in browser memory. See [Token Best Practices](/docs/secure/tokens/token-best-practices) for recommendations about token storage. You must enable offline access and request the offline access scope in the client SDK.

## Learn more

* [Configure Refresh Token Rotation](/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)
* [Disable Refresh Token Rotation](/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation)
* [Configure Refresh Token Expiration](/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)
* [Token Best Practices](/docs/secure/tokens/token-best-practices)