---
og:description: Lists best practices when using tokens in authentication and authorization.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: トークンのベストプラクティス
og:url: https://auth0.com/docs/
permalink: token-best-practices
title: トークンのベストプラクティス
twitter:description: Lists best practices when using tokens in authentication and
  authorization.
twitter:title: トークンのベストプラクティス
---

以下はトークンを使うときに考慮するべき内容の一部です。

* **機密を守り、安全を守る**：署名鍵は他の資格情報と同様に扱って、必要なサービスにのみ公開します。
* **ペイロードには機密データを追加しない**：トークンは不正な操作から保護するために署名され、簡単にデコードされます。性能と安全性を最大限発揮できるように、ペイロードには必要最小限のクレームを追加します。
* **トークンに有効期限を指定する**：技術的に、署名されたトークンは、署名鍵が変わったり、有効期限が明示的に設定されない限り、永久的に有効になります。これは潜在的な問題となるため、トークンの有効期限や失効させる方法を設けておくようにします。
* **HTTPSを利用する**：要求の傍受やトークンの侵害などの懸念があるため、トークンはHTTPS以外の接続で送信しないようにします。
* **認可のユースケースをすべて考慮する**：独自のサーバーで生成されたトークンであることを確実にするために、二次的なトークン検証システムを追加して、要件を満たす必要があるかもしれません。
* **Store and reuse:** Reduce unnecessary roundtrips that extend your application's attack surface, and optimize plan token limits (where applicable) by storing <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip> obtained from the <Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/docs/glossary?term=authorization+server">authorization server</Tooltip>. Rather than requesting a new token, use the stored token during future calls until it expires. How you store tokens will depend on the characteristics of your application: typical solutions include databases (for apps that need to perform API calls regardless of the presence of a session) and HTTP sessions (for apps that have an activity window limited to an interactive session). For an example of server-side storage and token reuse, see [Token Storage](/docs/secure/security-guidance/data-security/token-storage).

## トークンとクッキー

Typically, single-page apps (such as React, Vue, and AngularJS + Node), native mobile apps (such as iOS and Android), and web APIs (written in Node, Ruby, ASP.NET, or a mix of those) benefit most from token-based authentication. Traditional, server-side web applications have traditionally used cookie-based authentication.

Token-based authentication is implemented by generating a token when the user authenticates and then setting that token in the `Authorization` header of each subsequent request to your API. You want that token to be something standard, like <Tooltip tip="JSON Web Token (JWT): Standard ID Token format (and often Access Token format) used to represent claims securely between two parties." cta="View Glossary" href="/docs/glossary?term=JSON+web+tokens">JSON web tokens</Tooltip> since you will find libraries in most of the platforms and you don't want to do your own crypto.

どちらの方法でも、ユーザーから同じ量の情報を取得することができます。これは、（Lock、JavaScriptライブラリ、またはプレーンリンクを使って）ログイン要求で送信される`scope`パラメーターによって制御されます。`scope`は、`.signin({scope:'openid name email'})`メソッドのパラメーターで、ログイン要求ではクエリ文字列の一部になります。

By default, we use `scope=openid` in token-based authentication to avoid having a huge token. You can control any standard <Tooltip tip="OpenID: Open standard for authentication that allows applications to verify users' identities without collecting and storing login information." cta="View Glossary" href="/docs/glossary?term=OpenID">OpenID</Tooltip> Connect (OIDC) claims that you want to get in the token by adding them as scope values. For example, `scope=openid name email family_name address phone_number`. To learn more, see [Standard Claims on openid.net](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).

You can mix token-based authentication with cookie-based authentication. Take into account that cookies will work just fine if the web app and the API are served from the same domain, so you might not need token based authentication. If you need to, we also return a JWT on the web app flow. Each of our SDKs will do it differently. If you want to call your APIs from JavaScript(instead of using the existing cookie), then you have to set the access tokens using Web Workers or JavaScript closures to handle token transmissions and storage. To learn more, read the Browser in-memory scenarios section of our [Token Storage](/docs/secure/security-guidance/data-security/token-storage) page.

## リフレッシュトークンの使用

You can only get a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+token">Refresh token</Tooltip> if you are implementing the following flows:

* [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow)
* [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/add-login-using-the-authorization-code-flow-with-pkce)
* [Resource Owner Password Flow](/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)
* [Device Authorization Flow](/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)

If you limit offline access to your API, a safeguard configured via the **Allow Offline Access** switch at [Auth0 Dashboard > Applications > APIs > Settings](https://manage.auth0.com/#/apis), Auth0 will not return a Refresh Token for the API (even if you include the `offline_access` scope in your request).

ルールはリフレッシュトークンの交換で実行されます。特別なロジックを実行するには、ルール内の`context.protocol`プロパティを確認してください。値が`oauth2-refresh-token`の場合、ルールは交換中に実行されます。

When trying to get a refresh token, the <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> parameter is not available on the Rules context object. If you receive an error when attempting to add the audience parameter, verify that you do not have it set on the token.

ルールを使ってカスタムクレームをトークンに追加した場合には、ルールが存在している限り、リフレッシュトークンを使用すると、新しいトークンにカスタムクレームが含まれます。新しいトークンはカスタムクレームを自動的には継承しませんが、リフレッシュトークンフローでルールが実行されるため、同じコードが実行されます。これによって、認可済みのアプリケーションに新しいリフレッシュトークンの取得を強制することなく、新規発行されたトークンにカスタムクレームを追加や変更できるようになります。

リフレッシュトークンの制限事項

### Auth0では、有効なリフレッシュトークンの数をユーザーあたり・アプリケーションあたり200に制限しています。この制限は有効なトークンのみに適用されます。制限数に達した状態で新しいトークンが作成されると、システムは、該当するユーザーとアプリケーションを対象として、最も古いトークンを取り消し、削除します。取り消されたトークンや期限の切れたトークンは、制限数にカウントされません。

自動テスト

#### リフレッシュトークンは自動テストによって蓄積され、通常はテストが実行されている間に使用されます。制限の対象となるトークンが蓄積されるのを防ぐために、Auth0 Management APIを使って不要なリフレッシュトークンを削除することができます。

Refresh tokens accumulate due to automated tests and are generally used for the test lifetime. To avoid a token stockpile subject to refresh token limits, you can use the Auth0 <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> to remove unnecessary refresh tokens.

1. [Create a user](https://auth0.com/docs/api/management/v2#!/Users/post_users) with Management API. You will use this user for testing.
2. The response returns a `user_id` that you need to persist during tests to be used later.
3. Once tests are complete, [delete the user](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id) through Management API. When the test user is deleted, the associated artifacts are also removed, including refresh tokens.

<Warning>

For this use case, we don’t recommend using a static user ID. We do not recommended that you keep test users and artifacts, or cleaning the refresh tokens using the device credential endpoints as you could hit rate limits on the Management API. To learn more, read [Management API Endpoint Rate Limits.](/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/management-api-endpoint-rate-limits)

</Warning>

期限が切れそうなリフレッシュトークンを構成する

1. List the user’s refresh tokens using [Management API's device credential endpoint](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials). The endpoint will return a maximum of 1000 tokens without specific order regardless of accumulated tokens or the use of pagination.
2. Delete those credentials [using the DELETE](https://auth0.com/docs/api/management/v2#!/Device_Credentials/delete_device_credentials_by_id) method.
3. If the user has more than 1k tokens, repeat listing and deleting tokens until no more tokens left for the user.

#### ユーザーがAuth0でアプリケーションにログインし、`offline_access`が認可要求で要求された場合、新しいリフレッシュトークンがユーザーに対して発行されます。ユーザーがログアウトしてから同じデバイスでもう一度ログインすると、新しいリフレッシュトークンが発行されます。アプリケーションがユーザーのリフレッシュトークンを保管する方法によっては、最初のログインのリフレッシュトークンが古くなるため、両方とも同じオーディエンスで発行されている場合、アプリケーションはほぼ確実に新しいリフレッシュトークンを使用します。詳細については、「[トークンのストレージ](/security/data-security/token-storage)」をお読みください。

When users log into your application with Auth0, and when the `offline_access` is requested in the authorization request, a new refresh token is issued to the user. In the case users log out and in again with the same device, a new refresh token is issued. Depending on how your application stores and uses refresh tokens, the old refresh token from the first login might become obsolete, and your application will most likely use the new refresh tokens if both tokens are issued with the same audience. To learn more, read [Token Storage](/docs/secure/security-guidance/data-security/token-storage).

To avoid accumulating obsolete refresh tokens, even though the refresh token limit removes the oldest token first, we recommend you configure refresh token expiration. Both rotating and non-rotating (or reusable) refresh tokens can be configured to expire with either idle or absolute expiry values. Both expiration values help remove tokens that are not in active use and avoid accumulating tokens for the user. To learn more, read [Configure Refresh Token Expiration](/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration).

## ミドルウェアか、既存のサードパーティのオープンソースライブラリーを使用して、JWTを解析し検証することをお勧めします。[JWT.io]()では、.NETやPython、Java、Ruby、Objective-C、Swift、PHPといった、さまざまなプラットフォームと言語のライブラリーが揃っています。

We strongly recommend that you use middleware or one of the existing open source third-party libraries to parse and validate JWTs. At [JWT.io](https://jwt.io/#libraries-io), you can find libraries for various platforms and languages, such as .NET, Python, Java, Ruby, Objective-C, Swift, and PHP.

## アプリケーションまたはAPIに対して発行されたトークンに署名するアルゴリズムです。署名はJWTの一部で、トークンの送信者が自称のとおりであることを検証し、メッセージが途中で変更されていないことを保証するために使用されます。JWTの詳細については、「[JSON Webトークン](/security/tokens/json-web-tokens)」をお読みください。署名の詳細については、「[JSON Webトークン構造](/security/tokens/json-web-tokens/json-web-token-structure)」をお読みください。

The algorithm used to sign tokens issued for your application or API. A signature is part of a JWT and is used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way. To learn more about JWTs, read [JSON Web Tokens](/docs/secure/tokens/json-web-tokens). To learn more about signatures, read [JSON Web Token Structure](/docs/secure/tokens/json-web-tokens/json-web-token-structure).

You can select from the following <Tooltip tip="Signing Algorithm: Algorithm used to digitally sign tokens to ensure the token has not been tampered with." cta="View Glossary" href="/docs/glossary?term=signing+algorithms">signing algorithms</Tooltip>:

* **RS256** (RSA Signature with SHA-256): An asymmetric algorithm, which means that there are two keys: one public key and one private key that must be kept secret. Auth0 has the private key used to generate the signature, and the consumer of the JWT retrieves a public key from the Metadata endpoints provided by Auth0 and uses it to [validate the JWT signature](/docs/secure/tokens/json-web-tokens/validate-json-web-tokens).
* **HS256** (HMAC with SHA-256): A symmetric algorithm, which means that there is only one private key that must be kept secret, and it is shared between the two parties. Since the same key is used both to generate the signature and to validate it, care must be taken to ensure that the key is not compromised. This private key (or secret) is created when you register your Application (**<Tooltip tip="Client Secret: Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable." cta="View Glossary" href="/docs/glossary?term=Client+Secret">Client Secret</Tooltip>**) or API (**Signing Secret**) and choose the HS256 signing algorithm.

RS256では、秘密鍵の所有者（Auth0）のみがトークンに署名できる一方、誰でも公開鍵を使ってトークンの有効性を確認できます。

* RS256では、複数のオーディエンスに有効なトークンを要求できます。
* RS256では、秘密鍵が解読されたとしても、新しいシークレットでアプリケーションやAPIをデプロイし直すことなく、鍵のローテーションを実施できます（HS256では再デプロイが必要）。
* HS256では、秘密鍵が侵害されると、新しいシークレットでAPIをデプロイし直す必要があります。
* 署名鍵

## JWKSに複数の署名鍵があると仮定して進めておけば、いい結果に繋がります。Auth0のJWKSエンドポイントにある署名鍵は通常1つであるため、不要に思われるかもしれませんが、署名証明書のローテーションでJWKSに複数の署名鍵が見つかる可能性があります。

アプリケーションの性能を向上させ、レート制限の超過を回避できるように、署名鍵はキャッシュすることをお勧めします。ただし、トークンのデコードに失敗した場合には、必ずキャッシュを無効にして、新しい署名キーを取得し、**もう一度**だけ試すようにしてください。

We recommend that you cache your signing keys to improve application performance and avoid running into rate limits, but you will want to make sure that if decoding a token fails, you invalidate the cache and retrieve new signing keys before trying **only one** more time.

## Learn more

* [Tokens](/docs/secure/tokens)
* [Token Storage](/docs/secure/security-guidance/data-security/token-storage)