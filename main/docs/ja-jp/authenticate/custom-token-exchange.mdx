---
og:description: Learn about Custom Token Exchange Early Access features.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: カスタムトークン交換の早期アクセス
og:url: https://auth0.com/docs/
permalink: custom-token-exchange
title: カスタムトークン交換の早期アクセス
twitter:description: Learn about Custom Token Exchange Early Access features.
twitter:title: カスタムトークン交換の早期アクセス
---



[RFC 8693](https://datatracker.ietf.org/doc/html/rfc8693)で定義されているように、カスタムトークン交換はアプリケーションが`/oauth/token`エンドポイントを呼び出したときに既存のトークンをAuth0トークンに交換できるようにします。これは以下のような高度な統合に役立ちます。

* 別のオーディエンスのAuth0トークンを取得する
* 外部のIDプロバイダーを統合する
* Auth0に移行する

詳細については、「[ユースケースの例とサンプルコード](#example-use-cases-and-code-samples)」をお読みください。

トークン交換を管理して必要な特定のユースケースに調整するために、1つ以上の[カスタムトークン交換プロファイル](#custom-token-exchange-profile)を定義できます。それぞれのプロファイルでは、トランザクションにユーザー情報を提供する`subject_token_type`と[アクション](/customize/actions/actions-overview)が1対1でマッピングされます。アクション内にはカスタムコードを作成して、`/oauth/token`エンドポイントに渡されたサブジェクトトークンの復号化と検証を行うことができます。

カスタムトークン交換はユーザーの認証に使用できます。たとえば、アクション内でユースケースの認可ロジックを適用して、トランザクションにユーザーを設定できます。そうすると、Auth0がアクセストークン、IDトークンとリフレッシュトークンをユーザーに発行します。



## セットアップ

### アプリケーション

カスタムトークン交換を使用するには、Auth0 DashboardまたはManagement APIを使用して[新しいアプリケーションを作成](/get-started/auth0-overview/create-applications)する必要があります。カスタムトークン交換には、複数のアプリケーションを作成して使用できます。

新しいアプリケーションを作成するには以下を行います。

1. カスタムトークン交換はデフォルトで無効に設定されます。カスタムトークン交換を有効化するには、Management APIを使用してPOST呼び出しを[クライアント作成](https://auth0.com/docs/api/management/v2/clients/post-clients)エンドポイントに対して行うか、PATCH呼び出しを[クライアント更新](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id)エンドポイントに対して行います。`token_exchange`の`allow_any_profile_of_type`属性を`["custom_authentication"]`に設定します。



2. アプリケーションに[データベース接続](/authenticate/database-connections)または[エンタープライズ接続](/authenticate/enterprise-connections)を有効化して、カスタムトークン交換で使用できるようにします。

3. アプリケーションに[［First-Party（ファーストパーティー）］](/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)フラグがあり、[［Dashboard］>［Applications（アプリケーション）］>［Advanced Settings（詳細設定）］>［OAuth］で［OIDC Conformant（OIDC準拠）］](/get-started/applications/application-settings#oauth)として構成されていることを確認します。



アプリケーションを作成したら、`client_id`と`client_secret`を必ずメモして、後で`/oauth/token`エンドポイントを呼び出すときに使用できるようにします。

### カスタムトークン交換プロファイル

カスタムトークン交換プロファイルはそれぞれ`subject_token_type`にマッピングされ、該当するユースケースのコードロジックがあるアクションと関連付けられます。

特定の`subject_token_type`値を含めて`/oauth/token`エンドポイントに送信されたカスタムトークン交換要求は、対応するカスタムトークン交換プロファイルにマッピングされ、処理のために関連するアクションに送られます。

カスタムトークン交換プロファイルを作成するには、まずプロファイルにアクションを作成します。

#### アクションを作成する

Auth0 Dashboardで以下を行います。

1. **［Actions（アクション）］**>**［Library（ライブラリー）］**に移動します。

2. **［Create Action（アクションを作成）］**>**［Build from scratch（初めから構築する）］**を選択します。

3. **［Create Action（アクションを作成）］**ダイアログに名前を入力し、ドロップダウンから**［Custom Token Exchange（カスタムトークン交換）］**トリガーを選択します。

4. **［Create（作成）］**を選択します。

5. アクションを**［Deploy（デプロイ）］**します。

アクションをデプロイすると、Auth0がアクションIDを割り当てます。アクションにはカスタムロジックを追加しなければなりませんが、その前にアクションIDを取得して、カスタムトークン交換プロファイルを作成します。

6. Auth0 DashboardでアクションIDを取得するには、ブラウザーウィンドウのURLを確認します。下の画像が示すように、アクションIDはURLの末尾の部分にあります。

アクションIDはManagement APIで取得することもできます。まず、APIを使用するために[Management APIトークンを取得](/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens)します。そして、以下のGET要求を`/actions`エンドポイントに送信します。



応答本文の`actions[0].id`内にアクションIDが含まれているはずです。アクションIDはカスタムトークン交換プロファイルの作成に必要です。

#### カスタムトークン交換プロファイルを作成する

カスタムトークン交換プロファイルを作成するには、Management APIを使用して、POST要求に以下のパラメーターを含めて`/token-exchange-profiles`エンドポイントに送信します。





カスタムトークン交換プロファイルが正常に作成されると、以下の応答を受け取ります。



これで、ユースケースに実装するカスタムトークン交換のコード作成とテストの準備が整いました。

### カスタムトークン交換プロファイルを管理する

カスタムトークン交換プロファイルを管理するには、Management APIを使用して`/token-exchange-profiles`エンドポイントに要求を送信します。

カスタムトークン交換プロファイルを取得するには、以下の要求を行います。複数のプロファイルがある場合のために、このエンドポイントは[チェックポイントページネーション](/api/management/v2/introduction#checkpoint-based-pagination)に対応しています。



カスタムトークン交換プロファイルの`name`または`subject_token_type`を更新するには、以下のPATCH要求を行います。アクションIDは変更できませんが、実行されるカスタムコードはActionsエディターで変更できます。



カスタムトークン交換プロファイルを削除するには、以下のDELETE要求を行います。



## Actions API

### カスタムトークン交換とログイン後アクション

カスタムトークン交換アクションは早期アクセス版のカスタムトークン交換の一部として提供され、「[Actions APIを使用する](#use-the-actions-api)」に記載の新しいAPIメソッドが使用できます。

アクセストークンにカスタムクレームを追加することなどが必要な場合は、トランザクションに設定済みのユーザーに対してカスタムトークン交換アクションを実行したた後に、[ログイン後アクショントリガー](/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger)を実行すると、ログインフローと同じ機能性が実現できます。

トークン交換の付与タイプを使用するトランザクションを識別するには、[ログイン後アクション](/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger)の`oauth2-token-exchange`と同じ値を持つ`event.transaction.protocol`を探します。トークン交換の付与タイプはカスタムトークン交換とネイティブソーシャルログインの両方のトランザクションで使用され、`subject_token_type`はいずれかのカスタムトークン交換プロファイルに対応しているため、`subject_token_type`値を使用すれば、それらの2つを区別できます。



### Actions APIを使用する

トークン交換アクションで使用できるように、Auth0は数々のAPIメソッドを提供しています。`subject_token_type`に基づいてサブジェクトトークンの復号化と検証を行うアクションを実装してください。そうすることで、トランザクションのためにユーザー情報を入手できます。また、この情報を使用して、コードがトランザクションに必要な認可ポリシーを適用するようにします。トランザクションが続行できることを確認したら、対応するユーザーを設定してトランザクションを確定できます。そうすると、Auth0がアクセストークン、IDトークンとリフレッシュトークンをユーザーに発行します。これはユーザーを認証する1つの方法だと考えることができます。

カスタムトークン交換トランザクションはそれぞれ1つのテナントイベントログを生成します。トランザクションが成功すると種類が`secte`のイベントログが生成され、トランザクションが失敗すると種類が`fecte`のイベントログが生成されます。これらの種類は受け取るかもしれないエラーを理解するのに役立ちます。`/oauth/token`エンドポイントからのエラーには詳細があまり含まれません。



#### api.authentication.setUserById(user_id)

任意の接続タイプに対して、指定のユーザーIDを基にユーザー属性を設定します。これにより、プロファイルを更新することなく、既存のユーザーを指定できます。このメソッドはユーザーが存在しないか、ブロックされていると失敗します。





#### api.authentication.setUserByConnection(connection_name, user_profile, options)

ユーザーとそのユーザーに関するプロファイル属性を指定の接続内で設定します。これは、ユーザーがこの接続にログインし、指定されたユーザープロファイルをフェデレーションIdPが返すことと同等です。ユーザーが存在しない場合にこの操作がユーザーを作成するか、そして、提供されたユーザープロファイル属性を使ってプロファイルを更新するかを構成できます。

ユーザーが`setUserByConnection()`を通してログインするたびに、ログイン回数が加算されます。このメソッドはユーザーがブロックされていると失敗します。







##### 対応されているユーザープロファイル属性

`setUserByConnection()`メソッドでは、[ユーザー更新](https://auth0.com/docs/api/management/v2/users/patch-users-by-id)エンドポイントが対応しているプロファイル属性を設定できます。

* `user_id `（必須）：この接続またはプロバイダーでユーザーに一意の識別子です。通常は、この接続について外部のIDプロバイダーが提供するユーザーIDです。このパラメーターは`creationBehaviour`と`updateBehaviour`の両方が`none`に設定されている場合にのみ必須です。
* `email`
* `email_verified`。デフォルトは`false`です。
* `username`
* `phone_number`
* `phone_verified`。デフォルトは`false`です。
* `name`
* `given_name`
* `family_name`
* `nickname`
* `picture`

上のリストにはない属性の設定が必要な場合は、メタデータフィールドを使用してください。

##### 対応されている接続ストラテジー

現在のバージョンは以下の接続ストラテジーに対応しています。これ以外のストラテジーでは、`setUserByConnection()`メソッドが失敗します。他のストラテジーへの対応をご希望の場合には、Auth0サポートまでお問い合わせください。

エンタープライズ接続：

* [Active Directory](/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap)
* [SAML IdP](/authenticate/identity-providers/enterprise-identity-providers/saml)
* [OIDC IdP](/authenticate/identity-providers/enterprise-identity-providers/oidc)
* [Okta](/authenticate/identity-providers/enterprise-identity-providers/okta)
* [ADFS](/authenticate/identity-providers/enterprise-identity-providers/adfs)

ソーシャル接続：

* カスタムソーシャル接続
* Google
* Apple
* Facebook
* Github
* Windowslive

##### 作成の動作

ユーザーは`creationBehavior`が`create_if_not_exists`に設定されている場合にのみ動的に作成されます。

ユーザーの作成には以下が必要です。

* 使用している接続に構成されている識別子を提供しなければなりません。メールはデフォルトで必須です。
* [柔軟な識別子と属性](/authenticate/database-connections/flexible-identifiers-and-attributes)を使用する接続については、該当する属性が接続に有効化されていれば、ユーザー名や電話番号を提供できます。
* 柔軟な識別子と属性を使用しない接続については以下を行います。

* 接続に**［Require Username（ユーザー名を必須にする）］**が`true`に設定されている場合は、ユーザー名を提供できます。詳細については、「[データベース接続にユーザー名を追加する](/authenticate/database-connections/require-username)」をお読みください。
* `phone_number`は提供できません。
* `email_verified`や`phone_verified`を指定しても構いません。

Auth0のデータベース接続では、ユーザーのためにランダムなパスワードが動的に生成されます。ユーザーの作成後に必要に応じて[パスワードのリセットフロー](/authenticate/database-connections/password-change)をトリガーするには、別のオプションがあります。



##### 更新の動作

ユーザープロファイルは`updateBehavior`が`replace`に設定されている場合にのみ更新されます。

以下の属性は編集できません。値を変更しようとすると、Auth0からエラーが返されます。

* `email`
* `username`
* `phone_number`
* `email_verified`
* `phone_verified`





##### メール検証

`email_verified=false`でユーザーが作成されると、Auth0は自動的に確認メールを送信します。この動作をオーバーライドするには、`verify_email=false`をユーザープロファイル属性として指定します。ユーザープロファイルの一部として保管はされません。



[歓迎メールテンプレートを構成して有効化](/customize/email/email-templates)すると、確認メールが送信されない場合に、Auth0は新規作成されたユーザーに対して自動的に歓迎メールを送信します。

##### メタデータを設定する

[ユーザー更新](https://auth0.com/docs/api/management/v2/users/patch-users-by-id)エンドポイントとは異なり、`setUserByConnection()`メソッドではユーザーやアプリケーションのメタデータを設定できません。その場合は`api.user.setAppMetadata`を使用できます。ユーザーメタデータの正しい使い方については、「[ユーザープロファイルでのメタデータの仕組み](/manage-users/user-accounts/metadata)」をお読みください。メタデータのベストプラクティスについては、「[ログイン後トリガーでユーザーメタデータを管理する方法](/manage-users/user-accounts/metadata/manage-user-metadata#best-practices)」をお読みください。

#### api.user.setAppMetadata(name, value)

ログインを試行するユーザーのアプリケーションメタデータを設定します。

このメソッドはマージ動作に従うため、既存の属性に影響を与えることなく、追加する属性や更新する属性を指定できます。属性を削除するには、値を`null`に設定します。





#### api.user.setUserMetadata(name, value)

ログインを試行するユーザーの一般的なメタデータを設定します。

このメソッドはマージ動作に従うため、既存の属性に影響を与えることなく、追加する属性や更新する属性を指定できます。属性を削除するには、値を`null`に設定します。





#### api.access.deny(code, reason)

ログイントランザクションを拒否して、呼び出し元にエラーを返します。





#### api.access.rejectInvalidSubjectToken(reason)

トランザクションを拒否して、要求元の外部IPアドレスについて試行の失敗数を加算します。カスタムトークン交換は要求を`invalid_request`のエラーコードを使用した`400 Bad Request`エラー応答で拒否します。

試行の失敗が最大数に達すると、該当するIPアドレスからのすべてのカスタムトークン交換要求について、Auth0はトラフィックを`too_many_attempts`のエラーコードを使用した`429 Too Many Requests`エラー応答でブロックします。詳細については、「[攻撃防御](#attack-protection)」をお読みください。

このメソッドは、署名や暗号化が不適切、または有効期限切れのサブジェクトトークンを含むカスタムトークン交換要求を受け取った場合には必ず使用してください。また、なりすましやリプレイ攻撃など、不正使用が疑われる状況でも必ず使用してください。そうすることで、Auth0は構成に応じて、不審なIPのスロットリングを適用できるようになります。

不審なIPのスロットリングはデフォルトで最大10回まで、1時間あたりに6回の試行を許容します。詳細については、「[攻撃防御](#attack-protection)」をお読みください。





#### api.cache

実行間で維持されるデータの保管と取得を行います。

これらのメソッドはサブジェクトトークンを検証するために、署名検証の公開鍵などのデータをキャッシュする場合に役立ちます。`jwks-uri`からキーを取得する際のパフォーマンスを向上させることができます。

##### api.cache.delete(key)

提供された`key`にキャッシュ済みの値が存在する場合は、それを記述したレコードを削除します。

値がキャッシュから削除されると、`CacheWriteResult`オブジェクトに`type: "success"`を含めて返します。操作に失敗すると、`type: "error"`を返します。エラーの場合には、返すオブジェクトに`code`プロパティを含めて、失敗の詳細を示します。



##### api.cache.get(key)

提供された`key`にキャッシュ済みの値が存在する場合は、それを記述したレコードを取得します。レコードが見つかった場合には、返されたオブジェクトの`value`プロパティにキャッシュ済みの値があります。

提供された`key`にキャッシュが見つかった場合には、キャッシュレコードを返します。キャッシュレコードは`value`プロパティを含むオブジェクトで、このプロパティにはキャッシュ済みの値の他にも`expires_at`プロパティが含まれ、レコードの最大有効期間をUNIXエポックからの経過ミリ秒数で示します。

**重要：**このキャッシュは、短命で一時的なデータ向けに設計されています。項目が所定のライフタイム内であったとしても、後のトランザクションでは利用できないかもしれません。



##### api.cache.set(key, value, [options])

指定されたkeyのキャッシュに文字列値を保管または更新します。

このキャッシュに保管された値は、それを設定するトリガーにスコープが限定されます。これは[アクションのキャッシュ制限](/customize/actions/limitations)の対象になります。

このように保管された値には、指定された`ttl`または`expires_at`値までのライフタイムがあります。ライフタイムが指定されない場合には、デフォルトのライフタイムである15分が使用されます。ライフタイムは[アクションのキャッシュ制限](/customize/actions/limitations)が定める最大値を超過してはいけません。

値が正常に保管されると、`CacheWriteSuccess`を返します。それ以外の場合は`CacheWriteError`を返します。



## アクションイベント

新しいActions APIメソッドに加えて、アクションイベントのデータを使用して、サブジェクトトークン、IPアドレス、クライアントなど、トークン交換要求のコンテキストについて知ることができます。



## アクションをデプロイする

上記のAPIとイベントオブジェクトでトークン交換アクションを作成したら、ページの上部にある**［Deploy（デプロイ）］**をクリックして変更内容をデプロイします。

## トークン交換を呼び出す

カスタムトークン交換を使用するには、以下のパラメーターを指定して`POST`要求を`/oauth/token`エンドポイントに対して行います。以下に留意してください。

* カスタムトークン交換に使用する`subject_tokens`は、アクションコードが解釈できるのであれば、どのような形式や種類のトークンでも構いません。
* `subject_token_type`はそれぞれ特定のカスタムトークン交換プロファイルにマッピングされ、そのトランザクションを制御する特定のアクションに関連付けられます。



その他の拡張パラメーターは、対応するアクションの`event.request.body`に含まれていますが、無視されます。



### 要求例



## 攻撃防御

なりすましやリプレイ攻撃で悪意のある攻撃者がサブジェクトトークンを推測または再利用しようとするのを防ぐために、カスタムトークン交換は[不審なIPのスロットリング](/secure/attack-protection/suspicious-ip-throttling)に対応しています。これにより、[サブジェクトトークンが無効](#api-access-rejectinvalidsubjecttoken-reason-)な場合に、アクション内のコードから信号を特異的に送信できるため、Auth0は外部IPからの試行の失敗をカウントできます。

1つのIPアドレスからの試行の失敗数が事前構成のしきい値に達すると、該当するIPアドレスからのカスタムトークン交換要求について、Auth0は以下のエラー応答でトラフィックをブロックします。



構成済みの期間が過ぎると、IPアドレスは要求を再び行えるようになります。

すべての事例で推奨されることですが、**不審なIPのスロットリングを正しく構成してアクティブ化することは、カスタムトークン交換をネイティブアプリケーションやシングルページアプリケーションで使用する場合には特に重要です**。ネイティブアプリケーションやSPAなどの非機密アプリケーションは、自身を認証するためにシークレットを安全に保管できません。攻撃者は簡単にサブジェクトトークンを推測したり、窃盗や漏洩したものを使用したりできます。

不審なIPのスロットリングを正しく使用するためには、受け取ったサブジェクトトークンが厳密に検証されない場合は必ず、アクションのコードに`api.access.rejectInvalidSubjectToken`を使用してください。

不審なIPのスロットリングはAuth0テナントにはデフォルトでアクティブ化されます。アクティブ化や構成の方法については、「[不審なIPのスロットリング](/secure/attack-protection/suspicious-ip-throttling)」をお読みください。アクティブ化すると、カスタムトークン交換のデフォルト設定が適用されます。

* しきい値：10。1つのIPアドレスが失敗した試行の最大数です。
* スロットリングレート：1時間あたり6回。しきい値を超えない範囲で10分ごとに1回の試行が補充されます。

カスタムトークン交換には、Management APIを使用してカスタムのしきい値やスロットリングレートを構成できます。

まず、APIを使用するために[Management APIトークンを取得](/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens)します。そして、以下のGET要求を[不審なIPのスロットリング設定取得エンドポイント](https://auth0.com/docs/api/management/v2/attack-protection/get-suspicious-ip-throttling)に対して行います。



以下のような応答を受け取ります。



以下の`PATCH`要求では`pre-custom-token-exchange`ステージを必要な値で更新できます。レートは新たに試行が許可されるまでをミリ秒単位の間隔で表していることに注意してください。



## ユースケースの例とサンプルコード

技術的な制約やユーザーエクスペリエンスの観点から、エンドユーザーのリダイレクトに基づく標準的なフェデレーションログインストラテジーが適用できない高度な統合シナリオには、カスタムトークン交換をソリューションとして使用できます。ユースケースに提供するコードは不完全なものであり、対処するコードを論理的に進められるように説明することのみを意図しています。より詳しいサンプルコードについては、「[サンプルコード](#code-samples)」を参照してください。

このセクションでは、ユースケースの例と該当するシナリオの実装に推奨されるサンプルコードを紹介します。ユースケースを説明するために、GearUpという架空のレンタカー会社を想定します。

### ユースケース：Auth0へシームレスに移行する

GearUpには何百万人もが使用するモバイルアプリがあり、アイデンティティソリューションの近代化が必要なため、Auth0を使用することに決めました。ただし、レガシーIDプロバイダー（IdP）からの移行に関してユーザーエクスペリエンスでの摩擦を懸念して、ユーザーに再認証を強制することは避けたいと考えています。

これを解消し、リスクを制限するために、GearUpは段階的に移行しています。それぞれのユーザーについて、レガシーIdPからのリフレッシュトークンをAuth0のアクセストークン、リフレッシュトークン、IDトークンのセットに交換することを希望しています。そうすることで、アプリが速やかにAuth0をIdPとして使い始め、Auth0発行のトークンを用いてGearUp APIを使用できるようになります。すべてのユーザーに交換が完了したら、エンドユーザーとGearUpのビジネスに影響することなく、アプリは完全に移行され、古いIdPが切断されます。

前提条件として、GearUpはAuth0テナントに[ユーザーの一括インポート](/manage-users/user-migration/bulk-user-imports)を行い、モバイルアプリには移行するユーザーの有効なレガシーリフレッシュトークンがあります。

1. モバイルアプリがAuth0に対してレガシーのリフレッシュトークンの交換を要求します。その際にはレガシーのリフレッシュトークンをサブジェクトトークンとして設定します。
2. 該当するカスタムトークン交換プロファイルのアクションが実行されます。リフレッシュトークンをレガシーIdPで照会して、ユーザープロファイルから外部のユーザーIDを取得します。そして、必要な認可ポリシーを適用し、最終にユーザーを設定します。
3. Auth0がAuth0のアクセストークン、IDトークン、リフレッシュトークンを含めて応答します。
4. これで、ユーザーが再認証することなく、モバイルアプリがAuth0のトークンを使って顧客のAPIを使用できるようになりました。

以下のサンプルコードは、カスタムトークン交換アクションでこれを実装する方法を示しています。このユースケースではユーザープロファイルがすでにAuth0データベース接続にインポートされているため、以下が当てはまります。

* Auth0はユーザーを作成しません。
* Auth0はユーザープロファイルを更新しません。

Auth0は外部IdPのユーザーIDを使用して、該当する接続でユーザーを設定します。



不透明なリフレッシュトークンをレガシーIdPで検証する方法の詳しい例については、「[サンプルコード](#code-samples)」をお読みください。

### ユースケース：外部の認証プロバイダーを再利用する

別のユースケースでは、GearUpがAir0という大手旅行会社と提携し、Air0のシングルページアプリケーション内でレンタカーサービスを直接提供します。GearUpは自社APIの使用をカプセル化したJavaScriptライブラリーを提供します。そうすることで、レンタカーサービスを提供するAir0のWebサイトがGearUpのAPIを手軽に使用できるようになります。

今回も、GearUpへの再認証を避けて、ソリューションがエンドユーザーから見えないようにする必要があります。これを実現するために、GearUpのJavaScriptライブラリーは外部のAir0 IDトークンを入力として使用し、トークン交換を処理できます。その結果、Auth0のアクセストークンが生成され、メールアドレスを基に所定のGearUpユーザーと関連付けられます。GearUpライブラリーがアクセストークンを取得したら、Air0のWebサイトで直接レンタカーサービスを提供するために、GearUpのAPIを使い始めることができます。

前提条件として、GearUpはAir0 IdPをフェデレーションのエンタープライズ接続またはソーシャル接続としてセットアップし、ユーザー認証をフェデレーションログインで行うか、以下のようにカスタムトークン交換で行えるようにします。

1. ユーザーを認証したら、シングルページアプリが外部IdPからIDトークンを取得します。
2. シングルページアプリがIDトークンをサブジェクトトークンとして設定し、トークンの交換を要求します。
3. 該当するカスタムトークン交換プロファイルのアクションが実行されます。IDトークンを検証し、トークンからユーザーIDと他のプロファイル属性を取得します。そして、必要な認可ポリシーを適用し、最終にユーザーを設定します。
4. Auth0がAuth0のアクセストークン、IDトークン、リフレッシュトークンを含めて応答します。
5. これで、ユーザーが再認証することなく、SPAで実行中のJavascriptコードがAuth0のトークンを使って顧客のAPIを使用できるようになりました。

以下のサンプルコードは、カスタムトークン交換アクションでこれを実装する方法を示しています。このユースケースでは以下が当てはまります。

* Auth0は外部IdPのユーザーIDを使用して、該当する接続でユーザーを設定します。
* ユーザーが存在しない場合にはAuth0が作成します。
* ユーザーがすでに存在する場合のために、より完全な属性のセットがフェデレーションログインで取得できるのであれば、Auth0はユーザープロファイルを置換しません。
* Auth0はユーザーの作成時にメールを検証しません。



JWTを安全に検証する方法の詳しい例については、「[サンプルコード](#code-samples)」をお読みください。

### ユースケース：別のオーディエンスのAuth0トークンを取得する

GearUpはAPI要求を処理するために、内部のマイクロサービス間で呼び出しの認可方法を改善したいと考えています。それぞれのサービスに使用可能なリソースを制御するために、ポリシーの一元管理を希望しています。これもトークン交換を使用して実現できます。

まず、API要求がサービスAに到達すると、受け取ったアクセストークンを、新しいオーディエンスとしてサービスBの使用を許可する新しいアクセストークンに交換します。トークン交換を管理する認可ポリシーが許す場合、サービスAが新しいトークンを取得して、サービスBが使用できるようになります。ユーザーIDは新しいトークンで変わらずに維持されるため、ユーザーの正しいコンテキストがプロセス全体で維持されます。

GearUpアプリケーションは当初、API Aをユーザーに代わって使用するために、アクセストークンを取得します。

1. アプリが要求に当初のアクセストークンを含めてAPI Aに送信します。
2. API Aのバックエンドサービスがアクセストークンを検証し、それをサブジェクトトークンとして設定して、API Bを使用するための新しいアクセストークンとの交換を要求します。
3. 該当するカスタムトークン交換プロファイルのアクションが実行されます。IDトークンを検証し、トークンからAuth0ユーザーIDを取得します。そして、必要な認可ポリシーを適用し、最終にユーザーを設定します。
4. Auth0がAPI Bオーディエンスを使用するためのAuth0のアクセストークンを含めて応答します。
5. API Aのバックエンドサービスが新しいアクセストークンを使用してAPI Bを呼び出します。このアクセストークンは引き続き同じユーザーに関連付けられています。

以下のサンプルコードは、カスタムトークン交換アクションでこれを実装する方法を示しています。このユースケースでは以下が当てはまります。

* Auth0がAuth0のユーザーIDを使用してユーザーを設定するため、接続のスコープにこれを設定する必要はありません。
* Auth0はユーザーの作成や更新を行いません。

このユースケースに関する詳しいサンプルコードについては、「[非対称鍵で署名されたJWTを検証する](#validate-jwts-signed-with-asymmetric-keys)」を参照してください。



JWTを安全に検証する方法の詳しい例については、「[サンプルコード](#code-samples)」をお読みください。

### サンプルコード

以下のサンプルコードは、受け取ったサブジェクトトークンを安全で効率よく検証するために、シナリオ共通のベストプラクティスを示しています。

Auth0とシークレットを共有する必要がない場合は、できる限り非対称のアルゴリズムと鍵を使用します。これは、適用できるk公開鍵を公表するためにJWKS URIエンドポイントを公開する場合などで、鍵のローテーションも簡素化します。



#### 非対称鍵で署名されたJWTを検証する

以下の推奨事項を検討してください。

* Actionsの[api.cache](#api-cache)メソッドを使用し、トランザクションごとに署名鍵を取得しないようにします。
* [RFC8725](https://www.rfc-editor.org/rfc/rfc8725.txt)のベストプラクティスに従います。
* RS*、PS*、ES*、またはEd25519のアルゴリズムを使用します。
* noneアルゴリズムを使用したり、受け入れたりしてはいけません。
* 最小長2048ビットのRSAを使用します。



#### 対称鍵で署名されたJWTを検証する

以下の推奨事項を検討してください。

* [Actionsシークレット](/customize/actions/write-your-first-action#add-a-secret)を使用して、対称シークレットを安全に保管します。
* [RFC8725](https://www.rfc-editor.org/rfc/rfc8725.txt)のベストプラクティスに従います。
* HS256などのセキュリティ保護されたアルゴリズムと、高エントロピーでランダムなシークレット（256ビッドの最小長など）を使用します。



#### 外部サービスで不透明なトークンを検証する

[Actionsシークレット](/customize/actions/write-your-first-action#add-a-secret)を使用して、外部IdPのクライアントシークレットを安全に保管します。



## 制限事項

これは早期アクセス機能であるため、いくつかの制限があり、他のAuth0機能との互換性はありません。

早期アクセス版のカスタムトークン交換は以下の機能には対応していません（または正しく動作しません）。

* Organizations
* MFA：ログイン後アクションの`api.authentication.challengeWith()`および`api.multifactor.enable()`コマンドはカスタムトークン交換に未対応であるため、トランザクションが回復不可能なエラーで失敗します。同様に、テナントのポリシーとしてMFAが構成されている場合にも、トランザクションが失敗します。
* カスタムデータベース接続
* 特有のなりすまし対応（アクタートークンやアクタークレームなど）
* サードパーティやOIDC非準拠のクライアント

## レート制限

`/oauth/token`エンドポイントに対するカスタムトークン交換要求には、該当するパフォーマンスレベルにおいて、Authentication APIのグローバルレート制限の10%というレート制限が適用されます。



`api/v2/token-exchange-profiles`エンドポイントでの読み出し要求にも以下のレート制限が適用されます。



## エンティティ制限

テナントごとに最大100のカスタムトークン交換プロファイルを作成できます。

アクションの総数もAuth0プランに応じて制限されます。詳細については、「[Auth0の価格設定](https://auth0.com/pricing)」ページを参照してください。

## トラブルシューティング

### 「同意が必要」応答

`/oauth/token`エンドポイントを呼び出したときに、`consent_required`のエラー説明を含む`invalid_request`エラーを受け取ることがあります。

この問題を解消するには、Auth0 Dashboardを使用してAPIに**［Allow Skipping User Consent（ユーザー同意のスキップを許可する）］**オプションを有効にします。