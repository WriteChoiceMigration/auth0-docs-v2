---
og:description: Learn about Custom Token Exchange Early Access features.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: カスタムトークン交換の早期アクセス
og:url: https://auth0.com/docs/
permalink: custom-token-exchange
title: カスタムトークン交換の早期アクセス
twitter:description: Learn about Custom Token Exchange Early Access features.
twitter:title: カスタムトークン交換の早期アクセス
---

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange is currently in Early Access for Enterprise customers only. Reach out to your Auth0 contact to request access. To learn more about Auth0's product release cycle, read [Product Release Stages](/docs/troubleshoot/product-lifecycle/product-release-stages).

</Callout>

As defined in [RFC 8693](https://datatracker.ietf.org/doc/html/rfc8693), Custom Token Exchange allows you to enable applications to exchange their existing tokens for Auth0 tokens when calling the `/oauth/token` endpoint. This is useful for advanced integration use cases, such as:

* Get Auth0 tokens for another <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip>
* Integrate an external <Tooltip tip="Identity Provider (IdP): Service that stores and manages digital identities." cta="View Glossary" href="/docs/glossary?term=identity+provider">identity provider</Tooltip>
* 詳細については、「[ユースケースの例とサンプルコード](#example-use-cases-and-code-samples)」をお読みください。

トークン交換を管理して必要な特定のユースケースに調整するために、1つ以上の[カスタムトークン交換プロファイル](#custom-token-exchange-profile)を定義できます。それぞれのプロファイルでは、トランザクションにユーザー情報を提供する`subject_token_type`と[アクション](/customize/actions/actions-overview)が1対1でマッピングされます。アクション内にはカスタムコードを作成して、`/oauth/token`エンドポイントに渡されたサブジェクトトークンの復号化と検証を行うことができます。

To govern the token exchange and adjust it to the specific needs of your use case, you can define one or more [Custom Token Exchange Profiles](#custom-token-exchange-profile). Each profile establishes a one-to-one mapping between a `subject_token_type`, which provides information about the user for the transaction, and an [Action](/docs/customize/actions/actions-overview). In that Action, you can write custom code to decode and validate subject tokens passed to the `/oauth/token` endpoint.

You can use Custom Token Exchange to authenticate users. For example, in an Action, you can apply the authorization logic for your use case and set the user for the transaction. Auth0 will then issue access, ID, and <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=refresh+tokens">refresh tokens</Tooltip> for the user.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange gives you the added flexibility to set the user for the transaction by taking on the additional responsibility of securely validating the corresponding subject token that identifies the user for the transaction.

Remember that subject tokens used with Custom Token Exchange can be any token format or type you require, as long as your Action code can interpret them. **You must implement strong validation of the tokens you receive and accept.** If you fail to do so, you open yourself up to different attack vectors, such as spoofing or replay attacks, resulting in bad actors being able to authenticate with someone else’s user ID.

To learn about different options for implementing secure validation of your subject tokens, read and apply the recommendations included in [Example Use Cases and Code Samples](#example-use-cases-and-code-samples). Make sure you also take into consideration and apply [Attack Protection](#attack-protection) capabilities.

</Callout>

## アプリケーション

### カスタムトークン交換を使用するには、Auth0 DashboardまたはManagement APIを使用して[新しいアプリケーションを作成](/get-started/auth0-overview/create-applications)する必要があります。カスタムトークン交換には、複数のアプリケーションを作成して使用できます。

To use Custom Token Exchange, you must [create a new application](/docs/get-started/auth0-overview/create-applications) with the <Tooltip tip="Auth0 Dashboard: Auth0's main product to configure your services." cta="View Glossary" href="/docs/glossary?term=Auth0+Dashboard">Auth0 Dashboard</Tooltip> or the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip>. You can create multiple applications to use Custom Token Exchange.

アプリケーションを作成したら、`client_id`と`client_secret`を必ずメモして、後で`/oauth/token`エンドポイントを呼び出すときに使用できるようにします。

1. By default, Custom Token Exchange is disabled. To enable Custom Token Exchange, use the Management API to make a POST call to [Create a Client](https://auth0.com/docs/api/management/v2/clients/post-clients) or a PATCH call to [Update a Client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id). Set the `allow_any_profile_of_type` attribute under `token_exchange` to `["custom_authentication"]`:

```json lines
{
  "token_exchange": {
    "allow_any_profile_of_type": ["custom_authentication"]
  }
}
```






2. Enable the [database connection](/docs/authenticate/database-connections) or [enterprise connection](/docs/authenticate/enterprise-connections) you want to use with Custom Token Exchange for the application.

3. Make sure your application is flagged as [First-Party](/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications) and it is configured as [OIDC Conformant in Dashboard > Applications > Advanced Settings > OAuth](/docs/get-started/applications/application-settings#oauth).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom DBs with [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) enabled are only supported for `setUserById` operations.

</Callout>

カスタムトークン交換プロファイル

### カスタムトークン交換プロファイルはそれぞれ`subject_token_type`にマッピングされ、該当するユースケースのコードロジックがあるアクションと関連付けられます。

特定の`subject_token_type`値を含めて`/oauth/token`エンドポイントに送信されたカスタムトークン交換要求は、対応するカスタムトークン交換プロファイルにマッピングされ、処理のために関連するアクションに送られます。

カスタムトークン交換プロファイルを作成するには、まずプロファイルにアクションを作成します。

アクションを作成する

#### Auth0 Dashboardで以下を行います。

アクションをデプロイすると、Auth0がアクションIDを割り当てます。アクションにはカスタムロジックを追加しなければなりませんが、その前にアクションIDを取得して、カスタムトークン交換プロファイルを作成します。

1. Navigate to [**Actions > Library**](https://manage.auth0.com/#/actions/library).

2. Select **Create Action** > **Build from Scratch**.

3. In the **Create Action** dialog, enter a name and select the **Custom Token Exchange** trigger from the drop-down.

<Frame>![](/images/cdy7uua7fh8z/22vz9dsCFj5Ruot7U0HIVx/1c3dc4b562334dab9d6ac415028ea76e/Screenshot_2025-02-05_at_8.48.34_AM.png)</Frame>

4. Select **Create**.

5. **Deploy** the Action.

<Frame>![](/images/cdy7uua7fh8z/56NZA69Gmzha167xfgRD0W/302e59276815d2e2644ab2da3b9b5f1f/Screenshot_2025-02-03_at_10.29.17_AM.png)</Frame>

アクションIDはManagement APIで取得することもできます。まず、APIを使用するために[Management APIトークンを取得](/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens)します。そして、以下のGET要求を`/actions`エンドポイントに送信します。

6. To get the Action ID in the Auth0 Dashboard, navigate to the URL of the browser window. The Action ID should be the last part of the URL, as shown in the following image:

<Frame>![](/images/cdy7uua7fh8z/1Xx4UbgZR0FIuLC1KVvhKG/bde4469d770c2ff8d37c19895a0c8e66/Screenshot_2025-02-03_at_10.31.18_AM.png)</Frame>

You can also get the Action ID via the Management API. First, [get a Management API token](/docs/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens) to consume the API. Then, make the following GET request to the `/actions` endpoint:

```bash lines
curl --location 'https://{{YOUR _TENANT}}/api/v2/actions/actions?actionName={{ACTION_NAME}}' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
```






カスタムトークン交換プロファイルを作成する

#### カスタムトークン交換プロファイルを作成するには、Management APIを使用して、POST要求に以下のパラメーターを含めて`/token-exchange-profiles`エンドポイントに送信します。

カスタムトークン交換プロファイルが正常に作成されると、以下の応答を受け取ります。

```bash lines
curl --location 'https://{{YOUR _TENANT}}/api/v2/token-exchange-profiles' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
--data '{
    "name": "{{PROFILE_NAME}}",
    "subject_token_type": "{{UNIQUE_PROFILE_TOKEN_TYPE_URI}}",
    "action_id": "{{ACTION_ID}}",
    "type": "custom_authentication"
}'
```






<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>subject_token_type</code></td>
<td>Unique profile token type URI starting with `https://` or <code>urn</code><br/><br/>The following namespaces are reserved and you can’t use them:<br/><br/><ul><li>`http://auth0.com`</li><li>`https://auth0.com`</li><li>`http://okta.com`</li><li>`https://okta.com`</li><li><code>urn:ietf</code></li><li><code>urn:auth0</code></li><li><code>urn:okta</code></li></ul></td>
</tr>
<tr>
<td><code>action_id</code></td>
<td>Action ID of Action associated with the Custom Token Profile.</td>
</tr>
<tr>
<td><code>type</code></td>
<td>Should be set to <code>custom_authentication</code>.</td>
</tr>
</tbody>
</table>

これで、ユースケースに実装するカスタムトークン交換のコード作成とテストの準備が整いました。

```json lines
{
  "id":"tep_9xqewuejpa2RTltf",
  "name":"{{PROFILE_NAME}}",
  "type":"custom_authentication",
  "subject_token_type":"{{UNIQUE_PROFILE_TOKEN_TYPE_URI}}",
  "action_id":"{{ACTION_ID}}",
  "created_at":"2025-01-30T13:19:00.616Z",
  "updated_at":"2025-01-30T13:19:00.616Z"
}
```






カスタムトークン交換プロファイルを管理する

### カスタムトークン交換プロファイルを管理するには、Management APIを使用して`/token-exchange-profiles`エンドポイントに要求を送信します。

カスタムトークン交換プロファイルを取得するには、以下の要求を行います。複数のプロファイルがある場合のために、このエンドポイントは[チェックポイントページネーション](/api/management/v2/introduction#checkpoint-based-pagination)に対応しています。

To get all your Custom Token Exchange Profiles, make the following request. This endpoint supports [checkpoint pagination](https://auth0.com/docs/api/management/v2/introduction#checkpoint-based-pagination) in case you have several profiles.

```bash lines
curl --location 'https://{{YOUR _TENANT}}/api/v2/token-exchange-profiles' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
```






カスタムトークン交換プロファイルを削除するには、以下のDELETE要求を行います。

```bash lines
curl --location --request PATCH 'https://{{YOUR _TENANT}}/api/v2/token-exchange-profiles/{{PROFILE_ID}}' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
--data '{
    "name": "external-idp-migration",
    "subject_token_type": "urn:partner0:external-idp-migration"
}'
```






カスタムトークン交換とログイン後アクション

```bash lines
curl --location --request DELETE 'https://{{YOUR _TENANT}}/api/v2/token-exchange-profiles/{{PROFILE_ID}}' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
--data ''
```






## カスタムトークン交換とログイン後アクション

### カスタムトークン交換アクションは早期アクセス版のカスタムトークン交換の一部として提供され、「[Actions APIを使用する](#use-the-actions-api)」に記載の新しいAPIメソッドが使用できます。

アクセストークンにカスタムクレームを追加することなどが必要な場合は、トランザクションに設定済みのユーザーに対してカスタムトークン交換アクションを実行したた後に、[ログイン後アクショントリガー](/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger)を実行すると、ログインフローと同じ機能性が実現できます。

For other needs, such as adding custom claims to <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip>, your [Post Login Actions trigger](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger) executes after the Custom Token Exchange Action runs for the user that you set for the transaction, thus giving you the same functionality as other login flows.

To identify a transaction that uses the token exchange grant type, look for an `event.transaction.protocol` value equal to `oauth2-token-exchange` in your [Post Login Action](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger). Because the token exchange grant type is used by both the Custom Token Exchange and Native Social Login transactions, you can use the value of the `subject_token_type` to distinguish between the two, where the `subject_token_type` corresponds to one of your Custom Token Exchange Profiles.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange Early Access does not support [multi-factor authentication](/docs/secure/multi-factor-authentication). Enabling MFA as a tenant policy or using `api.multifactor.enable()`, `api.authentication.challengeWith(),` or `api.authentication.enrollWith()` is not yet supported for Custom Token Exchange and, within your Post-Login Action trigger, will result in the transaction failing with a non-recoverable error. Make sure you skip enabling MFA when `event.transaction.protocol==oauth2-token-exchange` depending on the `subject_token_type` value.

MFA support will be added in next iterations of Custom Token Exchange EA.

</Callout>

### トークン交換アクションで使用できるように、Auth0は数々のAPIメソッドを提供しています。`subject_token_type`に基づいてサブジェクトトークンの復号化と検証を行うアクションを実装してください。そうすることで、トランザクションのためにユーザー情報を入手できます。また、この情報を使用して、コードがトランザクションに必要な認可ポリシーを適用するようにします。トランザクションが続行できることを確認したら、対応するユーザーを設定してトランザクションを確定できます。そうすると、Auth0がアクセストークン、IDトークンとリフレッシュトークンをユーザーに発行します。これはユーザーを認証する1つの方法だと考えることができます。

カスタムトークン交換トランザクションはそれぞれ1つのテナントイベントログを生成します。トランザクションが成功すると種類が`secte`のイベントログが生成され、トランザクションが失敗すると種類が`fecte`のイベントログが生成されます。これらの種類は受け取るかもしれないエラーを理解するのに役立ちます。`/oauth/token`エンドポイントからのエラーには詳細があまり含まれません。

任意の接続タイプに対して、指定のユーザーIDを基にユーザー属性を設定します。これにより、プロファイルを更新することなく、既存のユーザーを指定できます。このメソッドはユーザーが存在しないか、ブロックされていると失敗します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange gives you the added flexibility to set the user for the transaction by taking on the additional responsibility of securely validating the corresponding subject token that identifies the user for the transaction.

Remember that subject tokens used with Custom Token Exchange can be any token format or type you require, as long as your Action code can interpret them. **You must implement strong validation of the tokens you receive and accept.** If you fail to do so, you open yourself up to different attack vectors, such as spoofing or replay attacks, resulting in bad actors being able to authenticate with someone else’s user ID.

To learn about different options for implementing secure validation of your subject tokens, read and apply the recommendations included in [Example Use Cases and Code Samples](#example-use-cases-and-code-samples). Make sure you also take into consideration and apply [Attack Protection](#attack-protection) capabilities.

</Callout>

#### 任意の接続タイプに対して、指定のユーザーIDを基にユーザー属性を設定します。これにより、プロファイルを更新することなく、既存のユーザーを指定できます。このメソッドはユーザーが存在しないか、ブロックされていると失敗します。

ユーザーとそのユーザーに関するプロファイル属性を指定の接続内で設定します。これは、ユーザーがこの接続にログインし、指定されたユーザープロファイルをフェデレーションIdPが返すことと同等です。ユーザーが存在しない場合にこの操作がユーザーを作成するか、そして、提供されたユーザープロファイル属性を使ってプロファイルを更新するかを構成できます。

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>user_id</code></td>
<td>The user ID, such as <code>auth0&amp;#124;55562040asf0aef</code>.</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // 1. Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // 2.  Apply your authorization policy on the user
  const isAuthorized = await authorizeAccess(subject_token.sub);
  if (!isAuthorized) {
    api.access.deny('Unauthorized_login', 'User cannot login due to reason: X');
  }

  // 3. Set the user for the transaction
  api.authentication.setUserById(subject_token.sub);

  return;
};
```






#### ユーザーとそのユーザーに関するプロファイル属性を指定の接続内で設定します。これは、ユーザーがこの接続にログインし、指定されたユーザープロファイルをフェデレーションIdPが返すことと同等です。ユーザーが存在しない場合にこの操作がユーザーを作成するか、そして、提供されたユーザープロファイル属性を使ってプロファイルを更新するかを構成できます。

Sets a user and their associated profile attributes in a specified connection. This is equivalent to returning the specified user profile from the federated IdP (or the corresponding Custom DB with [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) disabled) when a user logs into this connection. You can configure whether this operation should create the user if it does not exist, and whether it should update the profile using the provided user profile attributes.

対応されているユーザープロファイル属性

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Custom Token Exchange EA currently supports `setUserByConnection()` for Auth0 database connections, Enterprise and Social connections, and Custom DBs with [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) disabled.

</Callout>

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>connection_name</code></td>
<td>The name of the connection where the user profile will be set. Limited to 512 characters.</td>
</tr>
<tr>
<td><code>user_profile</code></td>
<td>An object containing the user profile attributes to be set. Limited to 24 properties.</td>
</tr>
<tr>
<td><code>options</code></td>
<td>An object specifying update and creation behavior.<br/><br/><code>\{updateBehavior: 'replace' | 'none',creationBehavior: 'create_if_not_exists' | 'none',}</code><br/><br/>If the user exists, <code>updateBahaviour</code> does the following:<br/><ul><li> <code>replace</code>: the user attributes and the <code>user_id</code> for the provided connection are replaced (existing user attributes that are not provided will be removed from the user. Partial updates are not supported).</li><li><code>none</code>: if the user exists, the profile is not updated. If the user does not exist, it will be created with the provided profile attributes depending on <code>creationBehavior</code> configuration.</li><li>If the user does not exist, <code>creationBehavior</code> does the following:</li><ul><li><code>create_if_not_exists</code>: create the user</li><li><code>none</code>: does not create the user and return with an error</li></ul></ul></td>
</tr>
</tbody>
</table>

```js lines expandable
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // 1. Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // 2.  Apply your authorization policy on the user
  const isAuthorized = await authorizeAccess(subject_token.sub);
  if (!isAuthorized) {
    api.access.deny('Unauthorized_login', 'User cannot login due to reason: X');
  }

  // 3. Set the user for the transaction
  api.authentication.setUserByConnection(
    'My Connection',
    {
      user_id: subject_token.sub,
      email: subject_token.email,
      email_verified: subject_token.email_verified,
      phone_number: subject_token.phone_number,
      phone_verified: subject_token.phone_number_verified,
      username: subject_token.preferred_username,
      name: subject_token.name,
      given_name: subject_token.given_name,
      family_name: subject_token.family_name,
      nickname: subject_token.nickname,
      verify_email: false
    },
    {
      creationBehavior: 'create_if_not_exists',
      updateBehavior: 'none'
    }
  );

  return;
};
```






##### `user_id `（必須）：この接続またはプロバイダーでユーザーに一意の識別子です。通常は、この接続について外部のIDプロバイダーが提供するユーザーIDです。このパラメーターは`creationBehaviour`と`updateBehaviour`の両方が`none`に設定されている場合にのみ必須です。

The `setUserByConnection()` method allows you to set profile attributes supported by the [Update a User](https://auth0.com/docs/api/management/v2/users/patch-users-by-id) endpoint:

* `user_id` (required): user's unique identifier for this connection/provider. It is typically the user ID provided by the external identity provider for the connection. This is the only required parameter when both `creationBehaviour` and `updateBehaviour` are set to `none`.
* メタデータを設定する
* ログインを試行するユーザーのアプリケーションメタデータを設定します。
* api.user.setAppMetadata(name, value)
* ログインを試行するユーザーのアプリケーションメタデータを設定します。
* 上のリストにはない属性の設定が必要な場合は、メタデータフィールドを使用してください。
* `family_name`
* 上のリストにはない属性の設定が必要な場合は、メタデータフィールドを使用してください。
* 対応されている接続ストラテジー
* 上のリストにはない属性の設定が必要な場合は、メタデータフィールドを使用してください。
* 対応されている接続ストラテジー

現在のバージョンは以下の接続ストラテジーに対応しています。これ以外のストラテジーでは、`setUserByConnection()`メソッドが失敗します。他のストラテジーへの対応をご希望の場合には、Auth0サポートまでお問い合わせください。

##### エンタープライズ接続：

ユーザーの作成には以下が必要です。

[SAML IdP](/authenticate/identity-providers/enterprise-identity-providers/saml)

* Custom database connections with  [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) disabled

[Okta](/authenticate/identity-providers/enterprise-identity-providers/okta)

* [Active Directory](/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap)
* [SAML IdPs](/docs/authenticate/identity-providers/enterprise-identity-providers/saml)
* [OIDC IdPs](/docs/authenticate/identity-providers/enterprise-identity-providers/oidc)
* [Okta](/docs/authenticate/identity-providers/enterprise-identity-providers/okta)
* [ADFS](/docs/authenticate/identity-providers/enterprise-identity-providers/adfs)

使用している接続に構成されている識別子を提供しなければなりません。メールはデフォルトで必須です。

* [柔軟な識別子と属性](/authenticate/database-connections/flexible-identifiers-and-attributes)を使用する接続については、該当する属性が接続に有効化されていれば、ユーザー名や電話番号を提供できます。
* 作成の動作
* ユーザーは`creationBehavior`が`create_if_not_exists`に設定されている場合にのみ動的に作成されます。
* ユーザーの作成には以下が必要です。
* 使用している接続に構成されている識別子を提供しなければなりません。メールはデフォルトで必須です。
* [柔軟な識別子と属性](/authenticate/database-connections/flexible-identifiers-and-attributes)を使用する接続については、該当する属性が接続に有効化されていれば、ユーザー名や電話番号を提供できます。

##### 柔軟な識別子と属性を使用しない接続については以下を行います。

接続に**［Require Username（ユーザー名を必須にする）］**が`true`に設定されている場合は、ユーザー名を提供できます。詳細については、「[データベース接続にユーザー名を追加する](/authenticate/database-connections/require-username)」をお読みください。

`phone_number`は提供できません。

* `email_verified`や`phone_verified`を指定しても構いません。
* For connections that use [Flexible Identifiers and Attributes](/docs/authenticate/database-connections/flexible-identifiers-and-attributes), you may provide a username and phone number if the corresponding attribute is enabled for the connection.
* 更新の動作

  + ユーザープロファイルは`updateBehavior`が`replace`に設定されている場合にのみ更新されます。
  + You may provide a username when the connection’s **Require Username** is set to `true`. To learn more, read [Adding Username for Database Connections](/docs/authenticate/database-connections/require-username).
  + メタデータを設定する
  * api.user.setAppMetadata(name, value)

A random password is generated for users dynamically created in Auth0 database connections. There are different options to trigger a [password reset flow](/docs/authenticate/database-connections/password-change) when needed after user creation.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Set `creationBehavior` to `none` when you want to log the user in but don’t want to create the user if they do not already exist in the connection.

Future iterations of Custom Token Exchange will make the email attribute optional dependent on the connection configuration.

</Callout>

##### `email_verified`

api.user.setUserMetadata(name, value)

メール検証

* メタデータを設定する
* api.user.setAppMetadata(name, value)
* ログインを試行するユーザーのアプリケーションメタデータを設定します。
* このメソッドはマージ動作に従うため、既存の属性に影響を与えることなく、追加する属性や更新する属性を指定できます。属性を削除するには、値を`null`に設定します。
* api.user.setUserMetadata(name, value)

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If you want to use `setUserByConnection()` to update a user profile that already contains `email`, `username`, or ログインを試行するユーザーのアプリケーションメタデータを設定します。 attributes, you must pass these attributes with the same value they already have. Otherwise, the method returns an error. Additionally, this action does not update the upstream Enterprise/Social IdP or the Custom DB, so make your updates match the latest version of the profile on the IdP/Custom DB if you want them to be in sync.

</Callout>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Set `updateBehavior` to `none` when you want to log the user in but don’t want to change any profile attributes if they already exist in the connection.

</Callout>

##### ログインを試行するユーザーの一般的なメタデータを設定します。

このメソッドはマージ動作に従うため、既存の属性に影響を与えることなく、追加する属性や更新する属性を指定できます。属性を削除するには、値を`null`に設定します。

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // Create a user but don't verify email
  api.authentication.setUserByConnection(
    'My Connection',
    {
      user_id: subject_token.sub,
      email: subject_token.email,
      email_verified: false,
      verify_email: false
    },
    {
      creationBehavior: 'create_if_not_exists',
      updateBehavior: 'none'
    }
  );

  return;
};
```






If you have [configured and enabled a welcome email template](/docs/customize/email/email-templates), Auth0 automatically sends a welcome email to newly created users when no email verification is sent.

##### ログイントランザクションを拒否して、呼び出し元にエラーを返します。

Unlike the [Update a User](https://auth0.com/docs/api/management/v2/users/patch-users-by-id) endpoint, the `setUserByConnection()` method does not allow you to set user or application metadata. Instead, you can use `api.user.setAppMetadata`. To learn how to correctly use metadata, read [How Metadata Works in User Profiles](/docs/manage-users/user-accounts/metadata). For metadata best practices, read [How to Manage User Metadata with the Post-login Trigger](/docs/manage-users/user-accounts/metadata/manage-user-metadata#best-practices).

#### トランザクションを拒否して、要求元の外部IPアドレスについて試行の失敗数を加算します。カスタムトークン交換は要求を`invalid_request`のエラーコードを使用した`400 Bad Request`エラー応答で拒否します。

試行の失敗が最大数に達すると、該当するIPアドレスからのすべてのカスタムトークン交換要求について、Auth0はトラフィックを`too_many_attempts`のエラーコードを使用した`429 Too Many Requests`エラー応答でブロックします。詳細については、「[攻撃防御](#attack-protection)」をお読みください。

このメソッドは、署名や暗号化が不適切、または有効期限切れのサブジェクトトークンを含むカスタムトークン交換要求を受け取った場合には必ず使用してください。また、なりすましやリプレイ攻撃など、不正使用が疑われる状況でも必ず使用してください。そうすることで、Auth0は構成に応じて、不審なIPのスロットリングを適用できるようになります。

<table class="table"><thead>
<tr>
<th><strong>Parameters</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>String. The name of the metadata property.</td>
</tr>
<tr>
<td><code>value</code></td>
<td>String, object or array. The name of the metadata property.</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {
  // Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // set the user for the transaction
  api.authentication.setUserById(subject_token.id);

  // set user group based on info contaiened in subject_token
  api.user.setAppMetadata('group', subject_token.group);

  return;
};
```






#### 不審なIPのスロットリングはデフォルトで最大10回まで、1時間あたりに6回の試行を許容します。詳細については、「[攻撃防御](#attack-protection)」をお読みください。

**重要：**このキャッシュは、短命で一時的なデータ向けに設計されています。項目が所定のライフタイム内であったとしても、後のトランザクションでは利用できないかもしれません。

実行間で維持されるデータの保管と取得を行います。

<table class="table"><thead>
<tr>
<th><strong>Parameters</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>String. The name of the metadata property.</td>
</tr>
<tr>
<td><code>value</code></td>
<td>String, object or array. The name of the metadata property.</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {
  // Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // set the user for the transaction
  api.authentication.setUserById(subject_token.id);

  // set user preferred_locale based on info contaiened in subject_token
  api.user.setUserMetadata('preferred_locale', subject_token.locale);

  return;
};
```






#### これらのメソッドはサブジェクトトークンを検証するために、署名検証の公開鍵などのデータをキャッシュする場合に役立ちます。`jwks-uri`からキーを取得する際のパフォーマンスを向上させることができます。

このキャッシュに保管された値は、それを設定するトリガーにスコープが限定されます。これは[アクションのキャッシュ制限](/customize/actions/limitations)の対象になります。

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>code</code></td>
<td>A string returned in the error property in the response.<br/><br/>Two standard error codes can be used:<ul><li><code>invalid_request</code>: Returns a <code>400</code> status code</li><li><code>server_error</code>: Returns <code>500</code> status code</li></ul><br/>If you use your own error code, it returns a <code>400</code> status code.</td>
</tr>
<tr>
<td><code>reason</code></td>
<td>A string returned in the <code>error_description</code> property in the response.</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // 1. Validate subject_token
  const subject_token = await validateToken(event.transaction.subject_token, jwksUri);

  // 2.  Apply your authorization policy on the user
  const isAuthorized = await authorizeAccess(subject_token.sub);
  if (!isAuthorized) {
    api.access.deny('Unauthorized_login', 'User cannot login due to reason: X');
  }

  // if user is authorized, go on as indicated here

};
```






#### 提供された`key`にキャッシュ済みの値が存在する場合は、それを記述したレコードを削除します。

値がキャッシュから削除されると、`CacheWriteResult`オブジェクトに`type: "success"`を含めて返します。操作に失敗すると、`type: "error"`を返します。エラーの場合には、返すオブジェクトに`code`プロパティを含めて、失敗の詳細を示します。

アクションイベント

Use this method whenever you receive a Custom Token Exchange request with a subject token that is not properly signed/encrypted or expired, or under any circumstance that points to any non-legitimate usage such as in a spoofing or replay attack. This allows Auth0 to activate <Tooltip tip="Suspicious IP Throttling: Form of attack protection that protects your tenant against suspicious logins targeting too many accounts from a single IP address." cta="View Glossary" href="/docs/glossary?term=Suspicious+IP+Throttling">Suspicious IP Throttling</Tooltip> protection as per your configuration.

提供された`key`にキャッシュが見つかった場合には、キャッシュレコードを返します。キャッシュレコードは`value`プロパティを含むオブジェクトで、このプロパティにはキャッシュ済みの値の他にも`expires_at`プロパティが含まれ、レコードの最大有効期間をUNIXエポックからの経過ミリ秒数で示します。

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reason</code></td>
<td>A string returned in the <code>error_description</code> property in the response</td>
</tr>
</tbody>
</table>

```js lines
exports.onExecuteCustomTokenExchange = async (event, api) => {

  try {
    // Validate subject_token
    const subject_token = await validateToken(event.transaction.subject_token, jwksUri);
    // set the user for the transaction
    api.authentication.setUserById(subject_token.id);

  } catch (error) {
    if (error.message === 'Invalid Token') {
      // If specifically the problem is the subject_token is invalid
      console.error('Invalid Token error');
      api.access.rejectInvalidSubjectToken('Invalid subject_token');
    } else {
      // if there is any other unexpected error, throw a server error
      throw error;
    }
  }

};
```






#### **重要：**このキャッシュは、短命で一時的なデータ向けに設計されています。項目が所定のライフタイム内であったとしても、後のトランザクションでは利用できないかもしれません。

トークン交換を呼び出す

指定されたkeyのキャッシュに文字列値を保管または更新します。

##### このキャッシュに保管された値は、それを設定するトリガーにスコープが限定されます。これは[アクションのキャッシュ制限](/customize/actions/limitations)の対象になります。

このように保管された値には、指定された`ttl`または`expires_at`値までのライフタイムがあります。ライフタイムが指定されない場合には、デフォルトのライフタイムである15分が使用されます。ライフタイムは[アクションのキャッシュ制限](/customize/actions/limitations)が定める最大値を超過してはいけません。

値が正常に保管されると、`CacheWriteSuccess`を返します。それ以外の場合は`CacheWriteError`を返します。

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>String. The key of the record stored in the cache.</td>
</tr>
</tbody>
</table>

##### アクションイベント

新しいActions APIメソッドに加えて、アクションイベントのデータを使用して、サブジェクトトークン、IPアドレス、クライアントなど、トークン交換要求のコンテキストについて知ることができます。

アクションをデプロイする

上記のAPIとイベントオブジェクトでトークン交換アクションを作成したら、ページの上部にある**［Deploy（デプロイ）］**をクリックして変更内容をデプロイします。

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>String. The key of the record stored in the cache.</td>
</tr>
</tbody>
</table>

##### トークン交換を呼び出す

カスタムトークン交換を使用するには、以下のパラメーターを指定して`POST`要求を`/oauth/token`エンドポイントに対して行います。以下に留意してください。

Values stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](/docs/customize/actions/limitations).

Values stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default lifetime of 15 minutes will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](/docs/customize/actions/limitations).

その他の拡張パラメーターは、対応するアクションの`event.request.body`に含まれていますが、無視されます。

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>String. The key of the record stored in the cache.</td>
</tr>
<tr>
<td><code>value</code></td>
<td>String. The value of the record to be stored.</td>
</tr>
<tr>
<td><code>options</code></td>
<td>Optional object. Options for adjusting cache behavior.</td>
</tr>
<tr>
<td><code>options.expires_at</code></td>
<td>Optional number. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the supplied <code>expires_at</code>.<br/><br/><strong>Note:</strong> This value should not be supplied if a value was also provided for <code>ttl</code>. If both options are supplied, the earlier expiry of the two will be used.</td>
</tr>
<tr>
<td><code>options.ttl</code></td>
<td>Optional number. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the supplied <code>ttl</code>.<br/><br/><strong>Note:</strong> This value should not be supplied if a value was also provided for expires_at. If both options are supplied, the earlier expiry of the two will be used.</td>
</tr>
</tbody>
</table>

## 要求例

攻撃防御

<table class="table"><thead>
<tr>
<th><strong>Property</strong></th>
<th><strong>Type</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>client</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>client_id</code></td>
<td>string</td>
<td><code>HOVc2PDFTH7eahimN4yNCo8mOtjfNjLV</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td>string</td>
<td><code>My Web App</code></td>
</tr>
<tr>
<td><code>metadata</code></td>
<td>object</td>
<td><code>\{“foo”: “bar” }</code></td>
</tr>
<tr>
<td><em>tenant</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>id</code></td>
<td>string</td>
<td><code>dev_1234</code></td>
</tr>
<tr>
<td>request</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>geoip</code></td>
<td>object</td>
<td><code>\{ … geoip object}</code></td>
</tr>
<tr>
<td><code>hostname</code></td>
<td>string</td>
<td><code>dev_1234.us.auth0.com</code></td>
</tr>
<tr>
<td><code>ip</code></td>
<td>string</td>
<td><code>123.42.42.34</code></td>
</tr>
<tr>
<td><code>user_agent</code></td>
<td>string</td>
<td><code>Mozilla/5.0</code></td>
</tr>
<tr>
<td><code>language</code></td>
<td>string</td>
<td><code>en</code></td>
</tr>
<tr>
<td><code>body</code></td>
<td>object</td>
<td><code>\{ // raw req.body }</code></td>
</tr>
<tr>
<td><code>method</code></td>
<td>string</td>
<td><code>POST</code></td>
</tr>
<tr>
<td><em>transaction</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>subject_token_type</code></td>
<td>string</td>
<td><code>urn://cic-migration-token</code></td>
</tr>
<tr>
<td><code>subject_token</code></td>
<td>string</td>
<td><code>41598922a1745f7af70</code></td>
</tr>
<tr>
<td><code>requested_scopes</code></td>
<td>string[]</td>
<td><code>[“openid”, “email”]</code></td>
</tr>
<tr>
<td><em>resource_server</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>id</code></td>
<td>string</td>
<td><code>http://acme-api/v1/profile</code></td>
</tr>
</tbody>
</table>

## なりすましやリプレイ攻撃で悪意のある攻撃者がサブジェクトトークンを推測または再利用しようとするのを防ぐために、カスタムトークン交換は[不審なIPのスロットリング](/secure/attack-protection/suspicious-ip-throttling)に対応しています。これにより、[サブジェクトトークンが無効](#api-access-rejectinvalidsubjecttoken-reason-)な場合に、アクション内のコードから信号を特異的に送信できるため、Auth0は外部IPからの試行の失敗をカウントできます。

構成済みの期間が過ぎると、IPアドレスは要求を再び行えるようになります。

<Frame>![](/images/cdy7uua7fh8z/61fgdh8VJEmfiYn0l7Tem0/3ceac5de5413373662e8b800d8f80210/Screenshot_2025-02-03_at_9.30.50_PM.png)</Frame>

## すべての事例で推奨されることですが、**不審なIPのスロットリングを正しく構成してアクティブ化することは、カスタムトークン交換をネイティブアプリケーションやシングルページアプリケーションで使用する場合には特に重要です**。ネイティブアプリケーションやSPAなどの非機密アプリケーションは、自身を認証するためにシークレットを安全に保管できません。攻撃者は簡単にサブジェクトトークンを推測したり、窃盗や漏洩したものを使用したりできます。

不審なIPのスロットリングを正しく使用するためには、受け取ったサブジェクトトークンが厳密に検証されない場合は必ず、アクションのコードに`api.access.rejectInvalidSubjectToken`を使用してください。

* 不審なIPのスロットリングはAuth0テナントにはデフォルトでアクティブ化されます。アクティブ化や構成の方法については、「[不審なIPのスロットリング](/secure/attack-protection/suspicious-ip-throttling)」をお読みください。アクティブ化すると、カスタムトークン交換のデフォルト設定が適用されます。
* しきい値：10。1つのIPアドレスが失敗した試行の最大数です。

<table class="table"><thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>grant_type</code></td>
<td>For Custom Token Exchange, use <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</td>
</tr>
<tr>
<td><code>subject_token_type</code></td>
<td>The type of the subject token. For Custom Token Exchange, this can be any URI scoped under your own ownership, such as `http://acme.com/legacy-token` or <code>urn:acme:legacy-token</code>.<br/><br/>The following namespaces are reserved and cannot be used:<ul><li>`http://auth0.com`</li><li>`https://auth0.com`</li><li>`http://okta.com`</li><li>`https://okta.com`</li><li><code>urn:ietf</code></li><li><code>urn:auth0</code></li><li><code>urn:okta</code></li></ul></td>
</tr>
<tr>
<td><code>subject_token</code></td>
<td>The subject token, which your action should validate and use to identify the user.</td>
</tr>
<tr>
<td><code>client_id</code></td>
<td>The client ID of the application you are using for the Token Exchange. As for other grant types, you can also pass the client ID in the Authorization header using HTTP Basic Auth.</td>
</tr>
<tr>
<td><code>client_secret</code></td>
<td>The client secret of the application you are using for the Token Exchange. As for other grant types, you can also pass the client secret in the Authorization header using HTTP Basic Auth.<br/><br/>Other alternatives are also available as explained in <a href="https://auth0.com/docs/api/authentication#authentication-methods">Auth0 Authentication API reference docs</a>.<br/><br/>Note Custom Token Exchange can be used by public Applications. Make sure to read <a href="#attack-protection">Attack Protection</a> in that case.</td>
</tr>
<tr>
<td><code>audience</code></td>
<td>The API identifier defined in Auth0.</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>The OAuth2 scope parameter.</td>
</tr>
</tbody>
</table>

スロットリングレート：1時間あたり6回。しきい値を超えない範囲で10分ごとに1回の試行が補充されます。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

この問題を解消するには、Auth0 Dashboardを使用してAPIに**［Allow Skipping User Consent（ユーザー同意のスキップを許可する）］**オプションを有効にします。 is not yet supported in Custom Token Exchange EA. Adding an organization parameter results in the request being rejected. この問題を解消するには、Auth0 Dashboardを使用してAPIに**［Allow Skipping User Consent（ユーザー同意のスキップを許可する）］**オプションを有効にします。 support will be added in the next iterations of Custom Token Exchange.

</Callout>

### カスタムトークン交換には、Management APIを使用してカスタムのしきい値やスロットリングレートを構成できます。

```bash lines
curl --location 'https://{{YOUR_TENANT}}/oauth/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=urn:ietf:params:oauth:grant-type:token-exchange' \
--data-urlencode 'audience=https://api.acme.com' \
--data-urlencode 'scope=openid offline_access acme-scope1 acme-scope2' \
--data-urlencode 'subject_token_type=urn:acme:external-idp-migration' \
--data-urlencode 'subject_token=t8e7S2D9trQm73e .... iqBR3GjxDtbDVjpfQU' \
--data-urlencode 'client_id={{CLIENT_ID}}' \
--data-urlencode 'client_secret={{CLIENT_SECRET}}'
```






## まず、APIを使用するために[Management APIトークンを取得](/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens)します。そして、以下のGET要求を[不審なIPのスロットリング設定取得エンドポイント]()に対して行います。

To protect against spoofing and replay attacks, in which a <Tooltip tip="Bad Actors: Entity (a person or group) that poses a threat to the business or environment with the intention to cause harm." cta="View Glossary" href="/docs/glossary?term=bad+actor">bad actor</Tooltip> tries to guess or reuse a subject token, Custom Token Exchange incorporates support for [Suspicious IP Throttling](/docs/secure/attack-protection/suspicious-ip-throttling). This enables you to specifically signal from your code in Actions when [a subject token is invalid](#api-access-rejectinvalidsubjecttoken-reason-), so Auth0 can count the failed attempts sent from that external IP.

以下の`PATCH`要求では`pre-custom-token-exchange`ステージを必要な値で更新できます。レートは新たに試行が許可されるまでをミリ秒単位の間隔で表していることに注意してください。

```json lines
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
{
    "error": "too_many_attempts",
    "error_description": "We have detected suspicious login behavior and further attempts will be blocked. Please contact the administrator."
}
```






ユースケースの例とサンプルコード

技術的な制約やユーザーエクスペリエンスの観点から、エンドユーザーのリダイレクトに基づく標準的なフェデレーションログインストラテジーが適用できない高度な統合シナリオには、カスタムトークン交換をソリューションとして使用できます。ユースケースに提供するコードは不完全なものであり、対処するコードを論理的に進められるように説明することのみを意図しています。より詳しいサンプルコードについては、「[サンプルコード](#code-samples)」を参照してください。

このセクションでは、ユースケースの例と該当するシナリオの実装に推奨されるサンプルコードを紹介します。ユースケースを説明するために、GearUpという架空のレンタカー会社を想定します。

Suspicious IP Throttling is activated by default for Auth0 tenants. To learn more about how to (de)activate and configure it, read [Suspicious IP Throttling](/docs/secure/attack-protection/suspicious-ip-throttling). When activated, the default settings for Custom Token Exchange will be applied:

* GearUpには何百万人もが使用するモバイルアプリがあり、アイデンティティソリューションの近代化が必要なため、Auth0を使用することに決めました。ただし、レガシーIDプロバイダー（IdP）からの移行に関してユーザーエクスペリエンスでの摩擦を懸念して、ユーザーに再認証を強制することは避けたいと考えています。
* これを解消し、リスクを制限するために、GearUpは段階的に移行しています。それぞれのユーザーについて、レガシーIdPからのリフレッシュトークンをAuth0のアクセストークン、リフレッシュトークン、IDトークンのセットに交換することを希望しています。そうすることで、アプリが速やかにAuth0をIdPとして使い始め、Auth0発行のトークンを用いてGearUp APIを使用できるようになります。すべてのユーザーに交換が完了したら、エンドユーザーとGearUpのビジネスに影響することなく、アプリは完全に移行され、古いIdPが切断されます。

<Frame>![](/images/cdy7uua7fh8z/47PB3OAci9fotSHFrCNBVn/1bafbaacbeb22a4d94eb78506ab89bb8/Screenshot_2025-02-03_at_4.44.29_PM.png)</Frame>

前提条件として、GearUpはAuth0テナントに[ユーザーの一括インポート](/manage-users/user-migration/bulk-user-imports)を行い、モバイルアプリには移行するユーザーの有効なレガシーリフレッシュトークンがあります。

First, [get a Management API token](/docs/secure/tokens/access-tokens/management-api-access-tokens#get-management-api-tokens) to consume the API. Then, send the following GET request to the [Get Suspicious IP Throttling settings endpoint](https://auth0.com/docs/api/management/v2/attack-protection/get-suspicious-ip-throttling):

```bash lines
curl --location 'https://{{YOUR _TENANT}}/api/v2/attack-protection/suspicious-ip-throttling' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
```






Auth0はユーザーを作成しません。

```json lines
{
  "enabled": true,
  "shields": [
    "admin_notification",
    "block"
  ],
  "allowlist": [],
  "stage": {
    "pre-login": {
      "max_attempts": 100,
      "rate": 864000
    },
    "pre-user-registration": {
      "max_attempts": 50,
      "rate": 1200
    },
    "pre-custom-token-exchange": {
      "max_attempts": 10,
      "rate": 600000
    }
  }
}
```






Auth0はユーザープロファイルを更新しません。

```bash lines
curl --location --request PATCH 'https://{{YOUR _TENANT}}/api/v2//attack-protection/suspicious-ip-throttling' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer {{MANAGEMENT_API_TOKEN}}' \
--data '{"stage":{"pre-custom-token-exchange":{"max_attempts":10,"rate":600000}}}'
```






## Auth0は外部IdPのユーザーIDを使用して、該当する接続でユーザーを設定します。

不透明なリフレッシュトークンをレガシーIdPで検証する方法の詳しい例については、「[サンプルコード](#code-samples)」をお読みください。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0 recommends using normal, out-of-the-box federated login whenever possible. By allowing you to set the user for the transaction, Custom Token Exchange gives you more flexibility by taking on the additional responsibility of securely validating and handling the transaction.

</Callout>

ユースケース：外部の認証プロバイダーを再利用する

### 別のユースケースでは、GearUpがAir0という大手旅行会社と提携し、Air0のシングルページアプリケーション内でレンタカーサービスを直接提供します。GearUpは自社APIの使用をカプセル化したJavaScriptライブラリーを提供します。そうすることで、レンタカーサービスを提供するAir0のWebサイトがGearUpのAPIを手軽に使用できるようになります。

今回も、GearUpへの再認証を避けて、ソリューションがエンドユーザーから見えないようにする必要があります。これを実現するために、GearUpのJavaScriptライブラリーは外部のAir0 IDトークンを入力として使用し、トークン交換を処理できます。その結果、Auth0のアクセストークンが生成され、メールアドレスを基に所定のGearUpユーザーと関連付けられます。GearUpライブラリーがアクセストークンを取得したら、Air0のWebサイトで直接レンタカーサービスを提供するために、GearUpのAPIを使い始めることができます。

To solve this, and to limit risks, GearUp is migrating incrementally. For each user, they wish to exchange the refresh token from their legacy IdP for an Auth0 access token, refresh token and <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+token">ID token</Tooltip> set. This allows their app to seamlessly start using Auth0 as the IdP for this user, as well as consume GearUp APIs using Auth0-issued tokens. Once the exchange is done for all users, the app will be fully migrated and the old IdP can be disconnected–all without impacting end users and GearUp’s business.

<Frame>![](/images/cdy7uua7fh8z/2Ke6p3yZl06KT4HHqtaVu9/5d9c5feb98d614d6d793fb01ccc03e92/Screenshot_2025-02-03_at_5.00.32_PM.png)</Frame>

As a prerequisite, GearUp has done a [bulk user import](/docs/manage-users/user-migration/bulk-user-imports) into their Auth0 tenant and the mobile app has a valid legacy refresh token for each user to be migrated.

1. The mobile app makes a request to Auth0 to exchange the legacy refresh token, setting it as the subject token.
2. The corresponding Custom Token Exchange profile Action executes. It validates the refresh token with the legacy IdP and gets the external user ID from the user profile. It then applies the required authorization policy and finally sets the user.
3. Auth0 responds with Auth0 access token, ID token, and refresh token.
4. The mobile app can now use the Customer APIs using Auth0 tokens without the user having to re-authenticate.

Auth0は外部IdPのユーザーIDを使用して、該当する接続でユーザーを設定します。

* ユーザーが存在しない場合にはAuth0が作成します。
* ユーザーがすでに存在する場合のために、より完全な属性のセットがフェデレーションログインで取得できるのであれば、Auth0はユーザープロファイルを置換しません。

Auth0がAuth0のユーザーIDを使用してユーザーを設定するため、接続のスコープにこれを設定する必要はありません。

```javascript lines expandable
/**
* Handler to be executed while executing a custom token exchange request
* @param {Event} event - Details about the incoming token exchange request.
* @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
*/
exports.onExecuteCustomTokenExchange = async (event, api) => {

 // 1. VALIDATE the refresh_token received in the subject_token by using it to get
 // the UserProfile from the external IdP
 const { isValid, user } = await getUserProfile(
   event.transaction.subject_token,
   event.secrets.CLIENT_SECRET,
 );

 if (!isValid) {
   // Mark the subject token as invalid and fail the transaction.
   api.access.rejectInvalidSubjectToken("Invalid subject_token");
 } else {
   // 2. Apply your AUTHORIZATION POLICY as required to determine if the request is valid.
   // Use api.access.deny() to reject the transaction in those cases.

   // 3. When we have the profile, we SET THE USER in the target connection
   api.authentication.setUserByConnection(
     connectionName,
     {
       // only the user_id in the connection is needed, as we are not
       // creating nor updating the user
       user_id: user.sub,
     },
     {
       creationBehavior: "none",
       updateBehavior: "none",
     },
   );
 }
};

/**
* Exchange the refresh token and load the user profile from the legacy IdP
* @param {string} refreshToken
* @param {string} clientSecret
* @returns {Promise<{ isValid: boolean, user?: object }>} If the refresh token was exchanged successfully, returns the user profile
*/
async function getUserProfile(refreshToken, clientSecret) {
 // Add your code here. REFER TO CODE SAMPLES FOR DETAILED EXAMPLES
}
```






JWTを安全に検証する方法の詳しい例については、「[サンプルコード](#code-samples)」をお読みください。

### ユースケース：別のオーディエンスのAuth0トークンを取得する

GearUpはAPI要求を処理するために、内部のマイクロサービス間で呼び出しの認可方法を改善したいと考えています。それぞれのサービスに使用可能なリソースを制御するために、ポリシーの一元管理を希望しています。これもトークン交換を使用して実現できます。

まず、API要求がサービスAに到達すると、受け取ったアクセストークンを、新しいオーディエンスとしてサービスBの使用を許可する新しいアクセストークンに交換します。トークン交換を管理する認可ポリシーが許す場合、サービスAが新しいトークンを取得して、サービスBが使用できるようになります。ユーザーIDは新しいトークンで変わらずに維持されるため、ユーザーの正しいコンテキストがプロセス全体で維持されます。

<Frame>![](/images/cdy7uua7fh8z/34AVzwyYARK6fn2IEnLsQn/409082d736d8495b637626406977fb1f/Screenshot_2025-02-03_at_5.08.47_PM.png)</Frame>

GearUpアプリケーションは当初、API Aをユーザーに代わって使用するために、アクセストークンを取得します。

1. The Single Page App gets the ID token from the external IdP once the user authenticates.
2. It then requests the exchanges of the ID token, setting it as the subject token.
3. The corresponding Custom Token Exchange profile Action executes. It validates the ID token and gets the user ID and other profile attributes from the token. It then applies the required authorization policy and finally sets the user.
4. Auth0 responds with Auth0 access token, ID token and refresh token.
5. The javascript code running in the SPA can now use the Customer APIs using Auth0 tokens without the user having to re-authenticate.

Actionsの[api.cache](#api-cache)メソッドを使用し、トランザクションごとに署名鍵を取得しないようにします。

* Auth0がAuth0のユーザーIDを使用してユーザーを設定するため、接続のスコープにこれを設定する必要はありません。
* Auth0はユーザーの作成や更新を行いません。
* このユースケースに関する詳しいサンプルコードについては、「[非対称鍵で署名されたJWTを検証する](#validate-jwts-signed-with-asymmetric-keys)」を参照してください。
* JWTを安全に検証する方法の詳しい例については、「[サンプルコード](#code-samples)」をお読みください。

```javascript lines expandable
const jwksUri = "https://example.com/.well-known/jwks.json";

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {

  // 1. VALIDATE the id_token received in the subject_token
  const { isValid, payload } = await validateToken(
    event.transaction.subject_token,
  );

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
  } else {
    // 2. Apply your AUTHORIZATION POLICY as required to determine if the request is valid.
    // Use api.access.deny() to reject the transaction in those cases.

    // 3. SET THE USER in the target connection.
    // We don't want to verify emails when users are created
    // This example assumes subject_token (id_token) contains standard OIDC claims. Other custom mappings
    // are also possible.
    api.authentication.setUserByConnection(
      'Enterprise-OIDC',
      {
          user_id: formattedUserId,
          email: subject_token.email,
          email_verified: subject_token.email_verified,
          phone_number: subject_token.phone_number,
          phone_verified: subject_token.phone_number_verified,
          username: subject_token.preferred_username,
          name: subject_token.name,
          given_name: subject_token.given_name,
          family_name: subject_token.family_name,
          nickname: subject_token.nickname,
          verify_email: false
      },
      {
          creationBehavior: 'create_if_not_exists',
          updateBehavior: 'none'
      }
    );
  }

  /**
   * Validate the subject token
   * @param {string} subjectToken
   * @returns {Promise<{ isValid: boolean, payload?: object }>} Payload of the token
   */
  async function validateToken(subjectToken) {
    // Add your code here. REFER TO CODE SAMPLES FOR DETAILED EXAMPLES
  }
};
```






Read [code samples](#code-samples) for a more detailed example on how to securely validate <Tooltip tip="JSON Web Token (JWT): Standard ID Token format (and often Access Token format) used to represent claims securely between two parties." cta="View Glossary" href="/docs/glossary?term=JWTs">JWTs</Tooltip>.

### 以下のサンプルコードは、受け取ったサブジェクトトークンを安全で効率よく検証するために、シナリオ共通のベストプラクティスを示しています。

Auth0とシークレットを共有する必要がない場合は、できる限り非対称のアルゴリズムと鍵を使用します。これは、適用できるk公開鍵を公表するためにJWKS URIエンドポイントを公開する場合などで、鍵のローテーションも簡素化します。

非対称鍵で署名されたJWTを検証する

<Frame>![](/images/cdy7uua7fh8z/5Zw7yaJGct9eHAl4rdf72D/42274a5896851a16bea402ac52037f52/Screenshot_2025-02-03_at_5.17.14_PM.png)</Frame>

以下の推奨事項を検討してください。

1. The app sends the request with the initial access token to API A.
2. API A backend service validates the access token and requests to exchange by setting it as the subject token for a new access token to consume API B.
3. The corresponding Custom Token Exchange profile Action executes. It validates the access token and gets the Auth0 user ID from the token. It then applies the required authorization policy and finally sets the user.
4. Auth0 responds with an Auth0 access token to consume the API B audience.
5. API A backend service calls API B using the new access token, which is still associated with the same user.

Actionsの[api.cache](#api-cache)メソッドを使用し、トランザクションごとに署名鍵を取得しないようにします。

* [RFC8725]()のベストプラクティスに従います。
* RS*、PS*、ES*、またはEd25519のアルゴリズムを使用します。

noneアルゴリズムを使用したり、受け入れたりしてはいけません。

```javascript lines expandable
const jwksUri = "https://example.com/.well-known/jwks.json";

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {
  // 1. VALIDATE the access_token received in the subject_token
  const { isValid, payload } = await validateToken(
    event.transaction.subject_token,
  );

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
  } else {
    // 2. Apply your AUTHORIZATION POLICY as required to determine if the request is valid.
    // Use api.access.deny() to reject the transaction in those cases.

    // 3. SET THE USER
    api.authentication.setUserById(payload.sub);
  }

  /**
   * Validate the subject token
   * @param {string} subjectToken
   * @returns {Promise<{ isValid: boolean, payload?: object }>} Payload of the token
   */
  async function validateToken(subjectToken) {
    // Add your code here. REFER TO CODE SAMPLES FOR DETAILED EXAMPLES
  }
};
```






最小長2048ビットのRSAを使用します。

### 対称鍵で署名されたJWTを検証する

以下の推奨事項を検討してください。

[Actionsシークレット](/customize/actions/write-your-first-action#add-a-secret)を使用して、対称シークレットを安全に保管します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

It is your responsibility to ensure that subject tokens are protected with a strong algorithm and keys/secrets with enough entropy.

</Callout>

#### [RFC8725]()のベストプラクティスに従います。

カスタムデータベース接続

* 外部サービスで不透明なトークンを検証する
* Adhere to [RFC8725](https://www.rfc-editor.org/rfc/rfc8725.txt) best practices
* Use RS\*, PS\*, ES\* or Ed25519 algorithms
* 早期アクセス版のカスタムトークン交換は以下の機能には対応していません（または正しく動作しません）。
* この問題を解消するには、Auth0 Dashboardを使用してAPIに**［Allow Skipping User Consent（ユーザー同意のスキップを許可する）］**オプションを有効にします。

```javascript lines expandable
const { jwtVerify } = require("jose");

const jwksUri = "https://example.com/.well-known/jwks.json";
const fetchTimeout = 5000; // 5 seconds

const validIssuer = "urn:my-issuer"; // Replace with your issuer

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {
  const { isValid, payload } = await validateToken(
    event.transaction.subject_token,
  );

  // Apply your authorization policy as required to determine if the request is valid.
  // Use api.access.deny() to reject the transaction in those cases.

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
  } else {
    // Set the user in the current request as authenticated, using the user ID from the subject token.
    api.authentication.setUserById(payload.sub);
  }

  /**
   * Validate the subject token
   * @param {string} subjectToken
   * @returns {Promise<{ isValid: boolean, payload?: object }>} Payload of the token
   */
  async function validateToken(subjectToken) {
    try {
      const { payload, protectedHeader } = await jwtVerify(
        subjectToken,
        async (header) => await getPublicKey(header.kid),
        {
          issuer: validIssuer,
        },
      );

      // Perform additional validation on the token payload as required

      return { isValid: true, payload };
    } catch (/** @type {any} */ error) {
      if (error.message === "Error fetching JWKS") {
        throw new Error("Internal error - retry later");
      } else {
        console.log("Token validation failed:", error.message);
        return { isValid: false };
      }
    }
  }

  /**
   * Get the public key to use for key verification. Load from the actions cache if available, otherwise
   * fetch the key from the JWKS endpoint and store in the cache.
   * @param {string} kid - kid (Key ID) of the key to be used for verification
   * @returns {Promise<Object>}
   */
  async function getPublicKey(kid) {
    const cachedKey = api.cache.get(kid);
    if (!cachedKey) {
      console.log(`Key ${kid} not found in cache`);
      const key = await fetchKeyFromJWKS(kid);
      api.cache.set(kid, JSON.stringify(key), { ttl: 600000 });
      return key;
    } else {
      return JSON.parse(cachedKey.value);
    }
  }

  /**
   * Fetch public signing key from the provided JWKS endpoint, to use for token verification
   * @param {string} kid - kid (Key ID) of the key to be used for verification
   * @returns {Promise<object>}
   */
  async function fetchKeyFromJWKS(kid) {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), fetchTimeout);

    /** @type {any} */
    const response = await fetch(jwksUri);

    if (!response.ok) {
      console.log(`Error fetching JWKS. Response status: ${response.status}`);
      throw new Error("Error fetching JWKS");
    }
    const jwks = await response.json();
    const key = jwks.keys.find((key) => key.kid === kid);
    if (!key) {
      throw new Error("Key not found in JWKS");
    }
    return key;
  }
};
```






#### MFA：ログイン後アクションの`api.authentication.challengeWith()`および`api.multifactor.enable()`コマンドはカスタムトークン交換に未対応であるため、トランザクションが回復不可能なエラーで失敗します。同様に、テナントのポリシーとしてMFAが構成されている場合にも、トランザクションが失敗します。

カスタムデータベース接続

* Use [Actions Secrets](/docs/customize/actions/write-your-first-action#add-a-secret) to securely store your symmetric secrets.
* Adhere to [RFC8725](https://www.rfc-editor.org/rfc/rfc8725.txt) best practices
* レート制限

```javascript lines expandable
const { jwtVerify } = require("jose");

const validIssuer = "urn:my-issuer"; // Replace with your issuer

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {
  // Initialize the shared symmetric key from Actions Secrets
  const encoder = new TextEncoder();
  const symmetricKey = encoder.encode(event.secrets.SHARED_SECRET);

  const { isValid, payload } = await validateToken(
    event.transaction.subject_token,
    symmetricKey,
  );

  // Apply your authorization policy as required to determine if the request is valid.
  // Use api.access.deny() to reject the transaction in those cases.

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
  } else {
    // Set the user in the current request as authenticated, using the user ID from the subject token.
    api.authentication.setUserById(payload.sub);
  }
};

/**
 * Validate the subject token
 * @param {string} subjectToken
 * @param {Uint8Array} symmetricKey
 * @returns {Promise<{ isValid: boolean, payload?: object }>} Payload of the token
 */
async function validateToken(subjectToken, symmetricKey) {
  try {
    // Validate token is correctly signed with the shared symmetric key
    // It also checks it is not expired as long as it includes an 'exp' attribute.
    const { payload, protectedHeader } = await jwtVerify(
      subjectToken,
      symmetricKey,
      {
        issuer: validIssuer,
      },
    );

    return { isValid: true, payload };
  } catch (/** @type {any} */ error) {
    console.log("Token validation failed:", error.message);
    return { isValid: false };
  }
}
```






#### エンティティ制限

Use [Action Secrets](/docs/customize/actions/write-your-first-action#add-a-secret) to securely store your external IdP <Tooltip tip="Client Secret: Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable." cta="View Glossary" href="/docs/glossary?term=client+secret">client secret</Tooltip>.

```javascript lines expandable
const tokenEndpoint = "EXTERNAL_TOKEN_ ENDPOINT";
const userInfoEndpoint = "EXTERNAL_USER_INFO_ENDPOINT";
const clientId = "EXTERNAL_CLIENT_ID";
const connectionName = "YOUR_CONNECTION_NAME";
const fetchTimeout = 5000; // 5 seconds

/**
 * Handler to be executed while executing a custom token exchange request
 * @param {Event} event - Details about the incoming token exchange request.
 * @param {CustomTokenExchangeAPI} api - Methods and utilities to define token exchange process.
 */
exports.onExecuteCustomTokenExchange = async (event, api) => {
  const { isValid, user } = await getUserProfile(
    event.transaction.subject_token,
    event.secrets.CLIENT_SECRET,
  );

  if (!isValid) {
    // Mark the subject token as invalid and fail the transaction.
    api.access.rejectInvalidSubjectToken("Invalid subject_token");
    return;
  }

  // Apply your authorization policy as required to determine if the request is valid.
  // Use api.access.deny() to reject the transaction in those cases.

  // When we have the profile, we set the user in the target connection
  api.authentication.setUserByConnection(
    connectionName,
    {
      // only the user_id in the connection is needed, as we are not
      // creating nor updating the user
      user_id: user.sub,
    },
    {
      creationBehavior: "none",
      updateBehavior: "none",
    },
  );
};

/**
 * Exchange the refresh token and load the user profile from the legacy IdP
 * @param {string} refreshToken
 * @param {string} clientSecret
 * @returns {Promise<{ isValid: boolean, user?: object }>} If the refresh token was exchanged successfully, returns the user profile
 */
async function getUserProfile(refreshToken, clientSecret) {
  const { isValid, accessToken } = await refreshAccessToken(
    refreshToken,
    clientSecret,
  );
  if (!isValid) {
    return { isValid: false };
  }

  const controller = new AbortController();
  setTimeout(() => controller.abort(), fetchTimeout);

  /** @type {any} */
  const response = await fetch(userInfoEndpoint, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json",
    },
  });

  if (!response.ok) {
    console.log(`Failed to fetch user info. Status: ${response.status}`);
    throw new Error("Error fetching user info");
  }

  const userProfile = await response.json();

  return { isValid: true, user: userProfile };
}

/**
 * Use the Refresh Token with the legacy IdP to validate it and get an access token
 * @param {string} refreshToken
 * @param {string} clientSecret
 * @returns {Promise<{ isValid: boolean, accessToken?: string }>} If the refresh token was exchanged successfully, returns the access token
 */
async function refreshAccessToken(refreshToken, clientSecret) {
  const controller = new AbortController();
  setTimeout(() => controller.abort(), fetchTimeout);

  /** @type {any} */
  let response;

  try {
    response = await fetch(tokenEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: refreshToken,
        client_id: clientId,
        client_secret: clientSecret,
      }).toString(),
    });
  } catch (error) {
    console.error("Error refreshing token");
    throw error;
  }

  if (!response.ok) {
    const errorBody = await response.json();
    console.error("Error refreshing token:", errorBody.error);

    // If we receive an error indicating the refresh token is invalid (for example, an invalid_grant error),
    // then we should explicitly indicate an invalid token using api.access.rejectInvalidSubjectToken
    // to prevent against brute force attacks on the refresh token by activating Suspicious IP Throttling.
    // For other errors which indicate a generic error making the request to the IdP, we should throw
    // an error to indicate a transient failure.
    if (errorBody.error === "invalid_grant") {
      return { isValid: false };
    } else {
      throw new Error("Error refreshing token");
    }
  }

  // Parse the response, in the form { access_token: "...", expires_in: ..., }
  const data = await response.json();
  console.log("Successfully exchanged refresh token");
  return { isValid: true, accessToken: data.access_token };
}
```






## アクションの総数もAuth0プランに応じて制限されます。詳細については、「[Auth0の価格設定]()」ページを参照してください。

トラブルシューティング

「同意が必要」応答

* この問題を解消するには、Auth0 Dashboardを使用してAPIに**［Allow Skipping User Consent（ユーザー同意のスキップを許可する）］**オプションを有効にします。
* <Tooltip tip="Multi-factor authentication (MFA): User authentication process that uses a factor in addition to username and password such as a code via SMS." cta="View Glossary" href="/docs/glossary?term=MFA">MFA</Tooltip>: `api.authentication.challengeWith()` and `api.multifactor.enable()` commands in Post Login actions are not yet supported for Custom Token Exchange and will result in the transaction failing with a non-recoverable error; similarly, transactions will also fail when MFA is configured as a tenant policy
* Custom DB Connections with [Import Users to Auth0](/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) enabled are not supported for `setUserByConnection()` operations
* Specific impersonation support (e.g. actor token and actor claim)
* Third-Party and Non-OIDC Conformant Clients

## Rate Limits

Custom Token Exchange requests to the `/oauth/token` endpoint are rate limited at 10% of the global Authentication API rate limit for the applicable performance tier.

<table class="table"><thead>
<tr>
<th><strong>Performance Tier</strong></th>
<th><strong>Global Authentication API limit (RPS)</strong></th>
<th><strong>Custom Token Exchange limit (RPS)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Enterprise</td>
<td>100</td>
<td>10</td>
</tr>
<tr>
<td>Private Cloud Basic (1x)</td>
<td>100</td>
<td>10</td>
</tr>
<tr>
<td>Private Cloud Performance (5x)</td>
<td>500</td>
<td>50</td>
</tr>
<tr>
<td>Private Cloud Performance (15x)</td>
<td>1500</td>
<td>150</td>
</tr>
<tr>
<td>Private Cloud Performance (30x)</td>
<td>3000</td>
<td>300</td>
</tr>
<tr>
<td>Private Cloud Performance (60x)</td>
<td>6000</td>
<td>600</td>
</tr>
<tr>
<td>Private Cloud Performance (100x)</td>
<td>10000</td>
<td>1000</td>
</tr>
</tbody>
</table>

Read requests on `api/v2/token-exchange-profiles` endpoints are also rate limited as follows:

<table class="table"><thead>
<tr>
<th>Performance Tier</th>
<th>Custom Token Exchange limit (RPS)</th>
<th>Custom Token Exchange limit (RPM)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enterprise</td>
<td>20</td>
<td>200</td>
</tr>
<tr>
<td>Private Cloud Basic (1x)</td>
<td>20</td>
<td>200</td>
</tr>
<tr>
<td>Private Cloud Performance (5x)</td>
<td>100</td>
<td>300</td>
</tr>
<tr>
<td>Private Cloud Performance (15x)</td>
<td>300</td>
<td>3000</td>
</tr>
<tr>
<td>Private Cloud Performance (30x)</td>
<td>600</td>
<td>6000</td>
</tr>
<tr>
<td>Private Cloud Performance (60x)</td>
<td>1200</td>
<td>12000</td>
</tr>
<tr>
<td>Private Cloud Performance (100x)</td>
<td>2000</td>
<td>20000</td>
</tr>
</tbody>
</table>

## Entity Limits

A maximum of 100 Custom Token Exchange profiles can be created per tenant.

The total number of Actions is also limited depending on your Auth0 plan. To learn more, read [Auth0's Pricing Page](https://auth0.com/pricing).

## Troubleshoot

### "Consent required" response

You may receive an `invalid_request` error with a `consent_required` error description when calling the `/oauth/token` endpoint.

To resolve this issue, enable the **Allow Skipping User Consent** option for your API in the Auth0 Dashboard.

<Frame>![](/images/cdy7uua7fh8z/4eKWTJtCQwSHUZyKU81mWm/33c1966367d2b7c157b414fa1f04c026/Screenshot_2025-02-03_at_5.36.38_PM.png)</Frame>