---
og:description: Learn how to keep users logged in to your application using silent
  authentication.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: サイレント認証を設定する
og:url: https://auth0.com/docs/
permalink: configure-silent-authentication
title: サイレント認証を設定する
twitter:description: Learn how to keep users logged in to your application using silent
  authentication.
twitter:title: サイレント認証を設定する
---

[OpenID Connectのプロトコル](/protocols/openid-connect-protocol)は、認証要求の`prompt=none`パラメーターをサポートしているので、アプリケーションは、認証サーバーにユーザーとのやりとり（認証や承諾、MFAなど）を一切表示しないよう指示できます。Auth0は要求された応答をアプリケーションに返すか、ユーザーがまだ認証されていない場合や、処理を進める前に何らかの同意やプロンプトが必要な場合はエラーを返します。

SPAで[暗黙フロー](/login/flows/implicit-flow-with-form-post)を使用すると、明示的な緩和策を必要とするセキュリティ上の課題につながります。[PKCEを使った認可コードフロー](/login/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)をサイレント認証と組み合わせて使用することで、SPAのセッションを更新できます。



## サイレント認証要求を開始する

サイレント認証要求を開始するには、[Auth0の認証APIのエンドポイント`/authorize`](/api/authentication#authorize-application)にユーザーをリダイレクトする際に、`prompt=none`パラメーターを追加します。（認証要求の個々のパラメーターは、アプリの特定のニーズに応じて異なります）。

例：



`prompt=none`パラメーターにより、Auth0は指定された`redirect_uri`（コールバックURL）に、指定された`response_mode`を使用して、成功またはエラーの2つのうちいずれかの応答を即座に送信します。



### 認証成功の応答

ユーザーがすでにAuth0にログインしており、他の対話型プロンプトが不要な場合、Auth0は、ユーザーがログインページから手動で認証を受けた場合とまったく同じように応答します。

たとえば、暗黙フロー（シングルページアプリケーションで使用される`response_type=id_token token`）を使用すると、Auth0は次のように、要求されたトークンを返します。



この応答は、`prompt=none`パラメーターを使用せずに直接ログインした場合と区別がつきません。

### エラーの応答

ユーザーがシングルサインオン（SSO）経由でログインしていなかった場合、またはSSOセッションが期限切れとなっていた場合、Auth0は次のように、指定された`redirect_uri`（コールバックURL）にエラーとともにリダイレクトします。



`ERROR_CODE`が取り得る値は、[OpenID Connect仕様](https://openid.net/specs/openid-connect-core-1_0.html#AuthError)によって次のように定義されています。



これらのいずれかのエラーが返された場合、ユーザーは`prompt=none`パラメーターなしでAuth0のログインページにリダイレクトされて、認証を受ける必要があります。

## 期限切れトークンを更新する

ユーザーがAuth0で有効なセッションを保持している限り、新しいトークンを取得するためにサイレント認証要求を行うことができます。[auth0.jsのメソッド`checkSession`](/libraries/auth0js)は、SPA用に`response_mode=web_message`と組み合わせてサイレントトークン要求を使用して、要求が非表示のiframe内で実行されるようにします。SPAでは、Auth0.jsが結果処理（トークンまたはエラーコード）を処理し、アプリケーションが提供するコールバック関数を通じて情報を渡します。これにより、UXが中断されること（ページの再読み込みや状態の喪失）はありません。



### アクセストークンの有効期限

アクセストークンはアプリケーションに対して不透明です。つまり、アプリケーションはアクセストークンの有効期限を判断するためにその内容を検査できません。

アクセストークンの有効期限を判断するには、2通りの方法があります。

* Auth0から返される`expires_in`応答パラメーターを読み取りる。
* 有効期限は完全に無視する。その代わりに、アプリケーションからの要求をAPIが拒否した場合（401など）にアクセストークンを更新する。

[暗黙フロー](/login/flows/implicit-flow-with-form-post)の場合、認証が成功すると、Auth0から`expires_in`パラメーターがハッシュパラメーターとして返されます。[PKCEを使った認可コードフロー](/login/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)では、認可コードの交換を行う際にバックエンドサーバーにこのパラメーターが返されます。

`expires_in`パラメーターは、アクセストークンが何秒間有効であるかを示し、アクセストークンの有効期限切れを予測するために使用できます。

### エラーの応答

`web_message`通信の実行中にタイムアウトが発生したことを示す`timeout`エラー応答を受信することがあります。このエラーは通常、クロスオリジン認証へのフォールバックと関連しています。解決するには、Auth0 Dashboardを使用して、サイレント認証を実行したいすべてのURLを、アプリケーションの**［Allowed Web Origins（許可されているWebオリジン）］**フィールドに追加してください。

## `checkSession()`でポーリングする



## 多要素認証によるサイレント認証

状況によっては、同じブラウザーを使ってログインしているユーザーに対し、[多要素認証（MFA）](/mfa)を求めるプロンプトを毎回表示したくない場合があります。これを実行するには、セッションごとにMFAが1回だけ発生するようにアクションを設定します。これは、`allowRememberBrowser`を`true`に設定することなく、ユーザーのセッションの期間中に、SPA内で有効期限の短いアクセストークンを更新するためのサイレント認証（`prompt=none`）を行う場合に便利です。



詳細については、[認証要求頻度を変更する](/mfa/customize-mfa-user-pages)を参照してください。